<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|华文行楷:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mdreamers.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="追梦">
<meta property="og:url" content="https://mdreamers.github.io/index.html">
<meta property="og:site_name" content="追梦">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lbl">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mdreamers.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>追梦</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">追梦</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mdreamers.github.io/2021/07/28/3-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven-m9q6e9.jpg">
      <meta itemprop="name" content="lbl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/28/3-%E6%A0%91/" class="post-title-link" itemprop="url">3.树和森林</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-28 21:41:41" itemprop="dateCreated datePublished" datetime="2021-07-28T21:41:41+08:00">2021-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 18:57:25" itemprop="dateModified" datetime="2021-07-30T18:57:25+08:00">2021-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树是n（n&geqslant;0）个结点的有限集.</p>
<ul>
<li>n=0，空树</li>
<li>n&gt;0，则满足以下条件<ul>
<li><strong>有且仅有一个</strong> 特定的称为 <strong>根</strong> 的结点</li>
<li>其余节点可分为m（m&geqslant;0）个互不相交的有限集T1，T2，T3……，Tm，其中每一个集合本身又是一棵树，并称为根的 <strong>子树</strong></li>
</ul>
</li>
</ul>
<h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p><strong>根节点</strong>：非空树中无前驱结点的结点</p>
<p><strong>结点的度</strong>：结点拥有的子树数</p>
<p><strong>树的度</strong>：树内各结点的度的最大值</p>
<p><strong>度=0</strong> —&gt; 称为 <strong>叶子结点</strong>（终端结点）</p>
<p><strong>度≠0</strong> —&gt; 称为 <strong>分支结点</strong>（非终端节点）</p>
<p>根节点以外的分支结点称为 <strong>内部节点</strong></p>
<p>结点的子树的根称为该结点的 <strong>孩子</strong>，该结点称为孩子的 <strong>双亲</strong></p>
<p><strong>兄弟</strong>：深度相同，双亲结点相同</p>
<p><strong>堂兄弟</strong>：深度相同，双亲结点不同</p>
<p>结点的 <strong>祖先</strong>：从根到该结点所经分支上的所有结点</p>
<p>结点的 <strong>子孙</strong>：以某结点为根的子树中的任一结点</p>
<p><strong>树的深度</strong>：树中结点的最大层次</p>
<p><strong>有序树</strong>：树中结点的各子树从左至右有次序</p>
<p><strong>无序树</strong>：树中结点的各子树无次序</p>
<p><strong>森林</strong>：是m（m&geqslant;0）棵互不相交的树的集合</p>
<h1 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>二叉树是n（n&geqslant;0）个结点的有限集.或是空集，或是一个根节点和两棵不相交的分别称作这个根的左子树和右子树的二叉树组成</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>每个结点最多有两个孩子（二叉树中不存在度大于2的结点）</li>
<li>子树有左右之分，其次序不能颠倒</li>
<li>二叉树可以是空集合，根可以有空的左子树或空的右子树</li>
</ol>
<p><strong>注意</strong>：二叉树 <strong>不是</strong> 树的特殊情况，它们是两个概念</p>
<p><strong>二叉树</strong> 结点的子树要 <strong>区分左子树和右子树</strong>，即使只有一棵子树也要区分，说明它是左子树，还是右子树</p>
<p><strong>树</strong> 当节点只有一个孩子时，就 <strong>无需区分</strong> 它是左还是右的次序，因此二者是不同的。这是二叉树与树的最主要差别</p>
<h2 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADT BinaryTree&#123;</span><br><span class="line">    数据对象D:  D是具有相同特性的数据元素的集合。</span><br><span class="line">    数据关系R:  若D=Φ,则R=Φ;</span><br><span class="line">                若D≠Φ,则R=&#123;H&#125;;H是如下二元关系:</span><br><span class="line">                <span class="number">1.</span>root唯一      <span class="comment">//关于根的说明</span></span><br><span class="line">                <span class="number">2.</span>D_j∩D_k=Φ     <span class="comment">//关于子树不相交的说明</span></span><br><span class="line">                <span class="number">3.</span>……            <span class="comment">//关于数据元素的说明</span></span><br><span class="line">                <span class="number">4.</span>……            <span class="comment">//关于左子树和右子树的说明</span></span><br><span class="line">    基本操作P</span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><blockquote>
<p>所有的结点都在，即深度为k且右 $2^k-1$ 个结点的二叉树称为满二叉树</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的 <strong>满二叉树</strong> 中 <strong>编号</strong> 为1~n的结点 <strong>一一对应</strong> 时，称之为完全二叉树。</p>
</blockquote>
<p><strong>注：</strong> 满二叉树中，最后一个结点开始，<strong>连续</strong> 去掉 <strong>任意</strong> 个结点，即是一棵完全二叉树</p>
<p><strong>满二叉树一定是完全二叉树</strong></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.具有n个节点的完全二叉树深度为 $\lfloor \log_2n \rfloor +1$</p>
<p>注：$\lfloor x \rfloor$：称作x的底，表示不大于x的最大整数</p>
<p>2.如果对对一棵有n个结点的完全二叉树，结点按层序编号，则对 <strong>任一结点i</strong>(i&leqslant;i&leqslant;n),有：</p>
<ul>
<li>如果i = 1，则结点i是二叉树的根，无双亲；如果 i&gt;1 ，则其双亲是 <strong>结点 $\lfloor i/2 \rfloor$</strong></li>
<li>如果2i &gt; n，则结点i为叶子结点，无左孩子；否则，其 <strong>左孩子是结点 2i</strong></li>
<li>如果2i+1 &gt; n，则结点i无右孩子；否则，其 <strong>右孩子是结点 2i+1</strong> </li>
</ul>
<h2 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h2><p>实现：按 <strong>满二叉树</strong> 的结点层次编号，依次存放二叉树中的数据元素<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTSIZE 100</span></span><br><span class="line">Typedef TElemTye SqBiTree[MAXTSIZE]</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>:<br>会浪费空间，所以适合 <strong>满二叉树</strong> 和 <strong>完全二叉树</strong></p>
<h2 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h2><p><strong>二叉链表</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<p>n个结点的二叉链表中有，<strong>n+1</strong> 个空指针域</p>
<ul>
<li>因为每个非空指针域都存放着一个结点</li>
</ul>
<p><strong>三叉链表</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>&#123;</span></span><br><span class="line">    TelemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>*<span class="title">parent</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="comment">//比二叉节点多了一个双亲指针</span></span><br><span class="line">&#125;TriTNode,*TriTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p><strong>方法</strong><br>假设：L：遍历左子树，D：访问根结点，R：遍历右子树</p>
<p>遍历方案共有六种：DLR、LDR、LRD、DRL、RLD</p>
<p>若规定 <strong>先左后右</strong>，则只有前三种情况：</p>
<ul>
<li><strong>DLR</strong>——先序（根）遍历</li>
<li><strong>LDR</strong>——中序（根）遍历</li>
<li><strong>LRD</strong>——后序（根）遍历</li>
</ul>
<p><strong>先序遍历递归算法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre</span><span class="params">(BiTree *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;data);</span><br><span class="line">        pre(T-&gt;lchild);</span><br><span class="line">        pre(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>中序遍历非递归算法</strong><br>算法设计思路：使用栈<br><strong>二叉树的层次遍历</strong><br>算法设计思路：使用一个队列</p>
<ul>
<li>将根节点进队;</li>
<li>队不空时循环：从队列中出列一个结点*p，访问它；<ul>
<li>若它有左孩子结点，将左孩子结点进队；</li>
<li>若它有右孩子结点，将右孩子结点进队。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">    BTNode *p; SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(qu,b);<span class="comment">//根结点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu))&#123;<span class="comment">//队不为空，则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出队结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//访问结点p</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">            enQueue(qu,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">            enQueue(qu,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h2><ul>
<li>若二叉树中各结点的值均不相同，则二叉树的结点的先序序列，中序序列，后序序列都是唯一的</li>
<li>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树</li>
</ul>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><p>C语言描述<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTree,*pBiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">pBiTree <span class="title">Create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(pBiTree )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pBiTree p=<span class="literal">NULL</span>;</span><br><span class="line">	p=Create();</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建成功\n&quot;</span>);</span><br><span class="line">	traverse(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;遍历成功\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pBiTree <span class="title">Create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	pBiTree T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		T=(pBiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">		T-&gt;data = ch;</span><br><span class="line">		T-&gt;lchild=Create();</span><br><span class="line">		T-&gt;rchild=Create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(pBiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,T-&gt;data);</span><br><span class="line">		traverse(T-&gt;lchild);</span><br><span class="line">		traverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线索二叉树-Threaded-Binary-Tree"><a href="#线索二叉树-Threaded-Binary-Tree" class="headerlink" title="线索二叉树(Threaded Binary Tree)"></a>线索二叉树(Threaded Binary Tree)</h2><p>问题：如何寻找特定遍历序列中二叉树结点的前驱和后继</p>
<p>解决方法：</p>
<ol>
<li>通过遍历寻找—-费时间</li>
<li>再增设前驱、后继指针域—-增加存储负担</li>
<li><p><strong>利用二叉链表中的空指针域</strong></p>
<ul>
<li>如果某个结点的左孩子为空，则将空的左孩子指针域改为 <strong>指向其前驱</strong>；如果某结点的右孩子为空，则将空的右孩子指针域改为 <strong>指向其后继</strong>——这种改变指向的指针称为“线索”</li>
</ul>
<p>为区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：</p>
<ul>
<li>l(r)tag = 0 l(r)child指向该结点的左（右）孩子</li>
<li>l(r)tag = 1 l(r)child指向该结点的前驱（后继）</li>
</ul>
<p><strong>增设了一个头结点</strong>以中序遍历为例）：</p>
<ul>
<li>ltag=0,lchild指向根结点，</li>
<li>rtag=1,rchild指向遍历序列中最后一个结点</li>
<li>遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点</li>
</ul>
</li>
</ol>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>实现：</p>
<ul>
<li>定义结构数组存放树的结点，每个结点含两个域<ul>
<li>数据域：存放结点本身信息</li>
<li>双亲域：指示本结点的双亲结点在数组中的位置</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//树的结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r,n;    <span class="comment">//根结点位置和结点个数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure>
<h2 id="双亲表示法-1"><a href="#双亲表示法-1" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储</p>
<p><strong>特点</strong><br>找孩子容易，找双亲难</p>
<p><strong>孩子结点结构</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*childPtr;</span><br></pre></td></tr></table></figure></p>
<p><strong>双亲结点结构</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CTbox;</span><br></pre></td></tr></table></figure></p>
<p><strong>树结构</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;    <span class="comment">//结点数和根结点的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉链表表示法"><a href="#二叉链表表示法" class="headerlink" title="二叉链表表示法"></a>二叉链表表示法</h2><p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其 <strong>第一个孩子结点</strong> 和 <strong>下一个兄弟结点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<h1 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h1><ul>
<li>将树转换成二叉树进行处理，利用二叉树的算法实现对数的操作</li>
<li>由于树和二叉树都可以用二叉链表作存储结构，则 <strong>以二叉链表作媒介</strong> 可以导出树与二叉树之间的一个对应关系。</li>
</ul>
<p><strong>口诀：兄弟相连留长子</strong></p>
<h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><blockquote>
<p>森林是m(m&geqslant;0)棵互不相交的树的集合<br>森林—-&gt;树—-&gt;二叉树</p>
</blockquote>
<p>森林变二叉树：树变二叉根相连</p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><p><strong>1.树的遍历方式（三种）</strong></p>
<ul>
<li><strong>先根（次序）遍历</strong>：<ul>
<li>若树不空，则先访问根结点，然后依次先根遍历各课子树</li>
</ul>
</li>
<li><strong>后根（次序）遍历</strong>:<ul>
<li>若树不空，则先依次后根遍历各棵子树，然后访问根结点</li>
</ul>
</li>
<li><strong>按层次遍历</strong>：<ul>
<li>若树不空，则自上而下自左至右访问树中每个结点</li>
</ul>
</li>
</ul>
<p><strong>2.森林的遍历</strong><br>将森林看作由三部分构成：</p>
<ul>
<li>森林中第一棵树的根结点；</li>
<li>森林中第一棵树的子树森林</li>
<li><p>森林中其它树构成的森林</p>
</li>
<li><p><strong>先序遍历</strong></p>
<ul>
<li>若树不空，则</li>
<li><strong>访问森林中第一棵树的根结点</strong></li>
<li>先序遍历森林中第一棵树的子树森林</li>
<li>先序遍历森林中（除第一棵树外）其余树构成的森林<blockquote>
<p>即依次从左至右对森林中的每一棵树进行先根遍历</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>中序遍历</strong></p>
<ul>
<li>若树不空，则</li>
<li>中序遍历森林中第一棵树的子树森林</li>
<li>访问森林中第一棵树的根结点</li>
<li>中序遍历森林中（除第一棵树外）其余树构成的森林<blockquote>
<p>即依次从左到右对森林中的每一棵树进行后根遍历</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.<strong>路径</strong>：从树中一个结点到另一个结点之间的 <strong>分支</strong> 构成这两个结点间的路径</p>
<p>2.<strong>结点的路径长度</strong>：两个结点路径上的 <strong>分支数</strong></p>
<p>3.<strong>树的路径长度</strong>：从 <strong>树根</strong> 到每个结点的 <strong>路径长度之和</strong>。记作：TL</p>
<p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p>
<p>4.<strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权</p>
<p>5.<strong>结点的带权路径长度</strong>：从根结点到该结点之间的 <strong>路径长度</strong> 与该结点的 <strong>权</strong> 的 <strong>乘积</strong></p>
<p>6.<strong>树的带权路径长度</strong>：树中所有 <strong>叶子</strong> 结点的 <strong>带权路径长度之和</strong> 记WPL</p>
<h2 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h2><p><strong>哈夫曼算法</strong></p>
<ul>
<li>构造森林全是根</li>
<li>选用两小造新树</li>
<li>删除两小添新人</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mdreamers.github.io/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven-m9q6e9.jpg">
      <meta itemprop="name" content="lbl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">2.栈和队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-27 22:28:45" itemprop="dateCreated datePublished" datetime="2021-07-27T22:28:45+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 00:02:23" itemprop="dateModified" datetime="2021-07-30T00:02:23+08:00">2021-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>栈和队列是线性表的子集（是插入和删除位置受限的线性表）</strong></p>
<h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><blockquote>
<p>限定只能在表的一端进行插入和删除运算的线性表</p>
</blockquote>
<p>又称为后进先出(Last In First Out)的线性表，简称 <strong>LIFO</strong> 结构</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>栈是进行插入、删除操作的线性表。</p>
<p>表尾称为 <strong>栈顶</strong> Top；表头称为 <strong>栈底</strong> Base</p>
<p>插入元素到 <strong>栈顶</strong> 的操作称为 <strong>入栈</strong> PUSH</p>
<p>从 <strong>栈顶</strong> 删除最后一个元素的操作，称为 <strong>出栈</strong> POP</p>
<p>逻辑结构：一对一</p>
<p>存储结构：用 <strong>顺序栈</strong> 或 <strong>链栈</strong> 均可，顺序栈更常见</p>
<p>运算规则：只能在栈顶运算，且访问结点时依照LIFO原则</p>
<p>分类：</p>
<ul>
<li>静态栈</li>
<li>动态栈</li>
</ul>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>设 <strong>top</strong> 指针，指示栈顶元素在顺序栈中的位置</li>
<li>设 <strong>base</strong> 指针，指示栈底元素在顺序栈中的位置<br>为了方便操作，通常top指示真正的栈顶元素之上</li>
<li>用 <strong>stacksize</strong> 表示栈可使用的最大容量</li>
<li>空栈：base==top</li>
<li>栈满：top-base==stacksize</li>
</ul>
<h2 id="C语言实现链栈的相关操作"><a href="#C语言实现链栈的相关操作" class="headerlink" title="C语言实现链栈的相关操作"></a>C语言实现链栈的相关操作</h2><p>顺序栈也类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,* PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PNODE pTop;</span><br><span class="line">	PNODE pBottom;</span><br><span class="line">&#125;STACK,* PSTACK;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK,<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	STACK S;<span class="comment">//内存里面有了两个变量pTop,pBottom</span></span><br><span class="line"></span><br><span class="line">	init(&amp;S);<span class="comment">//造出一个空栈</span></span><br><span class="line">	push(&amp;S,<span class="number">1</span>);<span class="comment">//压栈</span></span><br><span class="line">	push(&amp;S,<span class="number">2</span>);</span><br><span class="line">	traverse(&amp;S);</span><br><span class="line">	clear(&amp;S);</span><br><span class="line">	<span class="comment">//traverse(&amp;S);</span></span><br><span class="line">	<span class="keyword">if</span>(pop(&amp;S, &amp;val))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈成功，出栈的元素是%d\n&quot;</span>,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(&amp;S);<span class="comment">//遍历输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (pS-&gt;pTop == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pS-&gt;pBottom = pS-&gt;pTop;</span><br><span class="line">		pS-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>;<span class="comment">//pS-&gt;pBottom-&gt;pNext = NULL; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pS,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	pNew-&gt;data = val;</span><br><span class="line">	pNew-&gt;pNext = pS-&gt;pTop;<span class="comment">//pS-&gt;pTop不能改成pS-&gt;pBottom</span></span><br><span class="line">	pS-&gt;pTop = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNODE p = pS-&gt;pTop;</span><br><span class="line">	<span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把pS所指向的栈出栈一次，并把出栈的元素存入pVal形参所指向的变量中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pS,<span class="keyword">int</span> * pVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE r =pS-&gt;pTop;</span><br><span class="line">		*pVal = r-&gt;data;</span><br><span class="line">		pS-&gt;pTop=r-&gt;pNext;</span><br><span class="line">		r = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE p = pS-&gt;pTop;	</span><br><span class="line">		<span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">		&#123;</span><br><span class="line">			pS-&gt;pTop = p-&gt;pNext;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">			p = pS-&gt;pTop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>进制转换</strong></p>
<p><strong>括号匹配</strong></p>
<p><strong>表达式求值：</strong></p>
<ul>
<li>表达式组成<ul>
<li>操作符(operand)：常数、变量</li>
<li>运算符(operator)：算术运算符、关系运算符和逻辑运算符</li>
<li>界限符(delimiter)：左右括弧和表达式结束符</li>
</ul>
</li>
<li>需要两个栈：<ul>
<li>算符栈OPTR，用于寄存运算符</li>
<li>操作数栈OPND,用于寄存运算数和运算结果</li>
</ul>
</li>
<li>求值的处理过程是自左向右扫描表达式的每一个字符<ul>
<li>当扫描的是数字，将其压入栈OPND</li>
<li>当扫描到的是运算符<ul>
<li>若这个运算符比OPTR栈顶运算符优先级高，则入栈OPTR</li>
<li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，将运算结果压入栈OPND</li>
</ul>
</li>
</ul>
</li>
<li>继续处理当前字符，直到结束符为止</li>
</ul>
<h1 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h1><blockquote>
<p>只能在表头的一端进行插入运算，在表的另一端进行删除运算的线性表</p>
</blockquote>
<p>队列是一种 <strong>先进先出</strong>(First In First Out—<strong>FLFO</strong>)的线性表。在表一段插入（表尾），在另一端（表头）删除</p>
<h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><p>逻辑结构：一对一</p>
<p>存储结构：<strong>顺序队</strong> 或 <strong>链队</strong>，以循环顺序队列更常见</p>
<p>运算规则：只能在队首和队尾运算，且访问结点时依照FIFO的原则</p>
<p>分类：</p>
<ul>
<li><p>链式队列：用链表实现</p>
</li>
<li><p>静态队列：用数组实现</p>
<ul>
<li>静态队列通常都必须是循环队列</li>
</ul>
</li>
</ul>
<p>循环队列：</p>
<ol>
<li>静态队列为什么必须是循环队列</li>
<li>循环队列需要几个参数来确定</li>
<li>循环队列各个参数的含义</li>
<li>循环队列入队伪算法</li>
<li>循环队列出队伪算法</li>
<li>如何判断循环队列是否为空</li>
<li>如何判断循环队列是否已满</li>
</ol>
<h2 id="队列顺序表示和实现"><a href="#队列顺序表示和实现" class="headerlink" title="队列顺序表示和实现"></a>队列顺序表示和实现</h2><p>设立一个队首指针front,一个队尾指针rear，分别指向队首和队尾元素</p>
<ul>
<li>初始化：front=rear=0</li>
<li>入队：将新元素插入rear所指的位置，然后rear加1</li>
<li>出队：删去front所指的元素，然后加1并返回被删元素</li>
<li>队列为空：front == rear</li>
<li>队满：rear == MAX_QUEUE_SIZE-1或front==rear</li>
</ul>
<p>在非空队列里，队首指针始终指向队头元素，而队尾指针始终指向队尾元素的下一位置。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>1.顺序队列中存在 <strong>“假溢出”</strong> 现象。</p>
<p><strong>假溢出:</strong> 尾指针已超出向量空间的上界而不能做入队操作</p>
<p><strong>解决方法</strong>：引入循环队列<br>C呈现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span> == MAX_QUEUE_SIZE)</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	i++;</span><br></pre></td></tr></table></figure><br><strong>用模运算可简化为</strong>：i=(i+1) % MAX_QUEUE_SIZE;</p>
<p>2.队空和队满时头尾指针均相等，<strong>无法通过front=rear来判断队列”空”，还是”满”</strong>。</p>
<p><strong>解决方法</strong>:</p>
<ul>
<li>1.另外 <strong>设一个标志tag</strong> 以区别队空、队满（如队满为1，队空为0）</li>
<li>2.另外设一个变量，记录元素个数</li>
<li>3.<strong>少用一个元素空间</strong><ul>
<li>队空：front==rear</li>
<li>队满：(rear+1)%MAX_QUEUE_SIZE==font<br><img src="/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/queue1.png"></li>
</ul>
</li>
</ul>
<h2 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h2><ul>
<li>队列初始化：分配空间，头尾指针置为0</li>
<li><strong>队列长度</strong>：(reat-front+MAX_QUEUE_SIZE)%MAX_QUEUE_SIZE</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mdreamers.github.io/2021/07/26/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven-m9q6e9.jpg">
      <meta itemprop="name" content="lbl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="post-title-link" itemprop="url">1.线性表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-26 13:17:57" itemprop="dateCreated datePublished" datetime="2021-07-26T13:17:57+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-27 22:34:55" itemprop="dateModified" datetime="2021-07-27T22:34:55+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>就是指把所有的结点用一根 <strong>直线</strong>  串起来</p>
<h1 id="连续存储-数组"><a href="#连续存储-数组" class="headerlink" title="连续存储[数组]"></a>连续存储[数组]</h1><p>1.数组是元素类型相同，大小相等的一组数</p>
<p><strong>优缺点</strong><br>优点：存取速度很快</p>
<p>缺点：</p>
<ul>
<li>事先必须知道数组的长度</li>
<li>插入删除元素很慢</li>
<li>空间通常有限制</li>
<li>需要大块连续的内存块</li>
</ul>
<h1 id="离散存储-链表"><a href="#离散存储-链表" class="headerlink" title="离散存储[链表]"></a>离散存储[链表]</h1><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，首结点没有前驱结点，尾结点没有后续结点</p>
<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>空间没有限制 </li>
<li>插入删除元素很快</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储密度小，每个结点的指针域需要额外占用存储空间<br>存储密度=结点数据所占空间/该结点所占的总空间</li>
<li>链式存储结构是 <strong>非随机存取</strong> 结构，对任一结点的操作都要从头指针链查找到该结点，这增加了算法的复杂度</li>
</ul>
<p>专业术语：</p>
<ul>
<li>结点：数据元素的映像。由数据域和指针域两部分组成</li>
<li>首元结点：第一个有效结点</li>
<li>尾结点：最后一个有效结点</li>
<li>头结点：<ul>
<li>头结点的数据类型和首结点类型一样</li>
<li>第一个有效结点之前的那个结点</li>
<li>头结点并不存放有效数据</li>
<li>加头结点的目的是方便对链表的操作</li>
</ul>
</li>
<li>头指针：指向头结点的指针变量</li>
<li>尾指针：指向尾结点的指针变量</li>
</ul>
<p><strong>如果希望通过一个函数来对链表进行处理我们至少需要接受哪些参数？</strong><br>只需要一个参数：头指针</p>
<p>因为我们可以通过头指针推算出链表的其他所有参数</p>
<p><strong>创建链表,并完成一些功能</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE,*PNODE; <span class="comment">//NODE等价于struct Node,  PNODE等价于struct Node *</span></span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//输出链表的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE)</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//判断链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//链表排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;<span class="comment">//向链表中插入一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span>,<span class="keyword">int</span>*)</span></span>;<span class="comment">//删除链表中的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;<span class="comment">//等价于struct Node*pHead = NULL;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">	pHead = create_list();<span class="comment">//create_list()功能：创建一个非循环单链表</span></span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	<span class="comment">//int len = length_list(pHead);</span></span><br><span class="line">	<span class="comment">//printf(&quot;链表长度为%d\n&quot;,len);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//insert_list(pHead,4,33);//插入结点</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	<span class="keyword">if</span>(delete_list(pHead,<span class="number">4</span>,&amp;val))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除成功，你删除的元素是：%d\n&quot;</span>,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败，删除的元素不存在\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	<span class="comment">//sort_list(pHead);</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	<span class="keyword">if</span>(is_empty(pHead))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表为空\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表不空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//用来存放有效结点的个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> val;<span class="comment">//用来临时存放用户输入的结点的值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入结点个数：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="comment">//分配了一个不存放有效数字的头结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配失败，程序终止/n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    <span class="comment">//规定pTail永远指向尾结点，这里也就是指向头结点</span></span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d结点的值：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;分配失败，程序终止\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pTail-&gt;pNext = pNew;<span class="comment">//这里是让Ptail指针域存放临时结点</span></span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;<span class="comment">//清空临时结点的指针域</span></span><br><span class="line">        pTail = pNew;<span class="comment">//这里是pTail指针指向了pNew</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pHead-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNODE p = pHead-&gt;pNext;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,t;</span><br><span class="line">	<span class="keyword">int</span> len = length_list(pHead);</span><br><span class="line">	PNODE p,q;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++,p=p-&gt;pNext)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>,q=p-&gt;pNext;j&lt;len;j++,q=q-&gt;pNext)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)<span class="comment">//类似于数组中的：a[i]&gt;a[j]</span></span><br><span class="line">			&#123;</span><br><span class="line">				t=p-&gt;data;</span><br><span class="line">				p-&gt;data=q-&gt;data;</span><br><span class="line">				q-&gt;data=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pHead所指向的链表的第pos个结点的前面插入一个新的结点，</span></span><br><span class="line"><span class="comment">//该结点的值是val,并且pos的值是从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	PNODE p =pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span>(pNew == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态分配内存失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;data=val;</span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	p-&gt;pNext=pNew;</span><br><span class="line">	pNew-&gt;pNext=q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> *pVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	*pVal = q-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除p结点后面的结点</span></span><br><span class="line">	p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	q = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分类：</strong></p>
<ul>
<li>单链表</li>
<li>双向链表：每一个结点有两个 <strong>指针域</strong></li>
<li>循环单链表:能通过任何一个结点找到其他所有的结点</li>
<li>循环双向链表</li>
<li>非循环链表</li>
</ul>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>尾指针指向头结点</p>
<p><strong>优点：</strong></p>
<ul>
<li>如果表的操作常常是在表的首尾位置进行，用循环链表可以方便寻找，降低时间复杂度</li>
</ul>
<p><strong>循环链表的合并</strong></p>
<ul>
<li>p存表头结点</li>
<li>Tb表头连接到Ta表尾</li>
<li>释放Tb表头结点</li>
<li>修改指针</li>
</ul>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表的每个结点再增加一个指向其直接前驱的指针域prior。</p>
<p><strong>优点:</strong><br>容易查找前驱结点和后续结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span>&#123;</span></span><br><span class="line">	Elemtype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuNode,*DuPNode;</span><br></pre></td></tr></table></figure>
<h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><ul>
<li>建立单链表<ul>
<li>头插法—元素插在链表头部<ul>
<li>1.从一个空表开始</li>
<li>2.生成新结点，将读入数据存放到新结点的数据域中</li>
<li>3.最后一个结点开始依次将各结点插入到链表的前端</li>
</ul>
</li>
<li>尾插法—元素插入在链表尾部</li>
</ul>
</li>
<li>遍历</li>
<li>查找</li>
<li>清空</li>
<li>销毁</li>
<li>求长度</li>
<li>排序</li>
<li>删除结点<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>错误案例</span><br><span class="line">p-&gt;pNext=p-&gt;pNext-&gt;pNext;<span class="comment">//因为没有free所删除的结点，所以这样会让内存泄漏</span></span><br><span class="line"><span class="number">2.</span>正确写法</span><br><span class="line">r=p-&gt;pNext;<span class="comment">//r指向p后面的那个结点</span></span><br><span class="line">p-&gt;pNext=r-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);<span class="comment">//必须</span></span><br></pre></td></tr></table></figure></li>
<li>插入结点<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">r=p-&gt;pNext;<span class="comment">//先用r来存放p的指针域</span></span><br><span class="line">p-&gt;pNext=q;<span class="comment">//使p的指针域指向插入的q结点</span></span><br><span class="line">q-&gt;pNext=r;<span class="comment">//q的指针域就是原来p的指针域</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">q-&gt;pNext=p-&gt;pNext;<span class="comment">//插入的q的指针域替换成p的指针域</span></span><br><span class="line">p-&gt;pNext=q;<span class="comment">//p的指针域指向q</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mdreamers.github.io/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven-m9q6e9.jpg">
      <meta itemprop="name" content="lbl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" class="post-title-link" itemprop="url">0.数据结构与算法知识储备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-25 09:55:34" itemprop="dateCreated datePublished" datetime="2021-07-25T09:55:34+08:00">2021-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-27 22:31:11" itemprop="dateModified" datetime="2021-07-27T22:31:11+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/frame.png"></p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><blockquote>
<p>能输入计算机且能被计算机处理的 <strong>各种符号的集合</strong></p>
</blockquote>
<ul>
<li>是信息的载体</li>
<li>是对客观事物符号化的表示</li>
<li>能够被计算机识别，存储和加工</li>
</ul>
<p>包括：</p>
<ul>
<li>数值型数据：整数、实数等</li>
<li>非数值型数据：文字、图像、图形、声音等</li>
</ul>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><ul>
<li>是数据的 <strong>基本单位</strong>,在计算机程序中通常作为一个整体进行考虑和处理。</li>
<li>也简称为元素，或称为记录、结点或顶点。</li>
<li>一个 <strong>数据元素</strong> 可由若干个 <strong>数据项</strong> 组成</li>
</ul>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><ul>
<li>构成数据元素的不可分割的 <strong>最小单位</strong></li>
</ul>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><ul>
<li>是 <strong>性质相同的数据元素的集合</strong>，是数据的一个子集</li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p><strong>数据结构</strong> 是一门研究非数值计算的程序设计中计算机的操作对象以及它们之间的关系和操作的学科</p>
</blockquote>
<p>数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为 <strong>结构</strong></p>
<p>数据结构是指 <strong>相互之间存在一种或多种特定关系</strong> 的数据元素集合</p>
<p>数据结构包括以下三个方面的内容：</p>
<ol>
<li>数据元素之间的逻辑关系，也称为逻辑结构</li>
<li>数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的 <strong>物理结构</strong> 或数据的 <strong>存储结构</strong></li>
<li>数据的 <strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现</li>
</ol>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul>
<li>描述数据元素之间的逻辑关系</li>
<li>与数据的存储无关，独立于计算机</li>
<li>是从具体问题抽象出来的数学模型</li>
</ul>
<p><strong>种类</strong><br><strong>划分方法一</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li>有且仅有一个开始和一个终端结点，并且所有结点最多只有一个直接前驱和一个直接后继。如：线性表、栈、队列、串</li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li>一个节点可能有多个直接前驱和直接后继。如树、图</li>
</ul>
</li>
</ul>
<p><strong>划分方法二</strong><br>(1)<strong>集合结构</strong>：结构中的数据元素之间除了 <strong>同属于一个集合</strong> 的关系外，无其他任何关系</p>
<p>(2)<strong>线性结构</strong>：结构中的数据元素之间存在着 <strong>一对一</strong> 的线性关系</p>
<p>(3)<strong>树形结构</strong>：结构中的数据元素之间存在 <strong>一对多</strong> 的层次关系</p>
<p>(4)<strong>图状结构</strong> 或 <strong>网状结构</strong>：结构中的数据元素之间存在着 <strong>多对多</strong> 的任意关系</p>
<h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><ul>
<li>数据元素及其关系在计算机存储器中的结构（存储方式）</li>
<li>是数据结构在计算机中的表示</li>
</ul>
<p><strong>种类</strong></p>
<ul>
<li>顺序存储结构<ul>
<li>用一组 <strong>连续</strong> 的存储单元 <strong>依次</strong> 存储数据元素，数据元素之间的逻辑关系由元素的 <strong>存储位置</strong> 来表示</li>
<li>C语言中用数组来实现顺序存储结构</li>
</ul>
</li>
<li>链式存储结构<ul>
<li>用一组 <strong>任意</strong> 的存储单元存储数据元素，数据元素之间的逻辑关系用 <strong>指针</strong> 来表示</li>
<li>C语言中用指针来实现链式存储结构</li>
</ul>
</li>
<li>索引存储结构<ul>
<li>在存储节点信息的同时，还建立附加的 <strong>索引表</strong></li>
<li>索引表中的每一项称为一个 <strong>索引项</strong></li>
<li>索引项的 <strong>一般形式</strong> 是：(关键字，地址)</li>
<li>关键字是能 <strong>唯一标识</strong> 一个结点的那些数据项</li>
<li>若每个节点在索引表中都有一个索引项，则该索引表称之为 <strong>稠密索引</strong>。若一组结点在索引表中只对应一个索引项，则该索引表称之为 <strong>稀疏索引</strong></li>
</ul>
</li>
<li>散列存储结构<ul>
<li>根据结点的关键字直接计算出该节点的存储地址</li>
</ul>
</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul>
<li>存储结构是逻辑关系的映像与元素本身的映像</li>
<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li>
</ul>
<h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><h3 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h3><blockquote>
<p>定义：数据类型是一组性质相同的 <strong>值的集合</strong> 以及定义这个集合上的 <strong>一组操作</strong> 的总称</p>
</blockquote>
<p><strong>数据类型 = 值的集合 + 值集合上的一组操作</strong> </p>
<ul>
<li>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的 <strong>数据类型</strong><ul>
<li>例如，C语言中：<ul>
<li>提供int,char,float,double等基本数据类型</li>
<li>数组、结构、共用体、枚举等构造数据类型</li>
<li>还有指针、空(void)类型</li>
<li>用户也可用typedef自己定义数据类型</li>
</ul>
</li>
</ul>
</li>
<li>一些最基本数据结构可以用数据类型来实现，如数组、字符串等；</li>
<li>而另一些常用的数据结构。如栈、队列、树、图等，不能直接用数据类型来表示。</li>
</ul>
<p>数据类型的作用</p>
<ul>
<li>约束变量或常量的取值范围</li>
<li>约束变量或常量的操作</li>
</ul>
<h3 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type,ADT)"></a>抽象数据类型(Abstract Data Type,ADT)</h3><blockquote>
<p>是指一个数学模型以及定义在此数学模型上的一组操作</p>
</blockquote>
<ul>
<li>由用户定义，从问题抽象出 <strong>数据模型</strong>（逻辑结构）</li>
<li>还包括定义在数据模型上的一组 <strong>抽象运算</strong>（相关操作）</li>
<li>不考虑计算机内的具体存储结构与运算的具体实现算法</li>
</ul>
<p>抽象数据类型 = 数据的逻辑结构 + 抽象运算</p>
<p><strong>抽象数据类型的形式定义</strong><br>抽象数据类型可用（D,S,P）<strong>三元组</strong> 表示</p>
<p>其中：D是数据对象；S是D上的关系集；P是对D的基本操作集</p>
<p>一个抽象数据类型的 <strong>定义格式</strong> 如下<br><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">	数据对象：<span class="attribute">&lt;数据对象的定义&gt;</span></span><br><span class="line">	数据关系：<span class="attribute">&lt;数据关系的定义&gt;</span></span><br><span class="line">	基本操作：<span class="attribute">&lt;基本操作的定义&gt;</span></span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><br>其中：</p>
<ul>
<li>数据对象、数据关系的定义用伪代码描述</li>
<li>基本操作的定义格式为：<ul>
<li>基本操作名：（参数表）</li>
<li>初始条件：（初始条件描述）</li>
<li>操作结果：（操作结果描述）</li>
</ul>
</li>
</ul>
<p><strong>基本操作</strong> 定义格式说明</p>
<p>参数表：</p>
<ul>
<li>赋值参数 只为操作提供输入值</li>
<li>引用参数以&amp;打头，除可提供输入值外，还将返回操作结果 </li>
</ul>
<p>初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。</p>
<p>操作结果：说明操作完成之后，数据结构的变化状况和应返回的结果</p>
<p><strong>抽象数据类型如何实现</strong></p>
<ul>
<li>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示和实现<ul>
<li>即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/知识总结.png"></p>
<h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><blockquote>
<p>算法的定义：对特定问题 <strong>求解方法和步骤</strong> 的一种描述，它是 <strong>指令</strong> 的有限 <strong>序列</strong>。其中每个指令表示一个或多个操作 </p>
</blockquote>
<p><strong>算法:</strong></p>
<ul>
<li><p>狭义的算法是与数据的存储方式密切相关</p>
</li>
<li><p>广义的算法是与数据的存储方式无关</p>
</li>
<li><p>泛型：利用某种技术达到的效果就是：不同的存数方式，执行的操作是一样的</p>
<h2 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h2></li>
<li>自然语言：英语、中文</li>
<li>流程图：传统流程图、NS流程图</li>
<li>伪代码：类语言：类C语言</li>
</ul>
<h2 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h2><ul>
<li><strong>算法</strong> 是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法</li>
<li><strong>程序</strong> 是用某种程序设计语言对算法的具体实现。</li>
</ul>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<ul>
<li>数据结构通过算法实现操作</li>
<li>算法根据数据结构设计程序</li>
</ul>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li>有穷性：一个算法必须总是 在执行有穷步之后结束，且每一步都在又穷时间内完成</li>
<li>确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出</li>
<li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li>
<li>输入：一个算法有零个或多个输入</li>
<li>输入：一个算法有一个或多个输出</li>
</ul>
<h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
</ul>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><blockquote>
<p>目的是看算法实际是否可行，并在同一问题存在多的算法时可进行性能上的比较，以便从中挑选出比较优的算法</p>
</blockquote>
<p>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑 <strong>算法的效率</strong>,通过算法的效率高低来评判不同算法的优劣程度</p>
<p>效率从两方面考虑：</p>
<ol>
<li><strong>时间效率</strong>：指的是算法耗费的 <strong>时间</strong></li>
<li><strong>空间效率</strong>：指的是算法执行过程中所耗费的 <strong>存储空间</strong></li>
</ol>
<p><strong>时间效率和空间效率有时候是矛盾的</strong></p>
<h3 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h3><p>算法的时间效率可以依据该算法编制的程序在计算机上执行 <strong>所消耗的时间</strong> 来度量</p>
<p><strong>方法</strong></p>
<ul>
<li>事后统计<ul>
<li>将算法实现，测算其时间和空间开销</li>
<li>缺点：编写程序实现算法将花费较多的时间和精力；所得到实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣</li>
</ul>
</li>
<li>事前分析<ul>
<li>对算法所消耗的资源的一种估算方法</li>
</ul>
</li>
</ul>
<p><strong>事前分析方法</strong></p>
<ul>
<li>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的 <strong>时间</strong> 与算法中进行的简单操作 <strong>次数乘积</strong><br><strong>算法运行时间 = 一个简单操作所需的时间 × 简单操作次数</strong></li>
<li>也即算法中每条语句的时间之和<br>  算法运行时间 = &sum; 每条语句的执行次数 &times; 该语句执行一次所需的时间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++&gt;)<span class="comment">//n+1次</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++&gt;)&#123;<span class="comment">//n(n+1)次</span></span><br><span class="line">		c[i][j]=<span class="number">0</span>;<span class="comment">//n*n次</span></span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//n*n*(n+1)次</span></span><br><span class="line">			c[i][j]=c[i][j]+a[i][k]*b[k][j];<span class="comment">//n*n*n次</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们把算法所耗费的时间定义为该算法中 <strong>每条语句的频度之和</strong>，则上述算法的时间消耗T(n)为：<br>$T(n)=2n^3+3n^2+2n+1$</li>
</ul>
<ul>
<li>为了便于比较不同算法的时间效率，我们仅比较它们的数量级</li>
</ul>
<p>所以用时间复杂度表示,则$T(n)$可记作<br>$T(n)=O(n^3)$</p>
<h3 id="算法空间效率的度量"><a href="#算法空间效率的度量" class="headerlink" title="算法空间效率的度量"></a>算法空间效率的度量</h3><blockquote>
<p><strong>空间复杂度</strong>：算法所需存储空间的度量</p>
</blockquote>
<p>记作：$S(n)=O(f(n))$</p>
<p>其中 <strong>n</strong> 为问题的规模（或大小）</p>
<ul>
<li>算法要占据的空间<ul>
<li>算法本身要占据的空间，输入/输出，指令，常数，变量等 </li>
<li>算法要使用的 <strong>辅助空间</strong></li>
</ul>
</li>
</ul>
<p><strong>算法一</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">	t = a[i];</span><br><span class="line">	a[i] = a[n-i<span class="number">-1</span>];</span><br><span class="line">	a[n-i<span class="number">-1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>空间复杂度$S(n)=O(1)$</p>
<p><strong>算法二</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	b[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	a[i]=b[i];</span><br></pre></td></tr></table></figure><br>空间复杂度$S(n)=O(n)$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mdreamers.github.io/2021/07/23/CSS%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9D%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven-m9q6e9.jpg">
      <meta itemprop="name" content="lbl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/23/CSS%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9D%9F/" class="post-title-link" itemprop="url">CSS基本结束</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-23 15:20:07" itemprop="dateCreated datePublished" datetime="2021-07-23T15:20:07+08:00">2021-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-24 10:49:27" itemprop="dateModified" datetime="2021-07-24T10:49:27+08:00">2021-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>257</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html lang="ch-ZN">
<head>
    <style type="text/css">
        .box:hover{
            -webkit-transform: rotateX(90deg);
        }
    </style>
</head>
<body>
    <ul style="margin-top:40px">
        <li style="width:100px;height:35px;margin:0;padding:0;border:0;line-height: 35px;text-align: center; list-style:none;-webkit-perspective:500px;">
            <div class="box" style="position:relative;width:100%;height:100%;-webkit-transform-style:preserve-3d;-webkit-transition:all .4s;">
                <div style="position:absolute;top:0;left:0;width:100%;background-color:skyblue;color:#fff;-webkit-transform:translateZ(17.5px);">结束?</div>
                <div style="position:absolute;top:0;left:0;width:100%;background-color:#c7edcc;color:#000;-webkit-transform:translateY(17.5px) rotateX(-90deg);">想多了……</div>
                </div>
            
        </li>
    </ul>
</body>
</html>

<p>花了两天的时间，在这里记录一下。这两天完成了一个购物网站的主页，列表页，注册页的制作，但是这只是初步完成，搭建了基本框架，完成了样式优化，这里只用了html5和CSS对网页进行初步搭建，还不是真正意义上的网页，后面还需要学习JavaScript进行进一步的优化，CSS基本结束，但是还有很多细节需要去了解和积累，之后的JavaScript vue……要学有的东西很多很多，很长的路要走，慢慢积累，继续加油吧……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lbl"
      src="/images/wallhaven-m9q6e9.jpg">
  <p class="site-author-name" itemprop="name">lbl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

       <!-- require APlayer -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    <!-- require MetingJS-->
    <script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
	<!--网易云-->
    <div class="aplayer"
      data-id="2773494627"
      data-server="netease"
      data-type="playlist"
      data-fixed="false"
      data-autoplay="false"
      data-list-folded="true"
      data-mutex="true"
      data-order="random"
      data-loop="all"
      data-volume="0.4"
      data-theme="#FADFA3"
      date-preload="auto" >
    </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lbl</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">130k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:59</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
