<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0.CSS的一些规范和特性</title>
    <url>/2021/07/20/0-CSS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS代码规范"><a href="#CSS代码规范" class="headerlink" title="CSS代码规范"></a>CSS代码规范</h1><h2 id="样式格式书写"><a href="#样式格式书写" class="headerlink" title="样式格式书写"></a>样式格式书写</h2><p>(1) 紧凑格式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">color</span>: red;<span class="attribute">font-size</span>: <span class="number">20px</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>(2) 展开格式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式大小写"><a href="#样式大小写" class="headerlink" title="样式大小写"></a>样式大小写</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">COLOR</span>: PINK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>样式选择器，属性名，属性值关键字虽然大小写都行，但最好使用 <strong>小写字母</strong> ,特殊情况除外。</p>
<h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) 属性值前面，冒号后面，保留一个空格</p>
<p>(2) 选择器（标签）和大括号中间保留空格</p>
<h2 id="CSS-属性书写顺序"><a href="#CSS-属性书写顺序" class="headerlink" title="CSS 属性书写顺序"></a>CSS 属性书写顺序</h2><ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow（建议display第一个写）</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient…</li>
</ol>
<h1 id="CSS-引入方式"><a href="#CSS-引入方式" class="headerlink" title="CSS 引入方式"></a>CSS 引入方式</h1><h2 id="CSS-的三种样式表"><a href="#CSS-的三种样式表" class="headerlink" title="CSS 的三种样式表"></a>CSS 的三种样式表</h2><p>1.行内样式表（行内式）</p>
<p>2.内部样式表（嵌入式）</p>
<p>3.外部样式表（链接式）</p>
<h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>内部样式表就是在html页面内部写样式，但是单独写到style标签内部<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#ff0</span>00;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>&lt;style&gt; 标签里理论上可以放在HTML文档的任何地方，但一般会放在文档的&lt;head&gt; 标签中</li>
<li>通过此种方式可以方便控制当前整个页面元素样式设置</li>
<li>代码结构清晰，但是没有实现结构与样式完全分离</li>
</ul>
<h2 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h2><p>在元素标签内部的sytle属性中设定CSS样式，修改一些简单样式<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red;font-size: 12px;&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>不推荐大量使用</p>
<h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><p>适用于样式比较多的情况下，核心:样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。</p>
<p>引入外部样式表的步骤：<br>1.新建一个后缀名为.css的样式文件,把所有CSS代码都放到此文件中。 </p>
<p>2.在HTML页面中，使用&lt;link&gt;标签引入这个文件。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rel</td>
<td style="text-align:left">定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”,表示被链接文档是一个样式表文件</td>
</tr>
<tr>
<td style="text-align:left">href</td>
<td style="text-align:left">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</td>
</tr>
</tbody>
</table>
</div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">样式表</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">行内样式表</td>
<td style="text-align:left">书写方便，权重高</td>
<td style="text-align:left">控制一个标签</td>
</tr>
<tr>
<td style="text-align:left">内部样式表</td>
<td style="text-align:left">部分结构和样式相分离</td>
<td style="text-align:left">控制一个页面</td>
</tr>
<tr>
<td style="text-align:left">外部样式表</td>
<td style="text-align:left">完全实现结构和样式相分离</td>
<td style="text-align:left">控制多个页面</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS-的三大特性"><a href="#CSS-的三大特性" class="headerlink" title="CSS 的三大特性"></a>CSS 的三大特性</h1><blockquote>
<p>CSS有三个非常重要的特性：层叠性、继承性、优先级。</p>
</blockquote>
<h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><p>相同选择器给设置的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。</p>
<p>层叠性原则：</p>
<ul>
<li>样式冲突：就近原则那个样式离结构近，就执行哪个样式</li>
<li>样式不冲突，不会层叠。</li>
</ul>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>CSS中的继承：<strong>子标签</strong> 会继承 <strong>父标签</strong> 的某些样式，如文本颜色和字号</p>
<ul>
<li>恰当使用继承可以简化代码，降低CSS样式的复杂性</li>
<li>子标签可以继承父标签的样式（text-,font-,line- 以及color属性）</li>
</ul>
<p><strong>行高的继承</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">12px</span>/<span class="number">1.5</span> Microsoft YaHei</span><br><span class="line">    这个<span class="number">1.5</span>就是当前元素文字大小font-size的<span class="number">1.5</span>倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>行高可以跟单位也可以不跟单位</li>
</ul>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当同一个元素指定多个选择器，就会有优先级产生。</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，则根据 <strong>选择器权重</strong> 执行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">选择器权重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">继承或*</td>
<td style="text-align:left">0,0,0,0</td>
</tr>
<tr>
<td style="text-align:left">元素选择器</td>
<td style="text-align:left">0,0,0,1</td>
</tr>
<tr>
<td style="text-align:left">类选择器，伪类选择器</td>
<td style="text-align:left">0,0,1,0</td>
</tr>
<tr>
<td style="text-align:left">ID选择器</td>
<td style="text-align:left">0,1,0,0</td>
</tr>
<tr>
<td style="text-align:left">行内样式style=””</td>
<td style="text-align:left">1,0,0,0</td>
</tr>
<tr>
<td style="text-align:left">!important 重要的</td>
<td style="text-align:left">无穷大</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意点</strong></p>
<ul>
<li>权重是有4组数字组成，但是不会有进位</li>
<li>等级判断从左向右，如果某一位数值相同，则判断下一位数值。</li>
<li><strong>继承的权重是0</strong>,如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是0。</li>
</ul>
<p><strong>权重叠加</strong>：如果是复合选择器，则会有权重叠加，需要计算权重</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>0.数据结构与算法知识储备</title>
    <url>/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/frame.png"></p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><blockquote>
<p>能输入计算机且能被计算机处理的 <strong>各种符号的集合</strong></p>
</blockquote>
<ul>
<li>是信息的载体</li>
<li>是对客观事物符号化的表示</li>
<li>能够被计算机识别，存储和加工</li>
</ul>
<p>包括：</p>
<ul>
<li>数值型数据：整数、实数等</li>
<li>非数值型数据：文字、图像、图形、声音等</li>
</ul>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><ul>
<li>是数据的 <strong>基本单位</strong>,在计算机程序中通常作为一个整体进行考虑和处理。</li>
<li>也简称为元素，或称为记录、结点或顶点。</li>
<li>一个 <strong>数据元素</strong> 可由若干个 <strong>数据项</strong> 组成</li>
</ul>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><ul>
<li>构成数据元素的不可分割的 <strong>最小单位</strong></li>
</ul>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><ul>
<li>是 <strong>性质相同的数据元素的集合</strong>，是数据的一个子集</li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p><strong>数据结构</strong> 是一门研究非数值计算的程序设计中计算机的操作对象以及它们之间的关系和操作的学科</p>
</blockquote>
<p>数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为 <strong>结构</strong></p>
<p>数据结构是指 <strong>相互之间存在一种或多种特定关系</strong> 的数据元素集合</p>
<p>数据结构包括以下三个方面的内容：</p>
<ol>
<li>数据元素之间的逻辑关系，也称为逻辑结构</li>
<li>数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的 <strong>物理结构</strong> 或数据的 <strong>存储结构</strong></li>
<li>数据的 <strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现</li>
</ol>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul>
<li>描述数据元素之间的逻辑关系</li>
<li>与数据的存储无关，独立于计算机</li>
<li>是从具体问题抽象出来的数学模型</li>
</ul>
<p><strong>种类</strong><br><strong>划分方法一</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li>有且仅有一个开始和一个终端结点，并且所有结点最多只有一个直接前驱和一个直接后继。如：线性表、栈、队列、串</li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li>一个节点可能有多个直接前驱和直接后继。如树、图</li>
</ul>
</li>
</ul>
<p><strong>划分方法二</strong><br>(1)<strong>集合结构</strong>：结构中的数据元素之间除了 <strong>同属于一个集合</strong> 的关系外，无其他任何关系</p>
<p>(2)<strong>线性结构</strong>：结构中的数据元素之间存在着 <strong>一对一</strong> 的线性关系</p>
<p>(3)<strong>树形结构</strong>：结构中的数据元素之间存在 <strong>一对多</strong> 的层次关系</p>
<p>(4)<strong>图状结构</strong> 或 <strong>网状结构</strong>：结构中的数据元素之间存在着 <strong>多对多</strong> 的任意关系</p>
<h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><ul>
<li>数据元素及其关系在计算机存储器中的结构（存储方式）</li>
<li>是数据结构在计算机中的表示</li>
</ul>
<p><strong>种类</strong></p>
<ul>
<li>顺序存储结构<ul>
<li>用一组 <strong>连续</strong> 的存储单元 <strong>依次</strong> 存储数据元素，数据元素之间的逻辑关系由元素的 <strong>存储位置</strong> 来表示</li>
<li>C语言中用数组来实现顺序存储结构</li>
</ul>
</li>
<li>链式存储结构<ul>
<li>用一组 <strong>任意</strong> 的存储单元存储数据元素，数据元素之间的逻辑关系用 <strong>指针</strong> 来表示</li>
<li>C语言中用指针来实现链式存储结构</li>
</ul>
</li>
<li>索引存储结构<ul>
<li>在存储节点信息的同时，还建立附加的 <strong>索引表</strong></li>
<li>索引表中的每一项称为一个 <strong>索引项</strong></li>
<li>索引项的 <strong>一般形式</strong> 是：(关键字，地址)</li>
<li>关键字是能 <strong>唯一标识</strong> 一个结点的那些数据项</li>
<li>若每个节点在索引表中都有一个索引项，则该索引表称之为 <strong>稠密索引</strong>。若一组结点在索引表中只对应一个索引项，则该索引表称之为 <strong>稀疏索引</strong></li>
</ul>
</li>
<li>散列存储结构<ul>
<li>根据结点的关键字直接计算出该节点的存储地址</li>
</ul>
</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul>
<li>存储结构是逻辑关系的映像与元素本身的映像</li>
<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li>
</ul>
<h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><h3 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h3><blockquote>
<p>定义：数据类型是一组性质相同的 <strong>值的集合</strong> 以及定义这个集合上的 <strong>一组操作</strong> 的总称</p>
</blockquote>
<p><strong>数据类型 = 值的集合 + 值集合上的一组操作</strong> </p>
<ul>
<li>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的 <strong>数据类型</strong><ul>
<li>例如，C语言中：<ul>
<li>提供int,char,float,double等基本数据类型</li>
<li>数组、结构、共用体、枚举等构造数据类型</li>
<li>还有指针、空(void)类型</li>
<li>用户也可用typedef自己定义数据类型</li>
</ul>
</li>
</ul>
</li>
<li>一些最基本数据结构可以用数据类型来实现，如数组、字符串等；</li>
<li>而另一些常用的数据结构。如栈、队列、树、图等，不能直接用数据类型来表示。</li>
</ul>
<p>数据类型的作用</p>
<ul>
<li>约束变量或常量的取值范围</li>
<li>约束变量或常量的操作</li>
</ul>
<h3 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type,ADT)"></a>抽象数据类型(Abstract Data Type,ADT)</h3><blockquote>
<p>是指一个数学模型以及定义在此数学模型上的一组操作</p>
</blockquote>
<ul>
<li>由用户定义，从问题抽象出 <strong>数据模型</strong>（逻辑结构）</li>
<li>还包括定义在数据模型上的一组 <strong>抽象运算</strong>（相关操作）</li>
<li>不考虑计算机内的具体存储结构与运算的具体实现算法</li>
</ul>
<p>抽象数据类型 = 数据的逻辑结构 + 抽象运算</p>
<p><strong>抽象数据类型的形式定义</strong><br>抽象数据类型可用（D,S,P）<strong>三元组</strong> 表示</p>
<p>其中：D是数据对象；S是D上的关系集；P是对D的基本操作集</p>
<p>一个抽象数据类型的 <strong>定义格式</strong> 如下<br><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">	数据对象：<span class="attribute">&lt;数据对象的定义&gt;</span></span><br><span class="line">	数据关系：<span class="attribute">&lt;数据关系的定义&gt;</span></span><br><span class="line">	基本操作：<span class="attribute">&lt;基本操作的定义&gt;</span></span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><br>其中：</p>
<ul>
<li>数据对象、数据关系的定义用伪代码描述</li>
<li>基本操作的定义格式为：<ul>
<li>基本操作名：（参数表）</li>
<li>初始条件：（初始条件描述）</li>
<li>操作结果：（操作结果描述）</li>
</ul>
</li>
</ul>
<p><strong>基本操作</strong> 定义格式说明</p>
<p>参数表：</p>
<ul>
<li>赋值参数 只为操作提供输入值</li>
<li>引用参数以&amp;打头，除可提供输入值外，还将返回操作结果 </li>
</ul>
<p>初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。</p>
<p>操作结果：说明操作完成之后，数据结构的变化状况和应返回的结果</p>
<p><strong>抽象数据类型如何实现</strong></p>
<ul>
<li>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示和实现<ul>
<li>即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/知识总结.png"></p>
<h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><blockquote>
<p>算法的定义：对特定问题 <strong>求解方法和步骤</strong> 的一种描述，它是 <strong>指令</strong> 的有限 <strong>序列</strong>。其中每个指令表示一个或多个操作 </p>
</blockquote>
<p><strong>算法:</strong></p>
<ul>
<li><p>狭义的算法是与数据的存储方式密切相关</p>
</li>
<li><p>广义的算法是与数据的存储方式无关</p>
</li>
<li><p>泛型：利用某种技术达到的效果就是：不同的存数方式，执行的操作是一样的</p>
<h2 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h2></li>
<li>自然语言：英语、中文</li>
<li>流程图：传统流程图、NS流程图</li>
<li>伪代码：类语言：类C语言</li>
</ul>
<h2 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h2><ul>
<li><strong>算法</strong> 是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法</li>
<li><strong>程序</strong> 是用某种程序设计语言对算法的具体实现。</li>
</ul>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<ul>
<li>数据结构通过算法实现操作</li>
<li>算法根据数据结构设计程序</li>
</ul>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li>有穷性：一个算法必须总是 在执行有穷步之后结束，且每一步都在又穷时间内完成</li>
<li>确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出</li>
<li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li>
<li>输入：一个算法有零个或多个输入</li>
<li>输入：一个算法有一个或多个输出</li>
</ul>
<h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
</ul>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><blockquote>
<p>目的是看算法实际是否可行，并在同一问题存在多的算法时可进行性能上的比较，以便从中挑选出比较优的算法</p>
</blockquote>
<p>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑 <strong>算法的效率</strong>,通过算法的效率高低来评判不同算法的优劣程度</p>
<p>效率从两方面考虑：</p>
<ol>
<li><strong>时间效率</strong>：指的是算法耗费的 <strong>时间</strong></li>
<li><strong>空间效率</strong>：指的是算法执行过程中所耗费的 <strong>存储空间</strong></li>
</ol>
<p><strong>时间效率和空间效率有时候是矛盾的</strong></p>
<h3 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h3><p>算法的时间效率可以依据该算法编制的程序在计算机上执行 <strong>所消耗的时间</strong> 来度量</p>
<p><strong>方法</strong></p>
<ul>
<li>事后统计<ul>
<li>将算法实现，测算其时间和空间开销</li>
<li>缺点：编写程序实现算法将花费较多的时间和精力；所得到实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣</li>
</ul>
</li>
<li>事前分析<ul>
<li>对算法所消耗的资源的一种估算方法</li>
</ul>
</li>
</ul>
<p><strong>事前分析方法</strong></p>
<ul>
<li>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的 <strong>时间</strong> 与算法中进行的简单操作 <strong>次数乘积</strong><br><strong>算法运行时间 = 一个简单操作所需的时间 × 简单操作次数</strong></li>
<li>也即算法中每条语句的时间之和<br>  算法运行时间 = &sum; 每条语句的执行次数 &times; 该语句执行一次所需的时间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++&gt;)<span class="comment">//n+1次</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++&gt;)&#123;<span class="comment">//n(n+1)次</span></span><br><span class="line">		c[i][j]=<span class="number">0</span>;<span class="comment">//n*n次</span></span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//n*n*(n+1)次</span></span><br><span class="line">			c[i][j]=c[i][j]+a[i][k]*b[k][j];<span class="comment">//n*n*n次</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们把算法所耗费的时间定义为该算法中 <strong>每条语句的频度之和</strong>，则上述算法的时间消耗T(n)为：<br>$T(n)=2n^3+3n^2+2n+1$</li>
</ul>
<ul>
<li>为了便于比较不同算法的时间效率，我们仅比较它们的数量级</li>
</ul>
<p>所以用时间复杂度表示,则$T(n)$可记作<br>$T(n)=O(n^3)$</p>
<h3 id="算法空间效率的度量"><a href="#算法空间效率的度量" class="headerlink" title="算法空间效率的度量"></a>算法空间效率的度量</h3><blockquote>
<p><strong>空间复杂度</strong>：算法所需存储空间的度量</p>
</blockquote>
<p>记作：$S(n)=O(f(n))$</p>
<p>其中 <strong>n</strong> 为问题的规模（或大小）</p>
<ul>
<li>算法要占据的空间<ul>
<li>算法本身要占据的空间，输入/输出，指令，常数，变量等 </li>
<li>算法要使用的 <strong>辅助空间</strong></li>
</ul>
</li>
</ul>
<p><strong>算法一</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">	t = a[i];</span><br><span class="line">	a[i] = a[n-i<span class="number">-1</span>];</span><br><span class="line">	a[n-i<span class="number">-1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>空间复杂度$S(n)=O(1)$</p>
<p><strong>算法二</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	b[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	a[i]=b[i];</span><br></pre></td></tr></table></figure><br>空间复杂度$S(n)=O(n)$</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0. 知识储备</title>
    <url>/2021/06/16/0.%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="和号-sum"><a href="#和号-sum" class="headerlink" title="和号$\sum$"></a>和号$\sum$</h1><p>${\large a}_1+{\large a}_2+\cdots+{\large a}_n<br>=\sum\limits_{i=1}^n {\large a}_i$</p>
<p>${\large a}_{11}+{\large a}_{12}+\cdots+{\large a}_{1m}<br>=\sum\limits_{j=1}^n {\large a}_{1j}$</p>
<p>${\large a}_1x_1+{\large a}_2x_2+{\large a}_3x_3<br>=\sum\limits_{i=1}^3 {\large a}_ix_i$</p>
<p>$\sum\limits_{i=1}^3 ({\large a}_i+{\large b}_i)x_i<br>=\sum\limits_{i=1}^3 {\large a}_ix_i+<br>\sum\limits_{i=1}^3 {\large b}_ix_i$</p>
<p>$\sum\limits_{i=1}^n {\large a}_i<br>=\sum\limits_{j=1}^n {\large a}_j$</p>
<p>$\sum\limits_{i=1}^n k{\large a}_i<br>=k\sum\limits_{i=1}^n {\large a}_i$<br><br></p>
<ul>
<li>双和号<br>$<br>\begin{array}{lll}<br>{\large a}_{11} + {\large a}_{12} + \cdots+ {\large a}_{1n}<br>= \sum\limits_{j=1}^n {\large a}_{1j}\\<br>{\large a}_{21} + {\large a}_{22} + \cdots+ {\large a}_{2n}<br>= \sum\limits_{j=1}^n {\large a}_{2j}\\<br>\vdots\qquad\quad\vdots\qquad\quad\;\qquad\vdots\\<br>{\large a}_{m1} + {\large a}_{m2} + \cdots + {\large a}_{mm}<br>= \sum\limits_{j=1}^n {\large a}_{mj}\\<br>\downarrow\qquad\quad\downarrow\qquad\qquad\downarrow\\<br>\sum\limits_{i=1}^m {\large a}_{i1}\,<br>\sum\limits_{i=1}^m {\large a}_{i2}\;\cdots\;<br>\sum\limits_{i=1}^m {\large a}_{in}<br>\end{array}<br>$<br><br>先横着相加再竖着相加：<br>$\sum\limits_{j=1}^n {\large a}_{1j}+\sum\limits_{j=1}^n<br>{\large a}_{2j}+\cdots+\sum\limits_{j=1}^n<br>{\large a}_{mj}=\sum\limits_{i=1}^m\sum\limits_{j=1}^n {\large a}_{ij}$<br><br>按竖着相加再横着相加：<br>$\sum\limits_{i=1}^m {\large a}_{i1}+<br>\sum\limits_{i=1}^m {\large a}_{i2}+\cdots+\sum\limits_{i=1}^m<br>{\large a}_{in}=\sum\limits_{j=1}^n\sum\limits_{i=1}^m {\large a}_{ij}$<br><br>所以$\sum\limits_{i=1}^m\sum\limits_{j=1}^n {\large a}_{ij}<br>=\sum\limits_{j=1}^n\sum\limits_{i=1}^m {\large a}_{ij}$<br><br>未完待续……</li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>1.CSS选择器</title>
    <url>/2021/07/20/1-CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>分类</strong>： <strong>基础选择器</strong> 和 <strong>复合选择器</strong> </p>
<p><strong>作用</strong>：选择标签</p>
<h1 id="CSS-基础选择器"><a href="#CSS-基础选择器" class="headerlink" title="CSS 基础选择器"></a>CSS 基础选择器</h1><blockquote>
<p> 基础选择器是由 <strong>单个</strong> 选择器组成的</p>
</blockquote>
<p>基础选择器包括：标签选择器、类选择器、id选择器和通配符选择器</p>
<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>标签选择器是用 <strong>HTML标签名</strong> 作为选择器，按标签名称分类，为页面中的某一类标签指定统一的CSS样式。</p>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类标签</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，将所有拥有red类的HTML元素均为红色。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结构需要 <strong>class</strong> 属性来调用class类<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&#x27;red&#x27;&gt;红色&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><br><strong>注意:</strong><br>(1) 类选择器使用”.”进行标识，后面紧跟类名(自定义)</p>
<p>(2) 长名称或词组可以使用 <strong>中横线</strong> 来为选择器命名</p>
<p>(3) 不要使用纯数字、中文等命名，尽量使用英文字母</p>
<p>(4) 命名要有意义</p>
<p>(5) <strong>类命名规则:</strong> 查web文档</p>
<h2 id="类选择器-多类名"><a href="#类选择器-多类名" class="headerlink" title="类选择器-多类名"></a>类选择器-多类名</h2><p>一个标签可以指定多个类名，从而达到更多的选择目的<br>1.使用多类名的方法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;red font20&quot;&gt;hh&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><br>(1) 在标签class属性中写多个类名<br>(2) 多个类名中间必须用空格分开<br>(3) 每个标签就可以分别具有这些类名的样式</p>
<h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>用”#”定义<br>基本语法<br> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>选择器名称 &#123;</span><br><span class="line">    CSS属性:属性值</span><br><span class="line">    CSS属性:属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意:</p>
<p>1.id是唯一性元素，一个页面上 <strong>不允许两个元素具有相同的id</strong>。一个HTML元素，也只允许使用一个id，<strong>不允许以空格分隔的id列表</strong></p>
<p>2.当不确定时，有多个html元素来使用该样式时，使用类选择器</p>
<p>3.id选择器的优先级高于class选择器的优先级。</p>
<h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><p>用”*”定义，表示选取页面中的所有元素（标签）<br>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>注意:</strong></p>
<ul>
<li>通配符选择器不需要调用，自动就给所有元素使用样式</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">基础选择器</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标签选择器</td>
<td style="text-align:left">可以选出所有相同元素</td>
<td style="text-align:left">p{color: red;}</td>
</tr>
<tr>
<td style="text-align:left">类选择器</td>
<td style="text-align:left">可以选出1个或者多个标签</td>
<td style="text-align:left">.nav{color: red;}</td>
</tr>
<tr>
<td style="text-align:left">id选择器</td>
<td style="text-align:left">一次只能选择一个标签</td>
<td style="text-align:left">#nav{color: red;}</td>
</tr>
<tr>
<td style="text-align:left">通配符选择器</td>
<td style="text-align:left">选择所有标签</td>
<td style="text-align:left">*{color: red;}</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS-复合选择器"><a href="#CSS-复合选择器" class="headerlink" title="CSS 复合选择器"></a>CSS 复合选择器</h1><blockquote>
<p>复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的</p>
</blockquote>
<p>常用复合选择器包括：后代选择器，子选择器，并集选择器，伪类选择器等</p>
<h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>可以选择 <strong>父类元素里面的子元素</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素<span class="number">1</span> 元素<span class="number">2</span> &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h2><p>只能选择作为某元素最近一级子元素<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素<span class="number">1</span>&gt;元素<span class="number">2</span> &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>可以选择多组标签，同时为他们定义相同样式</p>
<p>通过逗号，（和的意思）连接而成</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素<span class="number">1</span>,</span><br><span class="line">元素<span class="number">2</span> &#123; </span><br><span class="line">	样式声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>用于某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素</p>
<p>伪类选择器书写用冒号:表示</p>
<h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器元素</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a:link</td>
<td style="text-align:left">选择所有未被访问的链接</td>
</tr>
<tr>
<td style="text-align:left">a:visited</td>
<td style="text-align:left">选择所有已被访问的链接</td>
</tr>
<tr>
<td style="text-align:left">a:hover</td>
<td style="text-align:left">选择鼠标指针位于其上的链接</td>
</tr>
<tr>
<td style="text-align:left">a:active</td>
<td style="text-align:left">选择活动链接（鼠标按下未弹起的链接）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意:</strong></p>
<ul>
<li>必须按照顺序LVHA，要不然会不起作用</li>
<li>因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</li>
</ul>
<h3 id="focus-伪类选择器"><a href="#focus-伪类选择器" class="headerlink" title=":focus 伪类选择器"></a>:focus 伪类选择器</h3><p>:focus 伪类选择器用于选取获得焦点的表单元素。<br>焦点是光标，一般情况&lt;input&gt;类表单元素才能获取，因此这个选择器也主要针对于表单元素来说</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">后代选择器</td>
<td style="text-align:left">选择父类里面的子元素</td>
<td style="text-align:left">空格</td>
</tr>
<tr>
<td style="text-align:left">子代选择器</td>
<td style="text-align:left">选择父类里面 <strong>最近一级的子元素元素</strong></td>
<td style="text-align:left">大于&gt;</td>
</tr>
<tr>
<td style="text-align:left">并集选择器</td>
<td style="text-align:left">选择某些样式相同的元素</td>
<td style="text-align:left">逗号,</td>
</tr>
<tr>
<td style="text-align:left">链接伪类选择器</td>
<td style="text-align:left">选择不同状态的链接</td>
<td style="text-align:left">冒号，重点记住a{}和a:hover</td>
</tr>
<tr>
<td style="text-align:left">:focus伪类选择器</td>
<td style="text-align:left">选择获得光标的表单</td>
<td style="text-align:left">input:focus</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.C语言的一些概念</title>
    <url>/2021/06/27/1-C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol>
<li>整型常量：也就是整数</li>
<li>实型常量：<ol>
<li>十进制小数形式：由数字和小数点组成</li>
<li>指数形式：如$12.34e3$(代表$12.34\times10^3$)<br><br> 规定：字母E或e代表以10为底的指数<br><br> 注意：E或e前必须有数字，且e或E后必须为整数</li>
</ol>
</li>
<li>字符常量：<ol>
<li>普通字符：用单撇号括起来的一个字符</li>
<li>转义字符：以字符”\\”开头的字符</li>
</ol>
</li>
<li>字符串常量：用双撇号把若干字符括起来</li>
<li>符号常量：如#define PI 3.14 (注意末尾没有分号)</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">转义字符</th>
<th style="text-align:left">字符值</th>
<th style="text-align:left">输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\a</td>
<td style="text-align:left">警告(alert)</td>
<td style="text-align:left">产生声音或视觉信号</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">退格(backspace)</td>
<td style="text-align:left">将光标位置后退一个字符</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页(form feed)</td>
<td style="text-align:left">将光标当前位置移到下一页的开头</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行</td>
<td style="text-align:left">将光标当前位置移到下一行的开头</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车(carriage return)</td>
<td style="text-align:left">将该光标当前位置移到本行的开头</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">水平制表符</td>
<td style="text-align:left">将光标当前位置移到下一个Tab位置</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表符</td>
<td style="text-align:left">将光标当前位置移到下一个垂直制表对齐点</td>
</tr>
<tr>
<td style="text-align:left">\o,\oo或\ooo<br>其中o代表一个八进制数字</td>
<td style="text-align:left">与该八进制码对应的$ASCLL$字符</td>
<td style="text-align:left">与该八进制码对应的字符</td>
</tr>
<tr>
<td style="text-align:left">\xh[h$\cdots$]<br>其中h代表一个十六进制数字</td>
<td style="text-align:left">与该十六进制对应的$ASCLL$字符</td>
<td style="text-align:left">与该十六进制码对应的字符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>变量代表一个有名字，具有特定属性的一个存储单元。它用来存放数据，也就是存放变量的值。程序运行期间变量的值可以改变。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;<span class="comment">//a是变量名，3是变量值</span></span><br></pre></td></tr></table></figure></p>
<h2 id="常变量"><a href="#常变量" class="headerlink" title="常变量"></a>常变量</h2><p>$C99$允许使用 <strong>常变量</strong> ,方法是在定义变量时，前面加一个关键字const,<br>如 const int a=3;<br><br>常变量和常量的异同：<br><br>常变量具有变量的基本属性：有类型，占存储单元，只是不允许只改变<br><br>常变量是有名字的不变量，常量是没有名字的不变量<br></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列统称为标识符。</p>
</blockquote>
<p>就是一个对象的名字。变量名c,f……，符号常量名PI……，函数名printf……都是标识符</p>
<p><strong>C语言规定</strong> 标识符只能由字母，数字和下划线3种字符组成，且首字符必须是字母或下划线。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>所谓类型，就是对数据分配存储单元的安排，包括存储单元的长度（占多少字节）<br>以及数据的存储形式。不同的类型分配不同的长度和存储形式。</p>
<ul>
<li>$<br>\text{数据类型}<br>\begin{cases}<br>\text{基本类型}<br>\begin{cases}<br>\text{整型类型}<br>\begin{cases}<br>\text{基本整形(int)}\\<br>\text{短整型(short int)}\\<br>\text{长整型(long int)}\\<br>\text{双长整型(long long int)}\\<br>\text{字符型(char)}\\<br>\text{布尔型(bool)}<br>\end{cases}\\<br>\\<br>\text{浮点类型}<br>\begin{cases}<br>\text{单精度浮点型(float)}\\<br>\text{双精度浮点型(double)}\\<br>\text{复数浮点型(float_complex,double_complex,longlong_complex)}<br>\end{cases}<br>\end{cases}\\<br>\\<br>\text{枚举类型(enum)}\\<br>\\<br>\text{空类型(void)}\\<br>\\<br>\text{派生类型}<br>\begin{cases}<br>\text{指针类型(*)}\\<br>\text{数组类型([ ])}\\<br>\text{结构体类型(struct)}\\<br>\text{共用体类型(union)}\\<br>\text{函数类型}<br>\end{cases}<br>\end{cases}<br>$</li>
</ul>
</blockquote>
<p>其中基本类型和枚举类型的值都是数值，统称为算术类型。</p>
<p>算术类型和指针类型统称为纯量类型，因为其值是整数类型。</p>
<p>枚举类型是程序中用户定义的整数类型。</p>
<p>数组类型和结构体类型统称为组合类型，共用体类型不属于组合类型，<br>因为在同一时间只有一个成员具有值。</p>
<p>函数类型用来定义函数，描述一个函数的接口，包括函数返回值的数据类型和参数的类型</p>
<h2 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h2><p>存储单元的存储方式是：用整数补码形式存放。</p>
<p>一个整数的补码是此数的二进制形式</p>
<p>求负数补码的方法：先将此数的绝对值写成二进制的形式，然后对所有二进制位按位 <strong>取反，再加1</strong></p>
<h3 id="整型数据的分类"><a href="#整型数据的分类" class="headerlink" title="整型数据的分类"></a>整型数据的分类</h3><ol>
<li>基本类型(int 型)<br>编译系统分配给int型数据2个字节或4个字节(由具体的C语言编译系统自行决定)<br></li>
<li>短整型(short int)<br>类型名为short int或short。<br><br>一般分配2个字节，取值范围$-2^{15}\sim (2^{15}-1)$</li>
<li>长整型(long int)<br>类型名为long int或long。<br><br>一般分配4个字节，取值范围$-2^{31}\sim (2^{31}-1)$</li>
<li>双长整型(long long int)<br>类型名为long long int或long long。<br><br>一般分配8个字节，取值范围$-2^{63}\sim (2^{63}-1)$</li>
</ol>
<p>在类型符号前面加上无符号修饰符unsigned，就是只有正值的意思，<br>因为其所占字节数不变，也就是说正值的取值范围比以前大。</p>
<h2 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h2><p>定义字符变量<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;?&#x27;</span>; <span class="comment">//char c=63;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  %c&quot;</span>,c,c);</span><br><span class="line"><span class="comment">//输出结果63 ?</span></span><br></pre></td></tr></table></figure><br>c是字符变量，实质上是一个字节的整型变量，但是它用来存放字符，所以称为字符变量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">signed char(有符号字符型)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$-2^7\sim (2^7-1)$</td>
</tr>
<tr>
<td style="text-align:center">unsigned char(无符号字符型)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$0\sim 2^{8}-1$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="浮点型数据"><a href="#浮点型数据" class="headerlink" title="浮点型数据"></a>浮点型数据</h2><blockquote>
<p>用来表示具有小数点的实数。</p>
</blockquote>
<p>因为小数点位置可以浮动，所以实数的指数形式称为 <strong>浮点数</strong></p>
<p>浮点数类型有三种</p>
<ol>
<li>float型（单精度浮点型）<br>分配4个字节</li>
<li>double型（双精度浮点型）<br>分配8个字节</li>
<li>long double型（长双精度型）<br>8或16个字节<h2 id="确定常量的类型"><a href="#确定常量的类型" class="headerlink" title="确定常量的类型"></a>确定常量的类型</h2></li>
<li>整型常量<br>在一个整数末尾加大写L或小写l表示长整型<br></li>
<li>浮点型常量<blockquote>
<p>以小数或指数形式出现的实数</p>
</blockquote>
</li>
</ol>
<p>在末尾加上F或f表示float类型，<br>加上L或l表示long double类型<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a =<span class="number">3</span> <span class="number">.14159</span>f</span><br><span class="line"><span class="keyword">float</span> dounble a = <span class="number">1.23L</span></span><br></pre></td></tr></table></figure></p>
<p><strong>类型和变量的区别：</strong><br>每个变量都属于一个确定的类型，类型是变量的一个重要属性。</p>
<h1 id="C语句"><a href="#C语句" class="headerlink" title="C语句"></a>C语句</h1><h2 id="C语句的作用和分类"><a href="#C语句的作用和分类" class="headerlink" title="C语句的作用和分类"></a>C语句的作用和分类</h2><p>语句后面有分号</p>
<p>分类：</p>
<ol>
<li>控制语句</li>
<li>函数调用语句</li>
<li>表达式语句</li>
<li>空语句</li>
<li>复合语句</li>
</ol>
<h1 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h1><p>C语言本身不提供输入输出语句</p>
<p>需要使用库函数stdio.h</p>
<h2 id="printf-格式控制，输出表列"><a href="#printf-格式控制，输出表列" class="headerlink" title="printf(格式控制，输出表列)"></a>printf(格式控制，输出表列)</h2><p>%附加字符 格式字符</p>
<p>例%-m.nf</p>
<p>printf函数中用到的格式字符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">d,i</td>
<td style="text-align:left">输出带符号十进制整数</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:left">输出八进制无符号整数(不输出前导符0)</td>
</tr>
<tr>
<td style="text-align:center">x,X</td>
<td style="text-align:left">输出无符号十六进制整数(不输出前导符0x)，用x小写，X大写</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:left">输出无符号十进制整数</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:left">输出一个字符</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:left">输出字符串</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:left">以小数形式输出单、双精度数，隐含输出6位小数</td>
</tr>
<tr>
<td style="text-align:center">e,E</td>
<td style="text-align:left">以指数形式输出实数</td>
</tr>
<tr>
<td style="text-align:center">g,G</td>
<td style="text-align:left">选用%f或%e格式中输出宽度较短的一种形式，不输出无意义的0</td>
</tr>
</tbody>
</table>
</div>
<p>在格式声明中，在%和上述格式字符间可以插入几种附加字符(又称修饰符)</p>
<p>printf函数中用到的修饰符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:left">长整型整数，可加在格式符d、o、x、u前面</td>
</tr>
<tr>
<td style="text-align:center">m(代表一个整数)</td>
<td style="text-align:left">数据的最小宽度</td>
</tr>
<tr>
<td style="text-align:center">n(代表一个实数)</td>
<td style="text-align:left">对实数，表示输出n位小数；对字符串，表示截取的字符个数</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:left">输出的数字或字符在域内想左靠</td>
</tr>
</tbody>
</table>
</div>
<h2 id="scanf-格式控制-地址表列"><a href="#scanf-格式控制-地址表列" class="headerlink" title="scanf(格式控制,地址表列)"></a>scanf(格式控制,地址表列)</h2><p><strong>注意</strong>：scanf函数中是地址表列，传进去的是变量地址</p>
<h1 id="关系运算符和关系表达式"><a href="#关系运算符和关系表达式" class="headerlink" title="关系运算符和关系表达式"></a>关系运算符和关系表达式</h1><blockquote>
<p>C语言中，比较符称为关系运算符<br><br>用关系运算符将两个数值或数值表达式连接起来的式子，称为关系表达式。</p>
</blockquote>
<p>关系运算符：</p>
<p>&lt; ， &lt;= ， &gt; ， &gt;= ， == ， !=</p>
<p>关系表达式：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>&gt;=<span class="number">0</span> <span class="comment">//为真 1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="逻辑运算符和逻辑表达式"><a href="#逻辑运算符和逻辑表达式" class="headerlink" title="逻辑运算符和逻辑表达式"></a>逻辑运算符和逻辑表达式</h1><p>逻辑表达式：</p>
<p>&amp;&amp; 或 ，|| 与 ，! 非</p>
<p>逻辑运算符：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">8</span> &lt; <span class="number">4</span> - !<span class="number">0</span> <span class="comment">//为假 0</span></span><br></pre></td></tr></table></figure></p>
<h1 id="条件运算符和条件表达式"><a href="#条件运算符和条件表达式" class="headerlink" title="条件运算符和条件表达式"></a>条件运算符和条件表达式</h1><p>条件表达式的一般形式：</p>
<p>表达式1 ? 表达式2 : 表达式3<br>例<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max=(a&gt;b)?a:b;</span><br></pre></td></tr></table></figure></p>
<h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grade;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;grade);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your score:&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(grade) <span class="comment">//此括号里的值类型应为整数类型（包括字符型）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;85~100\n&quot;</span>);<span class="keyword">break</span>;<span class="comment">//break;不能省</span></span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;B</span><span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;70~84\n&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>C<span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;60~69\n&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;&lt;60\n&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;enter data error!\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果:</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">Your score:85~100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="静态，动态存储方式"><a href="#静态，动态存储方式" class="headerlink" title="静态，动态存储方式"></a>静态，动态存储方式</h1><p><strong>例</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">0</span>;<span class="comment">//定义了一个静态局部变量，调用后不释放，保留前值</span></span><br><span class="line">	b=b+<span class="number">1</span>;</span><br><span class="line">	c=c+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">2</span>,i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><strong>对比下面的程序</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">	b=b+<span class="number">1</span>;</span><br><span class="line">	c=c+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">2</span>,i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>1.numpy入门</title>
    <url>/2021/06/30/1-numpy%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为在matplotlib和pandas中都需要用到pandas，所以我想先将numpy文档中的基本代码都实现一遍，也算作是numpy的入门，后面先将matplotlib和pandas暂时放一放，对numpy进行深入学习，当然因为numpy是对数组进行处理，所以也会将其和线性代数结合在一块儿进行学习，基本掌握之后，在花几天时间进行巩固，然后将其运用到matplotlib和pandas的学习中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="array创建"><a href="#array创建" class="headerlink" title="array创建"></a>array创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 一维数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) <span class="comment"># 二维数组，2行3列</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [4, 5, 6]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]],dtype=<span class="built_in">complex</span>) <span class="comment">#创建时指定数组类型</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1.+0.j, 2.+0.j, 3.+0.j],
       [1.+0.j, 2.+0.j, 3.+0.j]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-0.21304205, -0.6656218 ,  0.33403836])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0., 0., 0.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.empty(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0., 0., 0.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1., 1., 1.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full(<span class="number">3</span>,<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.5, 0.5, 0.5])
</code></pre><h2 id="arange函数"><a href="#arange函数" class="headerlink" title="arange函数"></a>arange函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">6</span>) <span class="comment">#类似等差数列，缺点是浮点精度有限，不可能预测所获得元素的数量 </span></span><br></pre></td></tr></table></figure>
<pre><code>array([10, 16, 22, 28])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">6</span>)</span><br><span class="line">b=np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#2行3列</span></span><br><span class="line">c=np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
--------------
[[0 1 2]
 [3 4 5]]
--------------
[[0 1 2]
 [3 4 5]
 [6 7 8]]
</code></pre><h2 id="linspace函数"><a href="#linspace函数" class="headerlink" title="linspace函数"></a>linspace函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>)<span class="comment">#接受所要元素的数量而不是步长(arrang函数)</span></span><br></pre></td></tr></table></figure>
<pre><code>array([1.  , 1.25, 1.5 , 1.75, 2.  , 2.25, 2.5 , 2.75, 3.  ])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.indices((<span class="number">3</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[[0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]],

       [[0, 1, 2],
        [0, 1, 2],
        [0, 1, 2]]])
</code></pre><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">b = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = b-a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = a&lt;<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">e = np.sin(b)<span class="comment">#都是对应元素进行计算</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<pre><code>[ 1.    3.25  5.5   7.75 10.  ]
---------------
[0 1 2 3 4]
---------------
[-1.   -2.25 -3.5  -4.75 -6.  ]
---------------
[ True False False False False]
---------------
[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025 ]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array( [[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">               [<span class="number">0</span>,<span class="number">1</span>]] )</span><br><span class="line">B = np.array( [[<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">               [<span class="number">3</span>,<span class="number">4</span>]] )</span><br><span class="line">a=A * B    <span class="comment"># 对应元素相乘</span></span><br><span class="line">b=A @ B    <span class="comment"># 矩阵相乘                 </span></span><br><span class="line">c=A.dot(B)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dot&quot;</span>,c)</span><br></pre></td></tr></table></figure>
<pre><code>* [[2 0]
 [0 4]]
---------------
@ [[5 4]
 [3 4]]
---------------
dot [[5 4]
 [3 4]]
</code></pre><h2 id="求和，求最值···"><a href="#求和，求最值···" class="headerlink" title="求和，求最值···"></a>求和，求最值···</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))<span class="comment">#2行3列随机数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure>
<pre><code>[[0.70271427 0.13052157 0.78775386]
 [0.57059958 0.22503932 0.35158542]]
---------------
2.768214031975299
---------------
0.13052157065742465
---------------
0.7877538595802818
</code></pre><h2 id="axis参数"><a href="#axis参数" class="headerlink" title="axis参数"></a>axis参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum&quot;</span>,a.<span class="built_in">sum</span>(axis=<span class="number">1</span>))<span class="comment"># 打印出每一列的和</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min&quot;</span>,a.<span class="built_in">min</span>(axis=<span class="number">1</span>))<span class="comment"># 打印出每一行的最小值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cumsum&quot;</span>,a.cumsum(axis=<span class="number">1</span>))<span class="comment">#每一行累积求和</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
---------------
sum [ 6 22 38 54]
---------------
min [ 0  4  8 12]
---------------
cumsum [[ 0  1  3  6]
 [ 4  9 15 22]
 [ 8 17 27 38]
 [12 25 39 54]]
</code></pre><h2 id="索引，切片，迭代"><a href="#索引，切片，迭代" class="headerlink" title="索引，切片，迭代"></a>索引，切片，迭代</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>])<span class="comment">#索引,打印出第三个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:<span class="number">5</span>])<span class="comment">#切片,从第三个数到第五个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[::-<span class="number">1</span>])<span class="comment">#步长为-1，也就是逆序</span></span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
---------------
2
---------------
[2 3 4]
---------------
[9 8 7 6 5 4 3 2 1 0]
</code></pre><h3 id="多维"><a href="#多维" class="headerlink" title="多维"></a>多维</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">25</span>).reshape(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 索引,第3行第4列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>]) <span class="comment"># 第2行到第5行的第3个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[:,<span class="number">2</span>]) <span class="comment"># 每行第3个数 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">5</span>,:]) <span class="comment"># 第2行到第5行的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">1</span>]) <span class="comment"># 表示最后一行所有元素,eq：a[-1,:]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">2</span>]) <span class="comment"># 表示的是第3列的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
---------------
13
---------------
[ 7 12 17 22]
---------------
[ 2  7 12 17 22]
---------------
[[ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
---------------
[20 21 22 23 24]
---------------
[ 2  7 12 17 22]
[15 16 17 18 19]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">24</span>).reshape(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...]) <span class="comment"># 表示第2个里面的所有元素 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...,<span class="number">1</span>,:])<span class="comment"># 表示第2个里面第2行元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">2</span>])<span class="comment"># 表示每个里面第3列元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>])<span class="comment"># 表示第3个里面的第一个元素</span></span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3]
  [ 4  5  6  7]]

 [[ 8  9 10 11]
  [12 13 14 15]]

 [[16 17 18 19]
  [20 21 22 23]]]
---------------
[[ 8  9 10 11]
 [12 13 14 15]]
---------------
[12 13 14 15]
---------------
[[ 2  6]
 [10 14]
 [18 22]]
---------------
16
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a =np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a: <span class="comment"># 循环遍历打印每行元素</span></span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.flat: <span class="comment"># 循环打印每个元素</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
---------------
[0 1 2 3]
[4 5 6 7]
[ 8  9 10 11]
---------------
0
1
2
3
4
5
6
7
8
9
10
11
</code></pre><h1 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h1><p>一个数组的形状是由每个轴的元素数量决定的</p>
<h2 id="改变数组形状"><a href="#改变数组形状" class="headerlink" title="改变数组形状"></a>改变数组形状</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.reshape(<span class="number">3</span>,<span class="number">4</span>))<span class="comment"># 返回一个改变后的数组，但不改变a中元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T)<span class="comment"># a的转置，但不改变a中元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
------------------------
[[6. 6. 1. 4.]
 [4. 5. 7. 3.]
 [7. 0. 4. 7.]]
------------------------
[[6. 4. 7.]
 [6. 5. 0.]
 [1. 7. 4.]
 [4. 3. 7.]]
------------------------
(4, 3)
------------------------
(3, 4)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.resize((<span class="number">2</span>,<span class="number">6</span>)))<span class="comment">#resize函数可以改变a中的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
------------------------
None
------------------------
[[0 1 2 3 4 5]
 [6 7 8 9 0 0]]
</code></pre><h2 id="将不同数组堆叠在一起"><a href="#将不同数组堆叠在一起" class="headerlink" title="将不同数组堆叠在一起"></a>将不同数组堆叠在一起</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.linspace(<span class="number">2</span>,<span class="number">20</span>,<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a,b)))<span class="comment">#垂直拼在一块</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a,b)))<span class="comment">#水平拼在一块</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 2.  8.]
 [14. 20.]]
------------------------
[[8. 4.]
 [0. 7.]]
------------------------
[[ 2.  8.]
 [14. 20.]
 [ 8.  4.]
 [ 0.  7.]]
------------------------
[[ 2.  8.  8.  4.]
 [14. 20.  0.  7.]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.column_stack((a,b))<span class="comment">#此时效果感觉跟hstack差不多</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2.,  8.,  8.,  4.],
       [14., 20.,  0.,  7.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">b=np.array([<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.column_stack((a,b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a,b)))<span class="comment">#这样子的话hstack和column_stack的区别就体现出来了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.row_stack((a,b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a,b)))<span class="comment">#vtack和row_stack的没有区别</span></span><br></pre></td></tr></table></figure>
<pre><code>a [1 2]
------------------------
b [3 4]
------------------------
[[1 3]
 [2 4]]
------------------------
[1 2 3 4]
------------------------
[[1 2]
 [3 4]]
------------------------
[[1 2]
 [3 4]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a[:,np.newaxis]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">d = b[:,np.newaxis]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d&quot;</span>,d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((c,d)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.row_stack((c,d))) <span class="comment"># 结果还是一样，</span></span><br><span class="line"><span class="comment"># hstack和column_stack在一维数组的堆叠中是有区别的</span></span><br><span class="line"><span class="comment"># 但是没有发现vstack和row_stack数组堆叠的区别</span></span><br></pre></td></tr></table></figure>
<pre><code>c [[1]
 [2]]
------------------------
d [[3]
 [4]]
------------------------
[[1]
 [2]
 [3]
 [4]]
------------------------
[[1]
 [2]
 [3]
 [4]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a[:,np.newaxis]<span class="comment"># newaxis可以将行向量转化成列向量</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1],
       [2],
       [3],
       [4]])
</code></pre><p>r_和c_的堆叠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment"># 允许使用范围操作符 :堆叠方式感觉跟vstack类似</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">b = np.c_[<span class="number">1</span>:<span class="number">4</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]] <span class="comment"># 堆叠方式感觉跟hstack类似</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3 4 5]
------------------------
[[1 4]
 [2 5]
 [3 6]]
</code></pre><h2 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hsplit(a,<span class="number">3</span>))<span class="comment"># 沿数组水平轴拆分数组,返回的数组形状相同</span></span><br><span class="line"><span class="built_in">print</span>(np.hsplit(a,(<span class="number">1</span>,<span class="number">4</span>)))<span class="comment"># 表示第1列和第4列后面切一刀分成三个数组</span></span><br></pre></td></tr></table></figure>
<pre><code>a [[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]
------------------------
[array([[0, 1],
       [6, 7]]), array([[2, 3],
       [8, 9]]), array([[ 4,  5],
       [10, 11]])]
[array([[0],
       [6]]), array([[1, 2, 3],
       [7, 8, 9]]), array([[ 4,  5],
       [10, 11]])]
</code></pre><p>当然同理vsplit就是按垂直轴分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.vsplit(a,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[array([[0, 1, 2, 3, 4, 5]]), array([[ 6,  7,  8,  9, 10, 11]])]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.array_split(a,<span class="number">2</span>)) <span class="comment"># array_split将可以数组拆分成大小相等的多个子数组</span></span><br></pre></td></tr></table></figure>
<pre><code>[array([[0, 1, 2, 3, 4, 5]]), array([[ 6,  7,  8,  9, 10, 11]])]
</code></pre><h1 id="拷贝和视图"><a href="#拷贝和视图" class="headerlink" title="拷贝和视图"></a>拷贝和视图</h1><h2 id="完全不复制"><a href="#完全不复制" class="headerlink" title="完全不复制"></a>完全不复制</h2><blockquote>
<p>简单分配不会复制数组对象或其数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a) <span class="comment"># 由此可以看出a,b是名字不同的相同数组，</span></span><br><span class="line"><span class="comment"># 这也就是python引用传递的特性，跟C语言的赋值操作不大一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------&quot;</span>)</span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">4</span> <span class="comment"># 通过改变b，改变a的形状</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>True
-------------------
(3, 4)
</code></pre><h2 id="试图或浅拷贝"><a href="#试图或浅拷贝" class="headerlink" title="试图或浅拷贝"></a>试图或浅拷贝</h2><blockquote>
<p>不同的数组对象可以共享相同的数据</p>
</blockquote>
<p>用view方法可以创建一个查看相同数据的新数组对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a.view()</span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c.base <span class="keyword">is</span> a)<span class="comment"># 可以看出两者不一样，但是所存储的内容一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------&quot;</span>)</span><br><span class="line">c.shape=<span class="number">2</span>,<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)<span class="comment"># a 的形状也没发生变化</span></span><br><span class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># 神奇的事情发生了a中对应的数组元素也发生了改变</span></span><br></pre></td></tr></table></figure>
<pre><code>False
---------------------
True
---------------------
(3, 4)
[[   0    1    2    3]
 [1234    5    6    7]
 [   8    9   10   11]]
</code></pre><p><strong>原因：切片数组会返回一个视图</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = a[:,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">s[:]=<span class="number">10</span> <span class="comment"># 这里s[:]是s的一个视图</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># a的值发生了变化</span></span><br></pre></td></tr></table></figure>
<pre><code>[[   0   10   10    3]
 [1234   10   10    7]
 [   8   10   10   11]]
</code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>用copy方法可以生成数组及其数据的完整副本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = a.copy()</span><br><span class="line"><span class="built_in">print</span>(d <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d.base <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line">d[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#也就是说用了copy方法后d和a是两个值相等，但完全不同的数组</span></span><br></pre></td></tr></table></figure>
<pre><code>False
-------------
False
-------------
[[   0   10   10    3]
 [1234   10   10    7]
 [   8   10   10   11]]
</code></pre><p>有时，如果不再需要原始数组，则应在切片后调用 copy。例如，假设a是一个巨大的中间结果，最终结果b只包含a的一小部分，那么在用切片构造b时应该做一个深拷贝,这样就可以只保留部分的a，将a的所占内存释放掉</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>1.html语法规则</title>
    <url>/2021/07/09/1-html%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h1><p>这两天学习了一下html的基本语法规则，复习一段时间后就会开始CSS的学习，并将其先运用在博客的页面显示上，当然这也是为了以后网站搭建进行一些知识储备。</p>
<h2 id="基本语法概述"><a href="#基本语法概述" class="headerlink" title="基本语法概述"></a>基本语法概述</h2><ol>
<li>HTML标签是由尖括号包围的关键词，例如&lt;html&gt;</li>
<li>HTML标签通常是成对出现的，例如&lt;html&gt;和&lt;/html&gt;，我们称为双标签，第一个是开始标签，第二个是结束标签</li>
<li>有些特殊的标签必须是单个标签（极少情况），例如&lt;br/&gt;,我们称为单标签</li>
</ol>
<h2 id="标签关系"><a href="#标签关系" class="headerlink" title="标签关系"></a>标签关系</h2><p>双标签关系可分为两类：包含关系和并列关系</p>
<p><strong>包含关系</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>并列关系</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="HTML基本结构标签"><a href="#HTML基本结构标签" class="headerlink" title="HTML基本结构标签"></a>HTML基本结构标签</h1><h2 id="第一个HTML网页"><a href="#第一个HTML网页" class="headerlink" title="第一个HTML网页"></a>第一个HTML网页</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		hello,world</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">标签名</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;html&gt;&lt;/html&gt;</td>
<td style="text-align:left">HTML标签</td>
<td style="text-align:left">根标签</td>
</tr>
<tr>
<td style="text-align:left">&lt;head&gt;&lt;/head&gt;</td>
<td style="text-align:left">文档头部</td>
<td style="text-align:left">注意在head标签中我们必须要设置的标签是title</td>
</tr>
<tr>
<td style="text-align:left">&lt;title&gt;&lt;/title&gt;</td>
<td style="text-align:left">文档标题</td>
<td style="text-align:left">让页面拥有一个属于自己的网页标题</td>
</tr>
<tr>
<td style="text-align:left">&lt;body&gt;&lt;/body&gt;</td>
<td style="text-align:left">文档主体</td>
<td style="text-align:left">元素包含文档的所有内容，页面内容基本都是放到body里面的</td>
</tr>
</tbody>
</table>
</div>
<h1 id="网页开发工具"><a href="#网页开发工具" class="headerlink" title="网页开发工具"></a>网页开发工具</h1><h2 id="文档类型声明标签"><a href="#文档类型声明标签" class="headerlink" title="文档类型声明标签"></a>文档类型声明标签</h2><p>&lt;!DOCTYPE&gt;文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这句代码表示采用HTML5</p>
<h2 id="lang语言种类"><a href="#lang语言种类" class="headerlink" title="lang语言种类"></a>lang语言种类</h2><p>用来定义当前文档显示的语言：</p>
<ol>
<li>en定义语言为英文</li>
<li>zh-CN定义语言为中文<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><blockquote>
<p>在&lt;head&gt;标签内，可以通过&lt;meta&gt;标签的charset属性来规定HTML文档应该使用哪种字符编码。</p>
</blockquote>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>charset常用的值由：GB2312、BIG5、GBK和UTF-8，其中UTF-8也被称为万国码，基本包含了全世界所有国家需要用到的字符</p>
<p><strong>注意：</strong> 上面语法是必须要写的代码，否则可能引起乱码情况，一般情况下，统一使用”UTF-8”编码</p>
<h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><h2 id="标题标签-lt-h1-gt-lt-h6-gt"><a href="#标题标签-lt-h1-gt-lt-h6-gt" class="headerlink" title="标题标签&lt;h1&gt;-&lt;h6&gt;"></a>标题标签&lt;h1&gt;-&lt;h6&gt;</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>单词head的缩写</p>
<h2 id="段落标签和换行标签"><a href="#段落标签和换行标签" class="headerlink" title="段落标签和换行标签"></a>段落标签和换行标签</h2><p>在网页中，要把文字有条理地显示出来，需要将这些文字分段显示。在HTML标签中，&lt;p&gt;标签用于定义段落，它可以将整个网页分为若干段落。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br>单词paragraph的缩写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>单词break的缩写</p>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加粗</td>
<td style="text-align:left">&lt;strong&gt;&lt;/strong&gt;或者&lt;b&gt;&lt;/b&gt;</td>
<td style="text-align:left">推荐使用&lt;strong&gt;</td>
</tr>
<tr>
<td style="text-align:left">倾斜</td>
<td style="text-align:left">&lt;em&gt;&lt;/em&gt;或者&lt;i&gt;&lt;/i&gt;</td>
<td style="text-align:left">推荐使用&lt;em&gt;</td>
</tr>
<tr>
<td style="text-align:left">删除线</td>
<td style="text-align:left">&lt;del&gt;&lt;del&gt;或者&lt;s&gt;&lt;/s&gt;</td>
<td style="text-align:left">推荐使用&lt;del&gt;</td>
</tr>
<tr>
<td style="text-align:left">下划线</td>
<td style="text-align:left">&lt;ins&gt;&lt;/ins&gt;或者<u></u></td>
<td style="text-align:left">推荐使用&lt;ins&gt;</td>
</tr>
</tbody>
</table>
</div>
<h2 id="lt-div-gt-和-lt-span-gt-标签"><a href="#lt-div-gt-和-lt-span-gt-标签" class="headerlink" title="&lt;div&gt;和&lt;span&gt;标签"></a>&lt;div&gt;和&lt;span&gt;标签</h2><p>&lt;div&gt;和&lt;span&gt;是没有语义的，它们是一个盒子，用来装内容的。</p>
<p>div是division的缩写，表示分区（大盒子），span是跨度（小盒子）</p>
<h2 id="图像标签和路径"><a href="#图像标签和路径" class="headerlink" title="图像标签和路径"></a>图像标签和路径</h2><ol>
<li>图像标签<br>在HTML标签中，&lt;img&gt;标签用于定义HTML页面中的图像。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
src是&lt;img&gt;的必须属性，而且必须写在img后面</li>
</ol>
<p><strong>图片标签属性:</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">图片路径</td>
<td style="text-align:left">必须属性</td>
</tr>
<tr>
<td style="text-align:left">alt</td>
<td style="text-align:left">文本</td>
<td style="text-align:left">替换文本，图像不能显示的文字</td>
</tr>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">文本</td>
<td style="text-align:left">提示文本，鼠标放到图像上，显示文字</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">像素</td>
<td style="text-align:left">设置图像的宽度</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left">像素</td>
<td style="text-align:left">设置图像的高度</td>
</tr>
<tr>
<td style="text-align:left">border</td>
<td style="text-align:left">像素</td>
<td style="text-align:left">设置图像边框的粗细</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>路径<br>目录文件夹和根目录：</li>
</ol>
<p><strong>目录文件夹</strong>：就是普通文件夹<br><strong>根目录</strong>：打开目录文件夹的第一层就是根目录</p>
<p>路径可以分为：</p>
<p>1.相对路径<br>以引用文件所在的位置为参考基础，建立出的目录路径</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">相对路径分类</th>
<th style="text-align:left">符号</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">同一级路径</td>
<td style="text-align:left"></td>
<td style="text-align:left">图像位于HTML文件同一级，如’baidu.gif’</td>
</tr>
<tr>
<td style="text-align:left">下一级路径</td>
<td style="text-align:left">/</td>
<td style="text-align:left">图像文件位于HTML文件下一级，如’images/baidu.gif’</td>
</tr>
<tr>
<td style="text-align:left">上一级路径</td>
<td style="text-align:left">../</td>
<td style="text-align:left">图像文件位于HTML文件上一级，如’../baidu.gif’</td>
</tr>
</tbody>
</table>
</div>
<p>2.绝对路径<br>是指目录下的绝对位置，直接到达目录位置，通常从盘符开始的路径。</p>
<p>例”D:\web\img\logo.gif”或完整的网络地址”xxx/images/log.gif”</p>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><blockquote>
<p>在HTML 标签中，&lt;a&gt;标签用于定义超链接，作用是从一个页面链接到另一个页面。</p>
</blockquote>
<p>1.语法格式<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">bref</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br>单词anchor的缩写，意为：锚<br><br>两个属性作用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">href</td>
<td style="text-align:left">用于指定来链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left">用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口中打开方式。</td>
</tr>
</tbody>
</table>
</div>
<p>2.链接分类<br>(1) 外部链接：例如<br><code>&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></p>
<p>(2) 内部链接：网站内部页面之间的相互链接，直接链接内部页面名称即可，例如<br><code>&lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;</code></p>
<p>(3)空连接：如果当时没有确定链接目标时<br><code>&lt;a href=&#39;#&#39;&gt;首页&lt;/a&gt;</code></p>
<p>(4)下载链接：如果href里面地址是一个文件或者压缩包，会下载这个文件</p>
<p>(5)网页元素链接：在网页中的各种网页元素，如文本、图像、表格、视频、音频等都可以添加超链接。</p>
<p>(6)锚点链接：点击链接，可以快速定位到页面中的某个位置</p>
<ul>
<li>在链接文本的href属性中，设置属性值为#名字的形式，如<br><code>&lt;a href=&#39;#two&#39;&gt;第二集&lt;/a&gt;</code></li>
<li>找到目标位置的标签，里面添加一个id属性 = 刚才的名字，如<br><code>&lt;h3 id=&quot;two&quot;&gt;第二集介绍&lt;/h3&gt;</code></li>
</ul>
<h1 id="HTML中的注释和特殊字符"><a href="#HTML中的注释和特殊字符" class="headerlink" title="HTML中的注释和特殊字符"></a>HTML中的注释和特殊字符</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>HTML中的注释</p>
<p>&lt;!— 注释 —&gt;</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>在HTML页面中，一些特殊的符号很难或不方便使用的代替方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特殊字符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">字符的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">空格符</td>
<td style="text-align:left">&amp;nbsp;</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">大于号</td>
<td style="text-align:left">&amp;lt;</td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">和号</td>
<td style="text-align:left">&amp;amp;</td>
</tr>
<tr>
<td style="text-align:left">&yen;</td>
<td style="text-align:left">人民币</td>
<td style="text-align:left">&amp;yen;</td>
</tr>
<tr>
<td style="text-align:left">&copy;</td>
<td style="text-align:left">版权</td>
<td style="text-align:left">&amp;copy;</td>
</tr>
<tr>
<td style="text-align:left">&reg;</td>
<td style="text-align:left">注册商标</td>
<td style="text-align:left">&amp;reg;</td>
</tr>
<tr>
<td style="text-align:left">&deg;</td>
<td style="text-align:left">摄氏度</td>
<td style="text-align:left">&amp;deg;</td>
</tr>
<tr>
<td style="text-align:left">&plusmn;</td>
<td style="text-align:left">正负号</td>
<td style="text-align:left">&amp;plusmn;</td>
</tr>
<tr>
<td style="text-align:left">&times;</td>
<td style="text-align:left">乘号</td>
<td style="text-align:left">&amp;times;</td>
</tr>
<tr>
<td style="text-align:left">&divide;</td>
<td style="text-align:left">除号</td>
<td style="text-align:left">&amp;divide;</td>
</tr>
<tr>
<td style="text-align:left">&sup2;</td>
<td style="text-align:left">上标2</td>
<td style="text-align:left">&amp;sup2;</td>
</tr>
<tr>
<td style="text-align:left">&sup3;</td>
<td style="text-align:left">上标3</td>
<td style="text-align:left">&amp;sup3;</td>
</tr>
</tbody>
</table>
</div>
<h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><h2 id="表格的基本语法"><a href="#表格的基本语法" class="headerlink" title="表格的基本语法"></a>表格的基本语法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>&lt;table&gt;&lt;/table&gt;是用于定义表格的标签</li>
<li>&lt;tr&gt;&lt;/tr&gt;标签用于定义表格中的行，必须嵌套在&lt;table&gt;&lt;/table&gt;标签中</li>
<li>&lt;td&gt;&lt;/td&gt;用于定义表格中的单元格，必须嵌套在&lt;td&gt;&lt;td&gt;标签中</li>
<li>字母td指表格数据(table data)，即数据单元格的内容</li>
</ol>
<h2 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h2><blockquote>
<p>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示</p>
</blockquote>
<p>&lt;th&gt;标签显示HTML表格的表头部分(table head的缩写)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">align</td>
<td style="text-align:left">left、center、right</td>
<td style="text-align:left">表格相对周围元素的对齐方式</td>
</tr>
<tr>
<td style="text-align:left">border</td>
<td style="text-align:left">1或””</td>
<td style="text-align:left">表格边框，默认为””,表示没有边框</td>
</tr>
<tr>
<td style="text-align:left">cellpadding</td>
<td style="text-align:left">像素值</td>
<td style="text-align:left">单元格与内容之间的距离，默认1像素</td>
</tr>
<tr>
<td style="text-align:left">cellspacing</td>
<td style="text-align:left">像素值</td>
<td style="text-align:left">单元格和单元格之间的距离，默认2像素</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">像素值或百分比</td>
<td style="text-align:left">表格的宽度</td>
</tr>
</tbody>
</table>
</div>
<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><p>分为无序列表，有序列表和自定义列表</p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>&lt;ul&gt;标签表示HTML页面中项目的无序列表，列表项使用&lt;li&gt;标签定义。</p>
<p>基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> &lt;ul&gt;里面只能放&lt;li&gt;,&lt;li&gt;里面可以放任何的标签</p>
<p>无序列表会带有自己的样式属性，在实际使用时，会用CSS来设置。</p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>&lt;ol&gt;标签用于定义有序列表，列表排序艺术字来显示，并且使用&lt;li&gt;标签来定义列表项</p>
<p>基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> &lt;ol&gt;里面只能放&lt;li&gt;,&lt;li&gt;里面可以放任何的标签</p>
<p>有序列表会带有自己的样式属性，在实际使用时，会用CSS来设置。</p>
<h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><p>列表前没有任何的项目符号</p>
<p>&lt;dl&gt;标签用于自定义列表，该标签会与&lt;dt&gt;（定义项目/名字）和&lt;dd&gt;（描述每一个项目/名字）一起使用。</p>
<p>基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>&lt;dl&gt;&lt;/dl&gt;里面只能包含&lt;dt&gt;和&lt;dd&gt;,&lt;dt&gt;和&lt;dd&gt;个数没有限制，但经常是一个&lt;dt&gt;对应多个&lt;dd&gt;</p>
<h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><p>通过表单收集用户信息</p>
<p>一个完整的表单通常是由表单域、表单元素和提示信息3个部分组成。</p>
<h2 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h2><p>一个包含表单元素的区域</p>
<p>&lt;form&gt;标签用于定义表单域</p>
<p>&lt;form&gt; 会把它范围内的表单元素信息提交给服务器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">	各种表单元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常用属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">action</td>
<td style="text-align:left">url地址</td>
<td style="text-align:left">用于指定接收并处理表单数据的服务器程序的url地址</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:left">get/post</td>
<td style="text-align:left">用于设置表单数据的提交方式</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">名称</td>
<td style="text-align:left">用于指定表单的名称，以区分同一页面中的的多个表单域</td>
</tr>
</tbody>
</table>
</div>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><h3 id="lt-input-gt-输入表单元素"><a href="#lt-input-gt-输入表单元素" class="headerlink" title="&lt;input&gt;输入表单元素"></a>&lt;input&gt;输入表单元素</h3><p>在&lt;input&gt;标签中，包含一个type属性，根据不同的type属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;input&gt;标签为单标签</li>
<li>type属性设置不同的属性值用来指定不同的控件类型</li>
</ul>
<p>type属性值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">button</td>
<td style="text-align:left">可点击按钮（多数情况下，用于通过javaScript启动脚本）</td>
</tr>
<tr>
<td style="text-align:left">checkbox</td>
<td style="text-align:left">复选框</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">输入字段和”浏览”按钮，供文件上传</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">隐藏输入字段</td>
</tr>
<tr>
<td style="text-align:left">image</td>
<td style="text-align:left">图像形式的提交按钮</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">密码字段，该字段中的字符被掩码</td>
</tr>
<tr>
<td style="text-align:left">radio</td>
<td style="text-align:left">单选按钮</td>
</tr>
<tr>
<td style="text-align:left">reset</td>
<td style="text-align:left">重置按钮，清除表单中的所有数据</td>
</tr>
<tr>
<td style="text-align:left">submit</td>
<td style="text-align:left">提交按钮，把表单数据发送到服务器</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">单行的输入字段，用户可在其中输入文本，默认宽度为20个字符</td>
</tr>
</tbody>
</table>
</div>
<p>除type属性，还有其他常用属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">由用户自定义</td>
<td style="text-align:left">input元素的名称</td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">由用户自定义</td>
<td style="text-align:left">规定input元素的值</td>
</tr>
<tr>
<td style="text-align:left">checked</td>
<td style="text-align:left">checked</td>
<td style="text-align:left">规定此Input元素首次加载对应当被选中</td>
</tr>
<tr>
<td style="text-align:left">maxlength</td>
<td style="text-align:left">正整数</td>
<td style="text-align:left">规定输入字段中的字符最大的长度</td>
</tr>
</tbody>
</table>
</div>
<h2 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt;标签"></a>&lt;label&gt;标签</h2><p>&lt;label&gt;标签为iput元素定义标注（标签）</p>
<p>&lt;label&gt;标签用于绑定一个表单元素，当点击&lt;lable&gt;标签内的文本时，浏览器会自动将光标转到或者选择对应的表单元素上，用来增加用户体验。</p>
<p>语法:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br><strong>核心:</strong>&lt;label&gt;标签的 <strong>for属性</strong> 应当与相关元素的 <strong>id属性</strong> 相同</p>
<h2 id="lt-select-gt-表单元素"><a href="#lt-select-gt-表单元素" class="headerlink" title="&lt;select&gt;表单元素"></a>&lt;select&gt;表单元素</h2><p>使用&lt;select&gt;标签控件定义下拉列表</p>
<p>语法：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">	地址：</span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在&lt;option&gt;中定义selected=”selected”时，当前项即为默认选中项。</p>
<h2 id="lt-textarea-gt-表单元素"><a href="#lt-textarea-gt-表单元素" class="headerlink" title="&lt;textarea&gt;表单元素"></a>&lt;textarea&gt;表单元素</h2><p>文本域</p>
<p>语法：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">row</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">	文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在实际开发中不会使用cols和rows,都是用CSS来改变大小</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.matplotlib入门</title>
    <url>/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h2 id="常见API介绍"><a href="#常见API介绍" class="headerlink" title="常见API介绍"></a>常见API介绍</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>plt.title()</strong><br>(图的标题)</td>
<td style="text-align:center">plt.title(“Matplotlib demo”)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.xlabel()</strong><br>(X轴描述)</td>
<td style="text-align:center">plt.xlabel(“x axis caption”)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.ylabel()</strong><br>(Y轴描述)</td>
<td style="text-align:center">plt.ylabel(“y axis caption”)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.plot()</strong><br> (画图)</td>
<td style="text-align:center">plt.plot(x,y)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.show()</strong><br> (显示)</td>
<td style="text-align:center">plt.show()</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.subplot()</strong><br>(子图绘制)</td>
<td style="text-align:center">plt.subplot(2, 1, 1) 21<br>(第一个图)<br>plt.subplot(2, 1, 2) 21<br>(第二个图)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.bar(x, y, align = ‘center’)</strong><br>(条状图)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.figure()</strong><br>存放实例代码生成的图片</td>
<td style="text-align:center">figure(figsize=(8,6),dpi=80)<br>创建一个 8 * 6 点（point）的图，并设置分辨率为 80</td>
</tr>
<tr>
<td style="text-align:center"><strong>xlim()</strong><br>(x轴的上下限)</td>
<td style="text-align:center">xlim(-4.0,4.0)</td>
</tr>
<tr>
<td style="text-align:center"><strong>ylim()</strong><br>(y轴的上下限)</td>
<td style="text-align:center">ylim(-1.0,1.0)</td>
</tr>
<tr>
<td style="text-align:center"><strong>legend()</strong><br>(图例位置)</td>
<td style="text-align:center">legend(loc=‘upper left’)</td>
</tr>
<tr>
<td style="text-align:center"><strong>scatter()</strong><br>(散点图)</td>
<td style="text-align:center">scatter(X,Y)</td>
</tr>
<tr>
<td style="text-align:center"><strong>contourf()</strong><br>(等高线)</td>
<td style="text-align:center">contourf(X, Y, f(X,Y), 8, alpha=.75, cmap=‘jet’)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="rcRarams的属性"><a href="#rcRarams的属性" class="headerlink" title="rcRarams的属性"></a>rcRarams的属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span>   <span class="comment">#这两行需要手动设置</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">‘font.family’</td>
<td style="text-align:left">用于显示字体的名字</td>
</tr>
<tr>
<td style="text-align:left">‘font.style’</td>
<td style="text-align:left">字体风格，正常’normal或斜体’italic’</td>
</tr>
<tr>
<td style="text-align:left">‘font.size’</td>
<td style="text-align:left">字体大小，整数字号或者’large’,’x-small’  </td>
</tr>
</tbody>
</table>
</div>
<p><strong>中文字体的样式</strong><br>(这些必须在matplotlib的font里进行添加，matplotlib里并没有这些,而且matplotlib很多font都不支持中文，虽然有一些支持中文显示，但是个人认为效果不是很好，中文配置也比较麻烦，后续会进行这方面的整理……)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">中文字体</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">‘SimHei’</td>
<td style="text-align:left"><font face="黑体">中文黑体</font></td>
</tr>
<tr>
<td style="text-align:left">‘Kaiti’</td>
<td style="text-align:left"><font face="楷体">中文楷体</font></td>
</tr>
<tr>
<td style="text-align:left">‘LiSu’</td>
<td style="text-align:left"><font face="隶书">中文隶书</font></td>
</tr>
<tr>
<td style="text-align:left">‘FangSong’</td>
<td style="text-align:left"><font face="仿宋">中文仿宋</font></td>
</tr>
<tr>
<td style="text-align:left">‘YouYuan’</td>
<td style="text-align:left"><font face="幼圆">中文幼圆</font></td>
</tr>
<tr>
<td style="text-align:left">‘STSong’</td>
<td style="text-align:left"><font face="华文宋体">华文宋体</font></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">颜色字符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">颜色字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘b’</td>
<td style="text-align:center">蓝色</td>
<td style="text-align:center">‘m’</td>
<td style="text-align:center">洋红色(magenta)</td>
</tr>
<tr>
<td style="text-align:center">‘g’</td>
<td style="text-align:center">绿色</td>
<td style="text-align:center">‘y’</td>
<td style="text-align:center">黄色</td>
</tr>
<tr>
<td style="text-align:center">‘r’</td>
<td style="text-align:center">红色</td>
<td style="text-align:center">‘k’</td>
<td style="text-align:center">黑色</td>
</tr>
<tr>
<td style="text-align:center">‘c’</td>
<td style="text-align:center">青绿色(cyan)</td>
<td style="text-align:center">‘w’</td>
<td style="text-align:center">白色</td>
</tr>
<tr>
<td style="text-align:center">‘#008000’</td>
<td style="text-align:center">RNG某颜色</td>
<td style="text-align:center">‘0.8’</td>
<td style="text-align:center">灰度值字符串</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">风格字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘-‘</td>
<td style="text-align:center">实线</td>
</tr>
<tr>
<td style="text-align:center">‘—‘</td>
<td style="text-align:center">破折线</td>
</tr>
<tr>
<td style="text-align:center">‘-.’</td>
<td style="text-align:center">点划线</td>
</tr>
<tr>
<td style="text-align:center">‘:’</td>
<td style="text-align:center">虚线</td>
</tr>
<tr>
<td style="text-align:center">‘’’’</td>
<td style="text-align:center">无线条</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘.’</td>
<td style="text-align:center">点标记</td>
</tr>
<tr>
<td style="text-align:center">‘,’</td>
<td style="text-align:center">像素标记</td>
</tr>
<tr>
<td style="text-align:center">‘o’</td>
<td style="text-align:center">实心圈标记</td>
</tr>
<tr>
<td style="text-align:center">‘v’</td>
<td style="text-align:center">倒三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘^’</td>
<td style="text-align:center">上三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘&gt;’</td>
<td style="text-align:center">右三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘&lt;’</td>
<td style="text-align:center">左三角标记</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘1’</td>
<td style="text-align:center">下花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘2’</td>
<td style="text-align:center">上花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘3’</td>
<td style="text-align:center">左花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘4’</td>
<td style="text-align:center">右花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘s’</td>
<td style="text-align:center">实心方形标记</td>
</tr>
<tr>
<td style="text-align:center">‘p’</td>
<td style="text-align:center">实心五角标记</td>
</tr>
<tr>
<td style="text-align:center">‘*’</td>
<td style="text-align:center">星形标记</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘h’</td>
<td style="text-align:center">竖六边形标记</td>
</tr>
<tr>
<td style="text-align:center">‘H’</td>
<td style="text-align:center">横六边形标记</td>
</tr>
<tr>
<td style="text-align:center">‘+’</td>
<td style="text-align:center">十字标记</td>
</tr>
<tr>
<td style="text-align:center">‘x’</td>
<td style="text-align:center">x标记</td>
</tr>
<tr>
<td style="text-align:center">‘D’</td>
<td style="text-align:center">菱形标记</td>
</tr>
<tr>
<td style="text-align:center">‘d’</td>
<td style="text-align:center">瘦菱形标记</td>
</tr>
<tr>
<td style="text-align:center">‘\\’</td>
<td style="text-align:center">垂直线标记</td>
</tr>
</tbody>
</table>
</div>
<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h2><p><strong>plot(x,y,formatstring)</strong></p>
<hr>
<ul>
<li><strong>x</strong>: x轴数据，列表或数组，可选参数，当我们在这个函数里，只展示一组数据时，x可省略。</li>
<li><strong>y</strong>： y轴数据，必须有。</li>
<li><strong>format_string</strong>：主要来控制我们画的曲线的格式：颜色，风格,标记，<br>可取三者的组合如：“g-o”,”r-.D”,如果不用组合，则用color,marker,linestyle,三个参数分别指定。</li>
<li><strong>label</strong>： 添加图例的类标。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span>   <span class="comment">#这两行需要手动设置</span></span><br><span class="line">x= np.linspace(-<span class="number">3</span>,<span class="number">3</span>,<span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line">plt.figure() <span class="comment"># 创建显示的窗口</span></span><br><span class="line">plt.plot(x,y1)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(x,y1,<span class="string">&#x27;r-.d&#x27;</span>,linewidth=<span class="number">1.0</span>,) <span class="comment"># r-.d三个参数分别代表color,linestyle,marker</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">plt.ylim((-<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x轴&#x27;</span>,fontdict=&#123;<span class="string">&quot;size&quot;</span>:<span class="number">20</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&quot;weight&quot;</span>:<span class="string">&quot;black&quot;</span>&#125;) <span class="comment"># 设置样式第一种fontdict</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y轴&#x27;</span>,fontsize=<span class="number">20</span>,color=<span class="string">&quot;r&quot;</span>,fontweight=<span class="string">&quot;light&quot;</span>) <span class="comment"># 第二种直接传入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(num=<span class="number">3</span>,figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">new_ticks = np.linspace(-<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(new_ticks)</span><br><span class="line">plt.xticks(new_ticks)</span><br><span class="line">plt.yticks([-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="string">r&#x27;$\alpha$&#x27;</span>,<span class="string">r&#x27;$\beta$&#x27;</span>,<span class="string">r&#x27;$\gamma$&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="comment"># gca = &#x27;get current axis&#x27;</span></span><br><span class="line">plt.tick_params(direction=<span class="string">&#x27;in&#x27;</span>,color=<span class="string">&quot;r&quot;</span>,width=<span class="number">2</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>) <span class="comment"># spines指的是边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment">#ax.xaxis.set_ticks_position(&#x27;bottom&#x27;) # 设置坐标上的数字显示的位置，default，可以不用</span></span><br><span class="line"><span class="comment">#ax.yaxis.set_ticks_position(&#x27;left&#x27;) # default</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>)) <span class="comment"># 将下面的坐标轴移动到0</span></span><br><span class="line">                                             <span class="comment"># &#x27;data&#x27;,&#x27;axes&#x27;,&#x27;outward&#x27;</span></span><br><span class="line">                                             <span class="comment"># &#x27;axes&#x27;:</span></span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>)) <span class="comment"># 将左面的坐标轴移动到0</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>[-1.   -0.25  0.5   1.25  2.  ]
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_1.png" alt="png"></p>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_2.png" alt="png"></p>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_3.png" alt="png"></p>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_4.png" alt="png"></p>
<h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">l1, = plt.plot(x,y1,color=<span class="string">&#x27;red&#x27;</span>,linewidth=<span class="number">1.0</span>,linestyle=<span class="string">&#x27;--&#x27;</span>,label=<span class="string">&#x27;Down&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意如果想传入handles，名称后面必须加一个逗号</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">plt.ylim((-<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">l2, = plt.plot(x,y2,label=<span class="string">&#x27;up&#x27;</span>) <span class="comment"># label，这个图像名称</span></span><br><span class="line">plt.legend(handles=[l1,l2,],labels=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],loc=<span class="string">&#x27;best&#x27;</span>) <span class="comment"># legend图例,handle传递两个对象[ , , ,]</span></span><br><span class="line">                                        <span class="comment"># loc指的是位置</span></span><br><span class="line">                                        <span class="comment"># rebel中表示图例中各个线的名称</span></span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_19_0.png" alt="png"></p>
<h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><p><strong><font size="5">annotate()</font></strong></p>
<hr>
<ul>
<li><p><strong>s</strong>: 添加标注的内容，字符串形式。</p>
</li>
<li><p><strong>xy</strong>: 箭头指向的位置，就是我们想添加标注的对象，元组类型输入方式。</p>
</li>
<li><p><strong>xytext</strong>：添加标注的实际位置，标注实际所在位置，可看做箭头输出端。</p>
</li>
<li><p><strong>arrowprops</strong>: 此参数中提供箭头属性字典来绘制从文本到注释点的箭头。</p>
</li>
<li><p><strong>width</strong> : 箭把宽度，整数或浮点数。</p>
</li>
<li><p><strong>frac</strong>：箭头头部所占的比例，小于1。</p>
</li>
<li><p><strong>headwidth</strong>：箭头头部宽度，整数或浮点数。</p>
</li>
<li><p><strong>headlength</strong>: 箭头长度，整数或浮点数。</p>
</li>
<li><p><strong>facecolor</strong>: 填充色。</p>
</li>
<li><p><strong>shrink</strong>：移动提示，并使其离注释点和文本一些距离。 <kbd>就是别让箭头两端里标注点和文本太近。</kbd></p>
</li>
<li><strong>fontsize</strong>：设置字体大小</li>
</ul>
<p><font size="5"><strong>ax.text()</strong></font></p>
<hr>
<ul>
<li><strong>x,y</strong>： 放置text的位置，横纵坐标<br>   </li>
<li><strong>s</strong>： str，text内容。<br>  </li>
<li><strong>fontsize</strong>： 设置字体大小，默认12，可选参数 [‘xx-small’, ‘x-small’, ‘small’, ‘medium’, ‘large’,‘x-large’, ‘xx-large’]<br>  </li>
<li><strong>fontweight</strong>：设置字体粗细，可选参数 [‘light’, ‘normal’, ‘medium’, ‘semibold’, ‘bold’, ‘heavy’, ‘black’] <br> </li>
<li><strong>alpha</strong>： 透明度，参数值0至1之间。<br>  </li>
<li><strong>rotation</strong>： (旋转角度)可选参数为:vertical,horizontal 也可以为数字。<br>  </li>
<li><strong>backgroundcolor</strong>：背景颜色。<br>  </li>
<li><strong>color</strong>： 字体颜色</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">ax=plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">2</span>*x0+<span class="number">1</span></span><br><span class="line">plt.scatter(x0,y0,s=<span class="number">50</span>,color=<span class="string">&#x27;red&#x27;</span>) <span class="comment"># s表示点的大小,color表示点的颜色</span></span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot([x0,x0],[y0,<span class="number">0</span>],<span class="string">&#x27;k--&#x27;</span>,lw=<span class="number">2.5</span>)<span class="comment"># k表示虚线的颜色为黑色，lw表示线的宽度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 1</span></span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">r&#x27;$2x+1=%s$&#x27;</span>% y0,xy=(x0,y0),xycoords=<span class="string">&#x27;data&#x27;</span>,xytext=(+<span class="number">30</span>,-<span class="number">30</span>),textcoords=<span class="string">&#x27;offset points&#x27;</span>,</span><br><span class="line">             fontsize=<span class="number">16</span>,arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;-&gt;&#x27;</span>,connectionstyle=<span class="string">&#x27;arc3,rad=.2&#x27;</span>))</span><br><span class="line">                             <span class="comment">#xy表示箭头所在的点，xycoords表示标注点的坐标系</span></span><br><span class="line">                             <span class="comment">#xytext()标记的左下角点的位置</span></span><br><span class="line">                             <span class="comment">#(+30,-30)表示xytext的位置基于箭头指向点横坐标加30，纵坐标减30</span></span><br><span class="line">                             <span class="comment">#offset points坐标系(这里是相对坐标系)</span></span><br><span class="line">                             <span class="comment">#arrowstyle描述标注只想标注点的方式</span></span><br><span class="line">                             <span class="comment">#fontsize字体大小</span></span><br><span class="line">                             <span class="comment">#connectionstyle</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line">plt.text(-<span class="number">3.7</span>,<span class="number">3</span>,<span class="string">r&#x27;$This\ is\ the\ some\ text.\ \mu\ \sigma_i\ \alpha_t$&#x27;</span>,fontdict=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">12</span>,<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;r&#x27;</span>&#125;)</span><br><span class="line">                                                                        <span class="comment">#fontdict&#123;&#125;表示字体,传入字典size,color……</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_23_0.png" alt="png"></p>
<h1 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h1><h2 id="tick-params"><a href="#tick-params" class="headerlink" title="tick_params()"></a>tick_params()</h2><ul>
<li><strong>axis</strong>: 可选”x”,”y”,”both”,defalut:”both”，分别代表，对x轴操作，对y轴操作，对两个轴都操作。</li>
<li><strong>direction</strong>: 可选 “in”,”out”,”inout”代表，刻度线显示在坐标轴里面，坐标轴外边，双边</li>
<li><strong>length</strong>: 刻度线长度</li>
<li><strong>color</strong>: 刻度线颜色</li>
<li><strong>width</strong>: 刻度线宽度</li>
<li><strong>pad</strong>：:刻度线与刻度标签之间的间隔</li>
<li><strong>bottom, top, left, right</strong>四个参数对应四个边框，取值为布尔类型，True 表示显示对应边框上的刻度线，False不显示，default:True</li>
<li><strong>labelbottom, labeltop, labelleft, labelright</strong>  与上面四个对应，代表的是四个边框上的类标的设置，取值为布尔类型，True代表显示对应边框上的类标，False不显示。</li>
<li><strong>labelsize</strong>：类标大小的设置参数，可取浮点型数值，也可去”medium”,”large”,”small”</li>
<li><strong>labelrotation</strong>：旋转类标一定的角度，与在set_xticklabels()中的参数rotation作用相同。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = <span class="number">0.1</span>*x</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y,label=<span class="string">&#x27;up&#x27;</span>,color=<span class="string">&#x27;grey&#x27;</span>,lw=<span class="number">10</span>,alpha=<span class="number">0.6</span>) <span class="comment"># lw=linewidth</span></span><br><span class="line">plt.ylim(-<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xticklabels()+ax.get_yticklabels():</span><br><span class="line">    label.set_fontsize(<span class="number">12</span>)</span><br><span class="line">    label.set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;white&#x27;</span>,edgecolor=<span class="string">&#x27;None&#x27;</span>,alpha=<span class="number">0.7</span>))</span><br><span class="line">                                                        <span class="comment"># alpha表示透明度</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_27_0.png" alt="png"></p>
<h1 id="scatter散点图"><a href="#scatter散点图" class="headerlink" title="scatter散点图"></a>scatter散点图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">1024</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,n)</span><br><span class="line">Y = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,n)</span><br><span class="line">T = np.arctan2(Y,X) <span class="comment"># for color value</span></span><br><span class="line"><span class="comment"># plt.scatter(X,Y,s=75,c=T,alpha=0.5) #s=size,c=color,</span></span><br><span class="line">plt.scatter(np.arange(<span class="number">5</span>),np.arange(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># plt.xlim((-1.5,1.5))</span></span><br><span class="line"><span class="comment"># plt.ylim((-1.5,1.5))</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.collections.PathCollection at 0x1e5aa843580&gt;
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_29_1.png" alt="png"></p>
<h1 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n =  <span class="number">12</span></span><br><span class="line">X = np.arange(n)</span><br><span class="line">Y1 = (<span class="number">1</span>-X/<span class="built_in">float</span>(n))*np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)</span><br><span class="line">Y2 = (<span class="number">1</span>-X/<span class="built_in">float</span>(n))*np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)</span><br><span class="line">plt.bar(X,+Y1,facecolor=<span class="string">&#x27;#9999ff&#x27;</span>,edgecolor=<span class="string">&#x27;white&#x27;</span>,align=<span class="string">&#x27;edge&#x27;</span>,width=-<span class="number">1</span>)</span><br><span class="line">plt.bar(X,-Y2,facecolor=<span class="string">&#x27;#ff9999&#x27;</span>,edgecolor=<span class="string">&#x27;white&#x27;</span>,align=<span class="string">&#x27;edge&#x27;</span>,width=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y1):</span><br><span class="line">    plt.text(x,y+<span class="number">0.05</span>,<span class="string">&#x27;%.2f&#x27;</span> % y,ha=<span class="string">&#x27;right&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,fontsize=<span class="number">8</span>) <span class="comment"># ha对齐方式</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,-Y2):</span><br><span class="line">    plt.text(x,y-<span class="number">0.05</span>,<span class="string">&#x27;-%.2f&#x27;</span> % y,ha=<span class="string">&#x27;right&#x27;</span>,va=<span class="string">&#x27;top&#x27;</span>,fontsize=<span class="number">8</span>)</span><br><span class="line">plt.xlim(-<span class="number">5</span>,n)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.ylim(-<span class="number">1.25</span>,<span class="number">1.25</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_31_0.png" alt="png"></p>
<h1 id="生成等高线"><a href="#生成等高线" class="headerlink" title="生成等高线"></a>生成等高线</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">1</span>-x/<span class="number">2</span>+x**<span class="number">5</span>+y**<span class="number">3</span>)*np.exp(-x**<span class="number">2</span>-y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line">x = np.linspace(-<span class="number">3</span>,<span class="number">3</span>,n)</span><br><span class="line">y = np.linspace(-<span class="number">3</span>,<span class="number">3</span>,n)</span><br><span class="line">X,Y = np.meshgrid(x,y)</span><br><span class="line">plt.contourf(X,Y,f(X,Y),<span class="number">8</span>,alpha=<span class="number">0.75</span>,cmap=plt.cm.hot) <span class="comment"># cm=colormap</span></span><br><span class="line">C = plt.contour(X,Y,f(X,Y),<span class="number">8</span>,colors=<span class="string">&#x27;black&#x27;</span>,linewidths=<span class="number">.5</span>)</span><br><span class="line">                                        <span class="comment"># 8是指八条等高线</span></span><br><span class="line">                                        <span class="comment"># 注意：</span></span><br><span class="line">                                        <span class="comment"># colors,linewidths后面都有s</span></span><br><span class="line">plt.clabel(C,inline=<span class="literal">True</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>([], [])
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_33_1.png" alt="png"></p>
<h1 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"><span class="comment"># X,Y value</span></span><br><span class="line">X = np.arange(-<span class="number">4</span>,<span class="number">4</span>,<span class="number">0.25</span>)</span><br><span class="line">Y = np.arange(-<span class="number">4</span>,<span class="number">4</span>,<span class="number">0.25</span>)</span><br><span class="line">X,Y = np.meshgrid(X,Y)</span><br><span class="line">R = np.sqrt(X**<span class="number">2</span>+Y**<span class="number">2</span>)</span><br><span class="line"><span class="comment"># height value</span></span><br><span class="line">Z = np.sin(R)</span><br><span class="line">ax.plot_surface(X,Y,Z,rstride=<span class="number">1</span>,cstride=<span class="number">1</span>,cmap=plt.get_cmap(<span class="string">&#x27;rainbow&#x27;</span>),edgecolor=<span class="string">&#x27;black&#x27;</span>,linewidths=<span class="number">0.5</span>)</span><br><span class="line">ax.contourf(X,Y,Z,zdir=<span class="string">&#x27;x&#x27;</span>,offset=-<span class="number">4</span>,cmap=<span class="string">&#x27;rainbow&#x27;</span>) <span class="comment"># zdir=&#x27;z&#x27;对应从z轴压下去</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.contour.QuadContourSet at 0x1e5ab98dd30&gt;
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_35_1.png" alt="png"></p>
<h1 id="Subplot-多合一显示"><a href="#Subplot-多合一显示" class="headerlink" title="Subplot 多合一显示"></a>Subplot 多合一显示</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 表示将figure分成两行一列</span></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>])<span class="comment"># x,y分别从0-1</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># 表示分成两行三列</span></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x1e5aa547850&gt;]
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_37_1.png" alt="png"></p>
<h1 id="Subplot-分隔显示"><a href="#Subplot-分隔显示" class="headerlink" title="Subplot 分隔显示"></a>Subplot 分隔显示</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"></span><br><span class="line"><span class="comment"># method 1:subplot2grid</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">0</span>),colspan=<span class="number">3</span>,rowspan=<span class="number">1</span>) </span><br><span class="line">                            <span class="comment"># (3,3)表示整个grid有三行三列</span></span><br><span class="line">                            <span class="comment"># (0,0)表示从第1行第1列开始开始plot</span></span><br><span class="line">                            <span class="comment"># colspan列跨度 rowspan行跨度</span></span><br><span class="line">ax1.plot([<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">ax1.set_title(<span class="string">&#x27;ax1&#x27;</span>)</span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),colspan=<span class="number">2</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),colspan=<span class="number">1</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">ax4 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">0</span>),colspan=<span class="number">1</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">ax5 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">1</span>),colspan=<span class="number">1</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_39_0.png" alt="png"></p>
<h1 id="图中图"><a href="#图中图" class="headerlink" title="图中图"></a>图中图</h1><p><strong><font size="5">set_title()</font></strong></p>
<hr>
<ul>
<li><p><strong>loc</strong>:可取”best”,1或”upper right”,2”upper left”,3”lower<br>left”,4”lower right”,代表放不同位置</p>
</li>
<li><p><strong>fontsize</strong>:int或float或{‘xx-small’,’x-small’,’small’, ‘medium’,’large’,’x-large’, ‘xx-large’}，字体大小</p>
</li>
<li><p><strong>shadow</strong>: 是否为图例边框添加阴影T，传入布尔类型</p>
</li>
<li><p><strong>labelspacing</strong>: 图例中条目之间的距离</p>
</li>
<li><p><strong>handlelength</strong>: 图例句柄的长度</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">left,bottom,width,height = <span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span> <span class="comment"># 这些值都是百分比</span></span><br><span class="line">ax1 = fig.add_axes([left,bottom,width,height]) </span><br><span class="line">ax1.plot(x,y,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">left,bottom,width,height = <span class="number">0.2</span>,<span class="number">0.6</span>,<span class="number">0.25</span>,<span class="number">0.25</span></span><br><span class="line">ax2 = fig.add_axes([left,bottom,width,height]) </span><br><span class="line">ax2.plot(y,x,<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax2.set_title(<span class="string">&#x27;title inside 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.axes([<span class="number">.6</span>,<span class="number">.2</span>,<span class="number">.25</span>,<span class="number">.25</span>])</span><br><span class="line">plt.plot(y[::-<span class="number">1</span>],x,<span class="string">&#x27;green&#x27;</span>) <span class="comment"># ::-1表示从后往前，间隔为-1</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;标题2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5, 1.0, &#39;标题2&#39;)
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_42_1.png" alt="png"></p>
<h1 id="次坐标轴"><a href="#次坐标轴" class="headerlink" title="次坐标轴"></a>次坐标轴</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">y1 = <span class="number">0.05</span>*x**<span class="number">2</span></span><br><span class="line">y2 = -<span class="number">10</span>*y1</span><br><span class="line">fig,ax1 = plt.subplots() <span class="comment"># ?</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax1.plot(x,y1,<span class="string">&#x27;g:&#x27;</span>)</span><br><span class="line">ax2.plot(x,y2,<span class="string">&#x27;m--&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;X data&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;Y1&#x27;</span>,color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;Y2&#x27;</span>,color=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0, 0.5, &#39;Y2&#39;)
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_44_1.png" alt="png"></p>
<h1 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line">fig,ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">0.01</span>)</span><br><span class="line">line, = ax.plot(x,np.sin(x))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span>(<span class="params">i</span>):</span></span><br><span class="line">    line.set_ydata(np.sin(x+i/<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    line.set_ydata(np.sin(x))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line">ani = animation.FuncAnimation(fig=fig,func=animate,frames=<span class="number">100</span>,init_func=init,interval=<span class="number">20</span>,blit=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_46_0.png" alt="png"></p>
<p>当然内容并不完整，只是初步的对matplotlib库中的工具进行介绍，后续会根据matplotlib所给的官方文件进行扩充……</p>
]]></content>
      <categories>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>1.线性表</title>
    <url>/2021/07/26/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>就是指把所有的结点用一根 <strong>直线</strong>  串起来</p>
<h1 id="连续存储-数组"><a href="#连续存储-数组" class="headerlink" title="连续存储[数组]"></a>连续存储[数组]</h1><p>1.数组是元素类型相同，大小相等的一组数</p>
<p><strong>优缺点</strong><br>优点：存取速度很快</p>
<p>缺点：</p>
<ul>
<li>事先必须知道数组的长度</li>
<li>插入删除元素很慢</li>
<li>空间通常有限制</li>
<li>需要大块连续的内存块<span id="more"></span>
<h1 id="离散存储-链表"><a href="#离散存储-链表" class="headerlink" title="离散存储[链表]"></a>离散存储[链表]</h1>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，首结点没有前驱结点，尾结点没有后续结点</li>
</ul>
<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>空间没有限制 </li>
<li>插入删除元素很快</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储密度小，每个结点的指针域需要额外占用存储空间<br>存储密度=结点数据所占空间/该结点所占的总空间</li>
<li>链式存储结构是 <strong>非随机存取</strong> 结构，对任一结点的操作都要从头指针链查找到该结点，这增加了算法的复杂度</li>
</ul>
<p>专业术语：</p>
<ul>
<li>结点：数据元素的映像。由数据域和指针域两部分组成</li>
<li>首元结点：第一个有效结点</li>
<li>尾结点：最后一个有效结点</li>
<li>头结点：<ul>
<li>头结点的数据类型和首结点类型一样</li>
<li>第一个有效结点之前的那个结点</li>
<li>头结点并不存放有效数据</li>
<li>加头结点的目的是方便对链表的操作</li>
</ul>
</li>
<li>头指针：指向头结点的指针变量</li>
<li>尾指针：指向尾结点的指针变量</li>
</ul>
<p><strong>如果希望通过一个函数来对链表进行处理我们至少需要接受哪些参数？</strong><br>只需要一个参数：头指针</p>
<p>因为我们可以通过头指针推算出链表的其他所有参数</p>
<p><strong>创建链表,并完成一些功能</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE,*PNODE; <span class="comment">//NODE等价于struct Node,  PNODE等价于struct Node *</span></span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//输出链表的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE)</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//判断链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//链表排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;<span class="comment">//向链表中插入一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span>,<span class="keyword">int</span>*)</span></span>;<span class="comment">//删除链表中的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;<span class="comment">//等价于struct Node*pHead = NULL;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">	pHead = create_list();<span class="comment">//create_list()功能：创建一个非循环单链表</span></span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	<span class="comment">//int len = length_list(pHead);</span></span><br><span class="line">	<span class="comment">//printf(&quot;链表长度为%d\n&quot;,len);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//insert_list(pHead,4,33);//插入结点</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	<span class="keyword">if</span>(delete_list(pHead,<span class="number">4</span>,&amp;val))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除成功，你删除的元素是：%d\n&quot;</span>,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败，删除的元素不存在\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	<span class="comment">//sort_list(pHead);</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	<span class="keyword">if</span>(is_empty(pHead))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表为空\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表不空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//用来存放有效结点的个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> val;<span class="comment">//用来临时存放用户输入的结点的值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入结点个数：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="comment">//分配了一个不存放有效数字的头结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配失败，程序终止/n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    <span class="comment">//规定pTail永远指向尾结点，这里也就是指向头结点</span></span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d结点的值：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;分配失败，程序终止\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pTail-&gt;pNext = pNew;<span class="comment">//这里是让Ptail指针域存放临时结点</span></span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;<span class="comment">//清空临时结点的指针域</span></span><br><span class="line">        pTail = pNew;<span class="comment">//这里是pTail指针指向了pNew</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pHead-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNODE p = pHead-&gt;pNext;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,t;</span><br><span class="line">	<span class="keyword">int</span> len = length_list(pHead);</span><br><span class="line">	PNODE p,q;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++,p=p-&gt;pNext)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>,q=p-&gt;pNext;j&lt;len;j++,q=q-&gt;pNext)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)<span class="comment">//类似于数组中的：a[i]&gt;a[j]</span></span><br><span class="line">			&#123;</span><br><span class="line">				t=p-&gt;data;</span><br><span class="line">				p-&gt;data=q-&gt;data;</span><br><span class="line">				q-&gt;data=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pHead所指向的链表的第pos个结点的前面插入一个新的结点，</span></span><br><span class="line"><span class="comment">//该结点的值是val,并且pos的值是从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	PNODE p =pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span>(pNew == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态分配内存失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;data=val;</span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	p-&gt;pNext=pNew;</span><br><span class="line">	pNew-&gt;pNext=q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> *pVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	*pVal = q-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除p结点后面的结点</span></span><br><span class="line">	p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	q = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分类：</strong></p>
<ul>
<li>单链表</li>
<li>双向链表：每一个结点有两个 <strong>指针域</strong></li>
<li>循环单链表:能通过任何一个结点找到其他所有的结点</li>
<li>循环双向链表</li>
<li>非循环链表</li>
</ul>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>尾指针指向头结点</p>
<p><strong>优点：</strong></p>
<ul>
<li>如果表的操作常常是在表的首尾位置进行，用循环链表可以方便寻找，降低时间复杂度</li>
</ul>
<p><strong>循环链表的合并</strong></p>
<ul>
<li>p存表头结点</li>
<li>Tb表头连接到Ta表尾</li>
<li>释放Tb表头结点</li>
<li>修改指针</li>
</ul>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表的每个结点再增加一个指向其直接前驱的指针域prior。</p>
<p><strong>优点:</strong><br>容易查找前驱结点和后续结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span>&#123;</span></span><br><span class="line">	Elemtype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuNode,*DuPNode;</span><br></pre></td></tr></table></figure>
<h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><ul>
<li>建立单链表<ul>
<li>头插法—元素插在链表头部<ul>
<li>1.从一个空表开始</li>
<li>2.生成新结点，将读入数据存放到新结点的数据域中</li>
<li>3.最后一个结点开始依次将各结点插入到链表的前端</li>
</ul>
</li>
<li>尾插法—元素插入在链表尾部</li>
</ul>
</li>
<li>遍历</li>
<li>查找</li>
<li>清空</li>
<li>销毁</li>
<li>求长度</li>
<li>排序</li>
<li>删除结点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>错误案例</span><br><span class="line">p-&gt;pNext=p-&gt;pNext-&gt;pNext;<span class="comment">//因为没有free所删除的结点，所以这样会让内存泄漏</span></span><br><span class="line"><span class="number">2.</span>正确写法</span><br><span class="line">r=p-&gt;pNext;<span class="comment">//r指向p后面的那个结点</span></span><br><span class="line">p-&gt;pNext=r-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);<span class="comment">//必须</span></span><br></pre></td></tr></table></figure></li>
<li>插入结点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">r=p-&gt;pNext;<span class="comment">//先用r来存放p的指针域</span></span><br><span class="line">p-&gt;pNext=q;<span class="comment">//使p的指针域指向插入的q结点</span></span><br><span class="line">q-&gt;pNext=r;<span class="comment">//q的指针域就是原来p的指针域</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">q-&gt;pNext=p-&gt;pNext;<span class="comment">//插入的q的指针域替换成p的指针域</span></span><br><span class="line">p-&gt;pNext=q;<span class="comment">//p的指针域指向q</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1.行列式</title>
    <url>/2021/06/18/1.%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>$<br>\begin{cases}<br>{\large a}_1x + {\large b}_1y = {\large c}_1&amp;&amp;(1)\\<br>{\large a}_2x + {\large b}_2y = {\large c}_2&amp;&amp;(2)<br>\end{cases}<br>$</p>
<p>方程组有唯一解:<br>$<br>x=\displaystyle<br>{<br>\frac{\left|\begin{array}{}<br>    {\large c}_1&amp;{\large b}_1\\<br>    {\large c}_2&amp;{\large b}_2<br>\end{array}\right|}<br>{\left|\begin{array}{}<br>    {\large a}_1&amp;{\large b}_1\\<br>    {\large a}_2&amp;{\large b}_2<br>\end{array}\right|}<br>}<br>$</p>
<p>$<br>y=\displaystyle<br>{<br>\frac{\left|\begin{array}{}<br>    {\large a}_1&amp;{\large c}_1\\<br>    {\large a}_2&amp;{\large c}_2<br>\end{array}\right|}<br>{\left|\begin{array}{}<br>    {\large a}_1&amp;{\large b}_1\\<br>    {\large a}_2&amp;{\large b}_2<br>\end{array}\right|}<br>}<br>$</p>
<p><strong>例</strong><br></p>
<p>$<br>\begin{cases}<br>3x + 2y = 5\\<br>5x - 7y = 29<br>\end{cases}<br>$</p>
<p>解：由于系数行列式<br></p>
<p>$<br>D=\left|\begin{array}{ccc}<br>   3 &amp;2\\<br>    5 &amp;-7<br>\end{array}\right|=-31\neq0<br>$</p>
<p>方程组有唯一解,又<br>$<br>D_1=\left|\begin{array}{ccc}<br>        5&amp;2\\<br>        29&amp;-7<br>    \end{array}\right|=-93<br>$</p>
<p>$<br>D_2=\left|\begin{array}{ccc}<br>        3&amp;5\\<br>        5&amp;29<br>    \end{array}\right|=62\\<br>$</p>
<p>故方程组的解为：</p>
<p>$<br>\begin{cases}<br>    x=\displaystyle{\frac{D_1}{D}=3}\\<br>    \\<br>    y=\displaystyle{\frac{D_2}{D}=-2}<br>\end{cases}<br>$</p>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>$\tau(3\;2\;1)=2+1=3$</p>
<ul>
<li><strong>行列式的定义计算</strong>:每一行元素错开相乘<br>$\qquad\qquad\qquad\tau(3\;2\;1)：$表示行列式3$\;$2$\;$1列逆序数值<br><br>$\qquad\qquad\qquad\tau$为偶时，正数<br><br>$\qquad\qquad\qquad\tau$为奇时，负数  </li>
</ul>
<h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><p>行列式互换(<strong>转置</strong>)，行列式的值不变   </p>
<ul>
<li><strong>即</strong><br>$<br>\left|\begin{array}{ccc}<br>{\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1n}\\<br>{\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2n}\\<br>\vdots&amp;\vdots&amp;     &amp;\vdots\\<br>{\large a}_{n1}&amp;{\large a}_{n2}&amp;\cdots&amp;{\large a}_{nn}\\<br>\end{array}\right|=<br>\left|\begin{array}{ccc}<br>{\large a}_{11}&amp;{\large a}_{21}&amp;\cdots&amp;{\large a}_{n1}\\<br>{\large a}_{12}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{n2}\\<br>\vdots&amp;\vdots&amp;     &amp;\vdots\\<br>{\large a}_{1n}&amp;{\large a}_{2n}&amp;\cdots&amp;{\large a}_{nn}\\<br>\end{array}\right|<br>$<br><br><br>一般项：<br>$<br>{\large a}_{1j_1}\quad{\large a}_{2j_2}\;\cdots\;\;{\large a}_{nj_n}\qquad<br>{\large a}_{j_{_1}1}\quad{\large a}_{j_{_2}2}\;\cdots\;\;{\large a}_{j_{_n}n}<br>$<br><br><br>某行所有元素都是两个数的和，<br>则可把行列式写成两个行列式值和，<br>字母行列式的求解要想到拆行或列<br><br>$\quad<br>\left|\begin{array}{ccc}<br>  \vdots     &amp;     \vdots  &amp;     &amp; \vdots\\<br>  {\large a}_{i1}+{\large b}_{i1} &amp; {\large a}_{i2}+{\large b}_{i2} &amp; \cdots&amp; {\large a}_{in}+{\large b}_{in}\\<br>  \vdots     &amp;      \vdots &amp;     &amp; \vdots\\<br>\end{array}\right|<br>$<br><br><br>$=<br>\left|\begin{array}{ccc}<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>   {\large a}_{i1} &amp; {\large a}_{i2} &amp; \cdots&amp; {\large a}_{in}\\<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>\end{array}\right|+<br>\left|\begin{array}{ccc}<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>   {\large b}_{i1} &amp; {\large b}_{i2} &amp; \cdots&amp; {\large b}_{in}\\<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>\end{array}\right|<br>$<br><br><br><br><strong>证：</strong><br>$<br>\begin{aligned}<br>左<br>&amp;= \sum (-1)^{\tau(j_1\;j_2\cdots j_n)}\;{\large a}_{1j_1}\cdots({\large a}_{ij_i}+{\large b}_{ij_i})\cdots {\large a}_{nj_n}\\<br>\\<br>&amp;= \sum(-1)^{\tau(j_1\;j_2\cdots j_n)} \; {\large a}_{1j_1}\cdots{\large a}_{ij_i}\cdots {\large a}_{nj_n}\\<br>\\<br>&amp;\quad+ \sum(-1)^{\tau(j_1\;j_2\cdots j_n)} \; {\large a}_{1j_1}\cdots{\large b}_{ij_i}\cdots {\large a}_{nj_n}<br>\end{aligned}<br>$</li>
</ul>
<p><strong>其他的性质:</strong></p>
<ul>
<li><p>如果行列式的值为0，则矩阵是<u><strong>奇异矩阵</strong></u>，也就是矩阵没有逆矩阵。</p>
</li>
<li><p>$|A|\not=0\Leftrightarrow r(A)=n\Leftrightarrow$矩阵可逆$\Leftrightarrow A\;$的行(列)向量线性组无关$\Leftrightarrow A\;$的特征值$\lambda\not=0$</p>
</li>
<li><p>（方阵）$|AB|=|A||B|$</p>
</li>
<li><p>$|A^{-1}|=\displaystyle\frac{1}{|A|}$</p>
</li>
<li><p>$|2A|=2^n|A|$</p>
</li>
</ul>
<h2 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h2><p><strong>注意：代数余子式${\large a}_{ij}$需要带正负号，而代数余子式不需要，这里注意区分</strong></p>
<ul>
<li>$D={\large a}_{11}{\large a}_{11}+{\large a}_{12}{\large a}_{12}+\cdots+{\large a}_{1n}{\large a}_{1n}=\sum\limits_{j=1}^n{\large a}_{1j}{\large a}_{1j}$<br><br>$D={\large a}_{11}{\large a}_{11}+{\large a}_{21}{\large a}_{21}+\cdots+{\large a}_{n1}{\large a}_{n1}=\sum\limits_{i=1}^n{\large a}_{i1}{\large a}_{i1}$<br><br>$D=\sum\limits_{j=1}^n {\large a}_{ij}{\large a}_{ij}\quad(i=1,2,\cdots,n)\quad i行$<br><br>$D=\sum\limits_{j=1}^n {\large a}_{ij}{\large a}_{ij}\quad(j=1,2,\cdots,n)\quad j列$</li>
</ul>
<h2 id="特殊的行列式"><a href="#特殊的行列式" class="headerlink" title="特殊的行列式"></a>特殊的行列式</h2><h3 id="三角行列式"><a href="#三角行列式" class="headerlink" title="三角行列式"></a>三角行列式</h3><p>上三角：</p>
<p>$<br>\left|\begin{array}{ccc}<br>    {\large a}_{11} &amp; {\large a}_{12} &amp;\cdots&amp; {\large a}_{1n}\\<br>    0   &amp; {\large a}_{22} &amp;\cdots&amp; {\large a}_{2n}\\<br>    \vdots&amp;\vdots&amp;   &amp;\vdots\\<br>    0   &amp; 0   &amp;\cdots&amp; {\large a}_{nn}\\<br>\end{array}\right|<br>$</p>
<p>下三角：</p>
<p>$<br>\left|\begin{array}{ccc}<br>    {\large a}_{11} &amp; 0    &amp;\cdots&amp; 0\\<br>    {\large a}_{21} &amp; {\large a}_{22}&amp;\cdots&amp; 0\\<br>    \vdots&amp;\vdots &amp;    &amp;\vdots\\<br>    {\large a}_{n1} &amp; {\large a}_{n2}&amp;\cdots&amp;{\large a}_{nn}\\<br>\end{array}\right|<br>$<br><br><br>$Det={\large a}_{11}{\large a}_{22}{\large a}_{33}\cdots {\large a}_{nn}$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个可以通过逆序数理解</span></span><br></pre></td></tr></table></figure>
<h3 id="范德蒙行列式"><a href="#范德蒙行列式" class="headerlink" title="范德蒙行列式"></a>范德蒙行列式</h3><p>$<br>\qquad\left|\begin{array}{ccc}<br>    1  &amp;  1  &amp;  1  &amp; \cdots &amp; 1\\<br>    {\large a}_1 &amp; {\large a}_2 &amp; {\large a}_3 &amp; \cdots &amp; {\large a}_n\\<br>    {\large a}_1^2&amp;{\large a}_2^2&amp;{\large a}_3^2&amp; \cdots&amp; {\large a}_n^2\\<br>    \vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>    {\large a}_1^{n-1}&amp;{\large a}_2^{n-1}&amp;{\large a}_3^{n-1}&amp;\cdots&amp;{\large a}_n^{n-1}<br>\end{array}\right|$</p>
<p>$\;{\large=}\prod\limits_{1\leqslant j&lt;i\leqslant n}({\large a}_i-{\large a}_j)<br>$</p>
<p><strong>应用</strong>  </p>
<p>$D=<br>\left|\begin{array}{ccc}1&amp;1&amp;1\\{\large a}&amp;{\large b}&amp;{\large c}\\{\large a}^3&amp;{\large b}^3&amp;{\large c}^3\end{array}\right|的值$</p>
<ul>
<li>首先构造(注意积累)<br><br>$<br>\begin{aligned}<br>D_4&amp;=\left|\begin{array}{ccc}<br>1&amp;1&amp;1&amp;1\\<br>{\large a}&amp;{\large b}&amp;{\large c}&amp;{\large x}\\<br>{\large a}^2&amp;{\large b}^2&amp;{\large c}^2&amp;{\large x}^2\\<br>{\large a}^3&amp;{\large b}^3&amp;{\large c}^3&amp;{\large x}^3\\<br>\end{array}\right|\\<br>&amp;=1\cdot {\large a}_{14}+{\large x}\cdot {\large a}_{24}+{\large x}^2\cdot(-D)+{\large x}^3 \cdot {\large a}_{44}\\<br>&amp;=({\large x}-{\large c})({\large x}-{\large b})({\large x}-{\large a})({\large c}-{\large b})({\large c}-{\large a})({\large b}-{\large a})<br>\end{aligned}$<br>$\longrightarrow D\;$的值就是${\large x}_2$系数的负数</li>
</ul>
<h3 id="拉普拉斯展开式"><a href="#拉普拉斯展开式" class="headerlink" title="拉普拉斯展开式"></a>拉普拉斯展开式</h3><ul>
<li>有一块全是零的行列式</li>
</ul>
<hr>
<ul>
<li>主对角线<br><br>$\quad<br>\left|\begin{array}{cccc:cccc}<br>  {\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1m}&amp;0&amp;0&amp;\cdots&amp;0\\<br>  {\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2m}&amp;0&amp;0&amp;\cdots&amp;0\\<br>   \vdots&amp; \vdots  &amp; &amp; \vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>  {\large a}_{m1}&amp;{\large c}_{m2}&amp;\cdots&amp;{\large a}_{mm}&amp;0&amp;0&amp;\cdots&amp;0\\<br>  \hdashline<br>  {\large c}_{11}&amp;{\large c}_{12}&amp;\cdots&amp;{\large c}_{1m}&amp;{\large b}_{11}&amp;{\large b}_{12}&amp;\cdots&amp;{\large b}_{1n}\\<br>  {\large c}_{21}&amp;{\large c}_{22}&amp;\cdots&amp;{\large c}_{2m}&amp;{\large b}_{21}&amp;{\large b}_{22}&amp;\cdots&amp;{\large b}_{2n}\\<br>  \vdots&amp;\vdots&amp;    &amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>  {\large c}_{m1}&amp;{\large c}_{m2}&amp;\cdots&amp;{\large c}_{mm}&amp;{\large b}_{n1}&amp;{\large b}_{n2}&amp;\cdots&amp;{\large b}_{nn}\\<br>\end{array}\right|<br>$<br><br><br>${\large=}<br>\left|\begin{array}{ccc}<br>  {\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1m}\\<br>  {\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2m}\\<br>  \vdots&amp;\vdots&amp;    &amp;\vdots\\<br>  {\large a}_{m1}&amp;{\large c}_{m2}&amp;\cdots&amp;{\large a}_{mm}\\<br>\end{array}\right|<br>$ $\cdot<br>\left|\begin{array}{ccc}<br>  {\large b}_{11}&amp;{\large b}_{12}&amp;\cdots&amp;{\large b}_{1n}\\<br>  {\large b}_{21}&amp;{\large b}_{22}&amp;\cdots&amp;{\large b}_{2n}\\<br>  \vdots&amp;\vdots&amp;&amp;\vdots\\<br>  {\large b}_{n1}&amp;{\large b}_{n2}&amp;\cdots&amp;{\large b}_{nn}\\<br>\end{array}\right|<br>$<br><br></li>
<li>副对角线<br><br>例<br><br>$\quad<br>\left|\begin{array}{cc:ccc}<br>  0&amp;0&amp;{\large a}_{11}&amp;{\large a}_{12}&amp;{\large a}_{13}\\<br>  0&amp;0&amp;{\large a}_{21}&amp;{\large a}_{22}&amp;{\large a}_{23}\\<br>  0&amp;0&amp;{\large a}_{31}&amp;{\large a}_{31}&amp;{\large a}_{33}\\<br>  \hdashline<br>  {\large b}_{11}&amp;{\large b}_{12}&amp;{\large c}_{11}&amp;{\large c}_{12}&amp;{\large c}_{13}\\<br>  {\large b}_{21}&amp;{\large b}_{22}&amp;{\large c}_{21}&amp;{\large c}_{22}&amp;{\large c}_{23}<br>\end{array}\right|<br>$<br><br>$=(-1)^{3\times2}<br>\left|\begin{array}{ccc}<br>  {\large a}_{11}&amp;{\large a}_{12}&amp;{\large a}_{13}\\<br>  {\large a}_{21}&amp;{\large a}_{22}&amp;{\large a}_{23}\\<br>  {\large a}_{31}&amp;{\large a}_{31}&amp;{\large a}_{33}<br>\end{array}\right|<br>\cdot<br>\left|\begin{array}{cc}<br>  {\large b}_{11}&amp;{\large b}_{12}\\<br>  {\large b}_{21}&amp;{\large b}_{22}<br>\end{array}\right|<br>$<br><br>$\qquad\uparrow$<br><br>$3\times2\;表示:\;A\;的阶数\times B\;的阶数$<br><br>$\qquad \qquad\quad\; ps:$当然也可以交换列，转化成主对角线的拉普拉斯展开<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分块求解行列式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>目前对于行列式的笔记就到这儿，后面会继续深入研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>10.CSS3新增特性</title>
    <url>/2021/07/21/10-CSS3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="新增选择器"><a href="#新增选择器" class="headerlink" title="新增选择器"></a>新增选择器</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器可以根据元素特定属性来选择元素，这样就可以不用借助于类或者id选择器。</p>
<p>选择符|简介<br>E[att]|选择具有att属性的 E 元素<br>E[att=”val”]|选择具有att 属性且属性值等于val 的E 元素<br>E[att^=”val”]|匹配具有att 属性且值以val 开头的E 元素<br>E[att$=”val”]|匹配具有att 属性且值以val 结尾的E 元素<br>E[att*=”val”]|匹配具有att属性且值中含有val 的E 元素</p>
<h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><p>结构伪类选择器主要根据文档结构来选择，常用于父级选择器里面的子元素</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择符</th>
<th style="text-align:left">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E:first-child</td>
<td style="text-align:left">匹配父元素中的第一个子元素E</td>
</tr>
<tr>
<td style="text-align:left">E:last-child</td>
<td style="text-align:left">匹配父元素中最后一个E 元素</td>
</tr>
<tr>
<td style="text-align:left">E:nth-child(n)</td>
<td style="text-align:left">匹配父元素中的第n个子元素E</td>
</tr>
<tr>
<td style="text-align:left">E:first-of-type</td>
<td style="text-align:left">指定类型E 的第一个</td>
</tr>
<tr>
<td style="text-align:left">E:last-of-type</td>
<td style="text-align:left">指定类型E 的最后一个</td>
</tr>
<tr>
<td style="text-align:left">E:nth-of-type(n)</td>
<td style="text-align:left">指定类型E的第n个</td>
</tr>
</tbody>
</table>
</div>
<p><strong>nth-child(n)</strong> 选择某个父元素的一个或多个特定的子元素</p>
<ul>
<li><strong>n可以是数字，关键字和公式</strong></li>
<li>n如果是数字，就是选择第n个子元素，里面数字从1开始</li>
<li>n可以是关键字:even偶数，odd奇数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">公式</th>
<th style="text-align:left">取值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2n</td>
<td style="text-align:left">偶数</td>
</tr>
<tr>
<td style="text-align:left">2n+1</td>
<td style="text-align:left">奇数</td>
</tr>
<tr>
<td style="text-align:left">5n</td>
<td style="text-align:left">5 10 15…</td>
</tr>
<tr>
<td style="text-align:left">n+5</td>
<td style="text-align:left">从第5个开始（包含第五个）到最后</td>
</tr>
<tr>
<td style="text-align:left">-n+5</td>
<td style="text-align:left">前五个（包含第5个）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>nth-child(n)</strong> 和 <strong>nth-of-type(n)</strong> 的区别<br>nth-child 会把所有的子元素排列序号</p>
<p>nth-child 只会把指定的子元素排序号</p>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>伪元素选择器可以帮助我们利用CSS 创建新标签元素，而不需要HTML标签，从而简化HTML结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择符</th>
<th style="text-align:left">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">::before</td>
<td style="text-align:left">在元素内部的前面插入内容</td>
</tr>
<tr>
<td style="text-align:left">::after</td>
<td style="text-align:left">在元素内部的后面插入内容</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong></p>
<ul>
<li><strong>before</strong> 和 <strong>after</strong> 创建一个元素，但是属于行内元素</li>
<li>新创建的这个元素在文档树中是找不到的，所以我们称之为伪元素</li>
<li><strong>语法：element::before{}</strong></li>
<li>before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素</li>
<li>伪元素选择器和标签选择器一样，权重为1</li>
</ul>
<h2 id="CSS3-盒子模型"><a href="#CSS3-盒子模型" class="headerlink" title="CSS3 盒子模型"></a>CSS3 盒子模型</h2><p>CSS3中可以通过 <strong>box-sizing</strong> 来指定盒子模型，有两个值：即可指定为 <strong>content-box</strong>、<strong>border-box</strong>，这样我们计算盒子大小的方式就发生了改变</p>
<p>1.box-sizing: content-box 盒子大小为width + padding + border （默认）</p>
<p>2.box-sizing: border-box 就不会撑大盒子（前提padding和border不会超过width宽度）</p>
<h1 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h1><p>过渡（transition）让我们可以在不适用flash动画或javascript的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<p>过渡动画：是从一个状态渐渐的过渡到另外一个状态</p>
<p><strong>经常和:hover一起搭配使用</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">tansition: 要过渡的属性 花费时间 曲线运动 何时开始;</span><br></pre></td></tr></table></figure>
<p><strong>1.属性</strong>：想要变化的CSS属性，宽度高度 背景颜色 内外边距都可以。如果想要所有的属性都变化过渡，写一个 <strong>all</strong> 就可以</p>
<p><strong>2.花费时间</strong>：单位 s（必须）</p>
<p><strong>3.曲线运动</strong>：默认是ease（可省略）</p>
<p><strong>4.何时开始</strong>：单位 s（必须）可以设置延迟出发时间 默认是0s（可省略）</p>
<h1 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h1><blockquote>
<p><strong>转换（transform）</strong> 可以实现元素的位移、旋转、缩放等效果，转换可以简单理解为变形</p>
<h2 id="二维坐标系"><a href="#二维坐标系" class="headerlink" title="二维坐标系"></a>二维坐标系</h2><p>2D转换是改变标签在二维平面上的位置和形状的一种技术</p>
<h2 id="2D-转换之移动-translate"><a href="#2D-转换之移动-translate" class="headerlink" title="2D 转换之移动 translate"></a>2D 转换之移动 translate</h2><p>2D移动是2D转换里面的一种功能，可以改变元素在页面中的位置，类似 <strong>定位</strong></p>
</blockquote>
<p>1.语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(x,y)或者分开写</span><br><span class="line">transform: <span class="built_in">translateX</span>(n)</span><br><span class="line">transform: <span class="built_in">translateY</span>(n)</span><br></pre></td></tr></table></figure></p>
<p><strong>2.重点</strong></p>
<ul>
<li>定义2D转换中的移动，沿着X和Y轴移动元素</li>
<li>translate最大的优点：不会影响到其他元素的位置</li>
<li>translate中的百分比单位是相对于自身元素的translate:(50%,50%);</li>
<li>对行内元素没有效果</li>
</ul>
<h2 id="2D-转换之旋转-rotate"><a href="#2D-转换之旋转-rotate" class="headerlink" title="2D 转换之旋转 rotate"></a>2D 转换之旋转 rotate</h2><blockquote>
<p>2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转</p>
</blockquote>
<p>1.语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate</span>(度数)</span><br></pre></td></tr></table></figure></p>
<p><strong>2.重点</strong></p>
<ul>
<li>rotate里面跟度数，单位是deg 比如 rotate(45deg)</li>
<li>角度为正时，顺时针，负时，为逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ul>
<h2 id="2D-转换中心点-transform-origin"><a href="#2D-转换中心点-transform-origin" class="headerlink" title="2D 转换中心点 transform-origin"></a>2D 转换中心点 transform-origin</h2><p>1.语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: x y;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.重点</strong></p>
<ul>
<li>注意后面参数x和y用空格隔开</li>
<li>x y默认转换的中心点是元素元素的中心点(50% 50%)</li>
<li>还可以给x y 设置 像素 或者 方位名词 (top bottom left right cneter)</li>
</ul>
<h2 id="2D转换之缩放-scale"><a href="#2D转换之缩放-scale" class="headerlink" title="2D转换之缩放 scale"></a>2D转换之缩放 scale</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">scale</span>(x,y);</span><br></pre></td></tr></table></figure>
<p><strong>2.注意</strong></p>
<ul>
<li>注意其中的x和y用逗号分隔</li>
<li>transform:scale(1,1)：宽和高都放大一倍，相当于没放大</li>
<li>transform:scale(2,2)：宽和高都放大2倍</li>
<li>transform:scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于scale(2,2)</li>
<li>transform缩放最大的优势：可以设置转换 <strong>中心点</strong> 缩放，默认为中心点缩放的，而且 <strong>不影响其他盒子</strong></li>
</ul>
<h2 id="2D转换的综合写法"><a href="#2D转换的综合写法" class="headerlink" title="2D转换的综合写法"></a>2D转换的综合写法</h2><p><strong>注意:</strong><br>1.同时使用多个转换，其格式为：transform:translate() rotate() scale()…等，</p>
<p>2.其顺序会影响转换的效果。(先旋转会改变坐标轴方向)</p>
<p><strong>3.当我们同时有位移和其他属性的时候，记得要将位移放到最前</strong></p>
<h1 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h1><blockquote>
<p><strong>动画</strong> 可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
</blockquote>
<p>相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果</p>
<h2 id="动画的基本使用"><a href="#动画的基本使用" class="headerlink" title="动画的基本使用"></a>动画的基本使用</h2><p>制作动画分为两步：</p>
<p>1.先定义动画</p>
<p>2.再使用（调用）动画</p>
<p><strong>1.用keyframes定义动画（类似定义类选择器）</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>动画序列</strong></p>
<ul>
<li>0%是动画的 <strong>开始</strong>,100%是动画的 <strong>完成</strong></li>
<li>在 <strong>@keyframes</strong> 中规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果</li>
<li>动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的 <strong>次数</strong></li>
<li>使用百分比来规定变化发生的时间，或用关键词”<strong>from</strong>“和”<strong>to</strong>“，等同于 <strong>0%</strong> 和 <strong>100%</strong></li>
</ul>
<p><strong>2.元素使用动画</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="comment">/* 调用动画 */</span></span><br><span class="line">    <span class="attribute">animation-name</span>: 动画名称;</span><br><span class="line">    <span class="comment">/* 持续时间 */</span></span><br><span class="line">    <span class="attribute">animation-duration</span>: 持续时间;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="动画常用属性"><a href="#动画常用属性" class="headerlink" title="动画常用属性"></a>动画常用属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@keyframes</td>
<td style="text-align:left">规定动画</td>
</tr>
<tr>
<td style="text-align:left">animation</td>
<td style="text-align:left">所有动画属性的简写属性，除了animathion-play-state属性</td>
</tr>
<tr>
<td style="text-align:left">animation-name</td>
<td style="text-align:left">规定@keyframes动画的名称（必须）</td>
</tr>
<tr>
<td style="text-align:left">animation-duration</td>
<td style="text-align:left">规定动画完成一个周期所花费的秒或毫秒，默认是0。（必须）</td>
</tr>
<tr>
<td style="text-align:left">animation-timing-funciton</td>
<td style="text-align:left">规定动画的速度曲线，默认”ease”</td>
</tr>
<tr>
<td style="text-align:left">animation-delay</td>
<td style="text-align:left">规定动画何时开始，默认是0</td>
</tr>
<tr>
<td style="text-align:left">animation-iteration-count</td>
<td style="text-align:left">规定动画被播放的次数，默认是1，还有infinite</td>
</tr>
<tr>
<td style="text-align:left">animation-direction</td>
<td style="text-align:left">规定动画是否在下一个周期逆向播放，默认是”normal”,alternate逆播放</td>
</tr>
<tr>
<td style="text-align:left">animation-play-state</td>
<td style="text-align:left">规定动画是否正在运行或暂停，默认是”running”,还有”pause”</td>
</tr>
<tr>
<td style="text-align:left">animation-fill-mode</td>
<td style="text-align:left">规定动画结束后状态，保持forwards回到起始backwards</td>
</tr>
</tbody>
</table>
</div>
<h2 id="动画简写属性"><a href="#动画简写属性" class="headerlink" title="动画简写属性"></a>动画简写属性</h2><p>animation: 动画名称 持续时间 曲线运动 何时开始 播放次数 是否反方向 动画起始或者结束的状态<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>简写属性里面不包含 <strong>animation-play-state</strong></li>
<li>暂停动画:<strong>animation-play-state:paused;</strong> 经常和鼠标经过等其他搭配使用</li>
<li>想要动画走回来，而不是直接跳回来：animation-diraction:alternate</li>
<li>盒子动画结束后，停在结束位置： animation-fill-mode: forwards</li>
</ul>
<h2 id="速度曲线细节"><a href="#速度曲线细节" class="headerlink" title="速度曲线细节"></a>速度曲线细节</h2><p>animation-timing-function:规定动画的速度曲线，默认是”ease”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">linear</td>
<td style="text-align:left">动画从头到尾的速度是相同的。匀速</td>
</tr>
<tr>
<td style="text-align:left">ease</td>
<td style="text-align:left">默认。动画以低速开始，然后加快，在结束前变慢</td>
</tr>
<tr>
<td style="text-align:left">ease-in</td>
<td style="text-align:left">动画以低速开始</td>
</tr>
<tr>
<td style="text-align:left">ease-out</td>
<td style="text-align:left">动画以低速结束</td>
</tr>
<tr>
<td style="text-align:left">ease-in-out</td>
<td style="text-align:left">动画以低速开始和结束</td>
</tr>
<tr>
<td style="text-align:left">steps()</td>
<td style="text-align:left">指定了时间函数中的间隔数量（步长）</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS3-3D转换"><a href="#CSS3-3D转换" class="headerlink" title="CSS3 3D转换"></a>CSS3 3D转换</h1><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><ul>
<li>x轴：向右为正</li>
<li>y轴：向下为正</li>
<li>z轴：向外为正</li>
</ul>
<h2 id="3D位移-translate3d"><a href="#3D位移-translate3d" class="headerlink" title="3D位移 translate3d"></a>3D位移 translate3d</h2><ul>
<li>transform:translate3dX(100px):仅在X轴上移动</li>
<li>transform:translate3dY(100px):仅在y轴上移动</li>
<li>transform:translate3dZ(100px):仅在z轴上移动<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(x,y,z)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>xyz是不能有省略的，如果没有就写0</strong></p>
<h2 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视 perspective"></a>透视 perspective</h2><ul>
<li>如果想要在网页中产生3D效果需要透视</li>
<li>模拟人的视觉位置，可认为安排一只眼去看</li>
<li>透视我们也称为视距：视距就是人的眼睛到屏幕的距离</li>
<li>距离视觉点越近的在电脑平面成像越大，越远成像越小</li>
<li>透视的单位是像素</li>
</ul>
<p><strong>透视写在被观察元素的父盒子上面的</strong></p>
<p><strong>d</strong>:就是视距，视距就是一个距离人的眼睛到屏幕的距离</p>
<p><strong>z</strong>:就是z轴，物体距离屏幕的距离，z轴越大（正值）我们看到的物体越大。</p>
<h2 id="3D旋转-rotate3d"><a href="#3D旋转-rotate3d" class="headerlink" title="3D旋转 rotate3d"></a>3D旋转 rotate3d</h2><ul>
<li>transform:rotateX(45deg):沿 <strong>x轴正方向</strong> 旋转45°</li>
<li>transform:rotateY(45deg):沿 <strong>y轴正方向</strong> 旋转45°</li>
<li>transform:rotateZ(45deg):沿 <strong>z轴正方向</strong> 旋转45°</li>
<li>transform:rotate3d(x,y,z,deg):（了解）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate3d</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">45deg</span>)</span><br><span class="line">这个是按照矢量叠加，也就是沿(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)旋转</span><br></pre></td></tr></table></figure>
<p><strong>左手准则</strong></p>
<ul>
<li>左手的手拇指指向x轴的正方向</li>
<li>其余手指的弯曲方向就是该元素沿x轴旋转的方向</li>
</ul>
<h2 id="3D呈现-transform-style"><a href="#3D呈现-transform-style" class="headerlink" title="3D呈现 transform-style"></a>3D呈现 transform-style</h2><ul>
<li>子元素是否开启三维立体环境</li>
<li>transform-style:flat 子元素不开启3d立体空间， 默认</li>
<li>transform-style:preserve-3d; 子元素开启立体空间</li>
<li>代码写给父级，但是影响的是子盒子</li>
</ul>
<h1 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h1><p>浏览器私有前缀是为了兼容老版本的写法，比较新版本的浏览器无需添加</p>
<p><strong>1.私有前缀</strong></p>
<ul>
<li>-moz-:代表firefox浏览器私有属性</li>
<li>-ms-:代表ie浏览器私有属性</li>
<li>-webkit-:代表safari、chrome私有属性</li>
<li>-o-:代表Opera私有属性</li>
</ul>
<p><strong>2.提倡写法</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">-webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">-o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2.CSS字体与文本属性</title>
    <url>/2021/07/20/2-CSS%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS-字体属性"><a href="#CSS-字体属性" class="headerlink" title="CSS 字体属性"></a>CSS 字体属性</h1><h2 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h2><p>CSS 使用 <strong>font-famliy</strong> 属性定义 <strong>字体</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-family</span>: <span class="string">&quot;微软雅黑&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font</span>-famliy: Arial,<span class="string">&quot;Microsoft YaHei&quot;</span>,<span class="string">&quot;微软雅黑&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p>CSS使用 <strong>font-size</strong> 属性定义字体 <strong>大小</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>px（像素）大小是页面最常用的单位</li>
<li>由于不同浏览器默认显示的字号可能不一致，所以尽量给一个明确值大小，不要默认大小</li>
</ul>
<h2 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h2><p>用 <strong>font-weight</strong> 定义字体 <strong>粗细</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">normal</td>
<td style="text-align:left">默认值（不加粗）</td>
</tr>
<tr>
<td style="text-align:left">bold</td>
<td style="text-align:left">定义粗体</td>
</tr>
<tr>
<td style="text-align:left">100-900</td>
<td style="text-align:left">400=normal,700=bold  <strong>（后面不跟单位）</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><p><strong>font-style</strong> 属性定义文字风格<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">normal</td>
<td style="text-align:left">默认值</td>
</tr>
<tr>
<td style="text-align:left">italic</td>
<td style="text-align:left">斜体</td>
</tr>
</tbody>
</table>
</div>
<h2 id="字体符复合属性"><a href="#字体符复合属性" class="headerlink" title="字体符复合属性"></a>字体符复合属性</h2><p>也就是字体属性的简洁书写形式</p>
<p>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: font-style font-weight font-size/line-height font-famliy;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">16px</span>/<span class="number">20px</span> <span class="string">&#x27;Microsoft yahei&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font</span>: <span class="number">16px</span> <span class="string">&#x27;Microsoft yahei&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>注意</strong></p>
<ul>
<li><strong>不能更换顺序书写</strong></li>
<li><strong>必须保留font-size和font-family属性</strong>，否则font属性不起作用,其他的可以省略</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">字号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">font-size</td>
<td style="text-align:left">字号</td>
</tr>
<tr>
<td style="text-align:left">font-family</td>
<td style="text-align:left">字体</td>
</tr>
<tr>
<td style="text-align:left">font-weight</td>
<td style="text-align:left">字体粗细</td>
</tr>
<tr>
<td style="text-align:left">font-style</td>
<td style="text-align:left">字体样式</td>
</tr>
<tr>
<td style="text-align:left">font</td>
<td style="text-align:left">字体连写</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS-文本属性"><a href="#CSS-文本属性" class="headerlink" title="CSS 文本属性"></a>CSS 文本属性</h1><h2 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h2><p>color属性定义文本的颜色<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表示</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">预定义的颜色值</td>
<td style="text-align:left">red,green,blue,pink</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">#ff000,#ff6600···</td>
</tr>
<tr>
<td style="text-align:left">RGB代码</td>
<td style="text-align:left">rgb(255,0,0)或rgb(100%,0%,0%)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h2><p><strong>text-aligh</strong> 属性用于设置元素内文本内容的水平对齐方式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">左对齐（默认）</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">右对齐</td>
</tr>
<tr>
<td style="text-align:left">center</td>
<td style="text-align:left">居中对齐</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h2><p><strong>text-decoration</strong> 属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left">默认，可以用来取消链接的下划线</td>
</tr>
<tr>
<td style="text-align:left">underline</td>
<td style="text-align:left">下划线</td>
</tr>
<tr>
<td style="text-align:left">overline</td>
<td style="text-align:left">上划线</td>
</tr>
<tr>
<td style="text-align:left">line-through</td>
<td style="text-align:left">删除线</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h2><p><strong>text-indent</strong> 属性用来指定文本的第一行的缩进，通常是将段落 <strong>首行缩进</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>em</strong> 单位表示相对单位，就是当前1个文字的大小</p>
<h2 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h2><p><strong>line-height</strong> 属性用于设置行间的距离（行高），可以控制文字行与行之间的距离<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><div style="width: 100px;height: 20px;text-align: center;line-height: 20px;border:1px solid;border-bottom:0;">
上方距离
</div></p>
<p><div style="width: 100px;height: 40px;text-align: center;line-height: 40px;border:1px solid;border-bottom:0;">文字大小</div></p>
<p><div style="width: 100px;height: 20px;text-align: center;line-height: 20px;border:1px solid">下方距离</div><br></p>
<p><strong>line-height</strong> 是文字上下方距离和文字大小之和</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">文本颜色</td>
</tr>
<tr>
<td style="text-align:left">text-align</td>
<td style="text-align:left">文本对齐</td>
</tr>
<tr>
<td style="text-align:left">text-indent</td>
<td style="text-align:left">文本缩进</td>
</tr>
<tr>
<td style="text-align:left">text-decoration</td>
<td style="text-align:left">文本修饰</td>
</tr>
<tr>
<td style="text-align:left">line-height</td>
<td style="text-align:left">行高</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2.html5新增特性</title>
    <url>/2021/07/21/2-html5%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTML5的新增特性"><a href="#HTML5的新增特性" class="headerlink" title="HTML5的新增特性"></a>HTML5的新增特性</h1><h2 id="HTML5-新增的带有语义化的标签"><a href="#HTML5-新增的带有语义化的标签" class="headerlink" title="HTML5 新增的带有语义化的标签"></a>HTML5 新增的带有语义化的标签</h2><ul>
<li>&lt;header&gt;：头部标签</li>
<li>&lt;nav&gt;：导航标签</li>
<li>&lt;article&gt;：内容标签</li>
<li>&lt;section&gt;：定义文档的某个区域</li>
<li>&lt;aside&gt;：侧边栏标签</li>
<li>&lt;footer&gt;：尾部标签</li>
</ul>
<h2 id="HTML5-新增的多媒体标签"><a href="#HTML5-新增的多媒体标签" class="headerlink" title="HTML5 新增的多媒体标签"></a>HTML5 新增的多媒体标签</h2><p>新增的多媒体标签主要包含两个：</p>
<p>1.音频：&lt;audio&gt;</p>
<p>2.视频：&lt;video&gt;</p>
<p>使用它们可以很方便的在页面中嵌入音频和视频，而不再去使用flash和其他浏览器插件</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>&lt;video&gt;元素支持三种视频格式：MP4、WebM、Ogg</p>
<p><strong>1.视频：&lt;video&gt;————常见属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">视频就绪自动播放（谷歌浏览器需要添加muted来解决自动播放问题）</td>
</tr>
<tr>
<td style="text-align:left">control</td>
<td style="text-align:left">controls</td>
<td style="text-align:left">向用户显示播放控件</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">pixels（像素）</td>
<td style="text-align:left">设置播放器宽度</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left">pixels（像素）</td>
<td style="text-align:left">设置值播放器高度</td>
</tr>
<tr>
<td style="text-align:left">loop</td>
<td style="text-align:left">loop</td>
<td style="text-align:left">播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td style="text-align:left">preioad</td>
<td style="text-align:left">auto（预加载视频）<br>none（不应加载视频）</td>
<td style="text-align:left">规定是否预加载视频（如果有了autoplay，就忽略该属性）</td>
</tr>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">url</td>
<td style="text-align:left">视频url地址</td>
</tr>
<tr>
<td style="text-align:left">poster</td>
<td style="text-align:left">imgurl</td>
<td style="text-align:left">视频等待的画面图片</td>
</tr>
<tr>
<td style="text-align:left">muted</td>
<td style="text-align:left">muted</td>
<td style="text-align:left">静音播放</td>
</tr>
</tbody>
</table>
</div>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>常见属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">音频在就绪后马上播放</td>
</tr>
<tr>
<td style="text-align:left">controls</td>
<td style="text-align:left">controls</td>
<td style="text-align:left">向用户显示控件</td>
</tr>
<tr>
<td style="text-align:left">loop</td>
<td style="text-align:left">loop</td>
<td style="text-align:left">循环播放</td>
</tr>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">url</td>
<td style="text-align:left">要播放的音频URL</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>谷歌浏览器把音频和视频自动播放都禁止了</li>
</ul>
<h2 id="HTML5-新增的-input-表单"><a href="#HTML5-新增的-input-表单" class="headerlink" title="HTML5 新增的 input 表单"></a>HTML5 新增的 input 表单</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type=”email”</td>
<td style="text-align:left">限制用户输入必须为Email类型</td>
</tr>
<tr>
<td style="text-align:left">type=”url”</td>
<td style="text-align:left">限制用户输入必须为URL类型</td>
</tr>
<tr>
<td style="text-align:left">type=”date”</td>
<td style="text-align:left">限制用户输入必须为日期类型</td>
</tr>
<tr>
<td style="text-align:left">type=”time”</td>
<td style="text-align:left">限制用户输入必须为时间类型</td>
</tr>
<tr>
<td style="text-align:left">type=”month”</td>
<td style="text-align:left">限制用户输入必须为月类型</td>
</tr>
<tr>
<td style="text-align:left">type=”week”</td>
<td style="text-align:left">限制用户输入必须为周类型</td>
</tr>
<tr>
<td style="text-align:left">type=”number”</td>
<td style="text-align:left">限制用户输入必须为数字类型</td>
</tr>
<tr>
<td style="text-align:left">type=”tel”</td>
<td style="text-align:left">手机号码</td>
</tr>
<tr>
<td style="text-align:left">type=”search”</td>
<td style="text-align:left">搜索框</td>
</tr>
<tr>
<td style="text-align:left">type=”color”</td>
<td style="text-align:left">生成一个颜色选择表单</td>
</tr>
</tbody>
</table>
</div>
<h2 id="HTML5-新增的表单属性"><a href="#HTML5-新增的表单属性" class="headerlink" title="HTML5 新增的表单属性"></a>HTML5 新增的表单属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">required</td>
<td style="text-align:left">required</td>
<td style="text-align:left">表单拥有该属性表示其内容不能为空，必填</td>
</tr>
<tr>
<td style="text-align:left"><strong>placeholder</strong></td>
<td style="text-align:left">提示文本</td>
<td style="text-align:left">表单的提示信息，存在默认值将不显示</td>
</tr>
<tr>
<td style="text-align:left">autofocus</td>
<td style="text-align:left">autofocus</td>
<td style="text-align:left">自动聚焦属性，页面加载完成自动聚焦到指定表单</td>
</tr>
<tr>
<td style="text-align:left">autocomplete</td>
<td style="text-align:left">off / on</td>
<td style="text-align:left">当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项<br>默认已经打开，如autocomplete=”on”，关闭autocomplete=”off”<br>需要放在表单内同时加上 name 属性,同时成功提交</td>
</tr>
<tr>
<td style="text-align:left">multiple</td>
<td style="text-align:left">multiple</td>
<td style="text-align:left">可以多选文件提交</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2.n维数组</title>
    <url>/2021/07/02/2-n%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="N维数组（ndarray）"><a href="#N维数组（ndarray）" class="headerlink" title="N维数组（ndarray）"></a>N维数组（ndarray）</h1><blockquote>
<p>ndarray是numpy的数组类，别名array</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="np-ndarray"><a href="#np-ndarray" class="headerlink" title="np.ndarray()"></a>np.ndarray()</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">用处</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shape(tuple)</td>
<td style="text-align:left">所创建数组的形状</td>
</tr>
<tr>
<td style="text-align:left">dtype(data-type)</td>
<td style="text-align:left">numpy数据的类型</td>
</tr>
<tr>
<td style="text-align:left">buffer</td>
<td style="text-align:left">初始化数据</td>
</tr>
<tr>
<td style="text-align:left">offset(int)</td>
<td style="text-align:left">初始化数据的首个数据的偏移量</td>
</tr>
<tr>
<td style="text-align:left">strides(int型tuple)</td>
<td style="text-align:left">每个轴的下标增加一时,数据指针在内存中增加的字节数</td>
</tr>
<tr>
<td style="text-align:left">order{‘C’,’F’}</td>
<td style="text-align:left">行优先(C-style)或列优先(Fortran-style)</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例</span></span><br><span class="line">np.ndarray(shape=(<span class="number">3</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>,buffer=np.arange(<span class="number">12</span>),offset=<span class="number">0</span>,order=<span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ndarray(shape=(<span class="number">3</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>,buffer=np.arange(<span class="number">12</span>),offset=<span class="number">0</span>,order=<span class="string">&quot;F&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  3,  6,  9],
       [ 1,  4,  7, 10],
       [ 2,  5,  8, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ndarray(shape=(<span class="number">3</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>,buffer=np.arange(<span class="number">20</span>),offset=<span class="number">20</span>,order=<span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])
</code></pre><h2 id="ndarray对象的常用属性"><a href="#ndarray对象的常用属性" class="headerlink" title="ndarray对象的常用属性"></a>ndarray对象的常用属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:left">转置</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:left">数列中元素个数</td>
</tr>
<tr>
<td style="text-align:center">itemsize</td>
<td style="text-align:left">数组中单个元素的字节长度</td>
</tr>
<tr>
<td style="text-align:center">dtype</td>
<td style="text-align:left">数组元素的数据类型对象</td>
</tr>
<tr>
<td style="text-align:center">ndim</td>
<td style="text-align:left">数组的维度</td>
</tr>
<tr>
<td style="text-align:center">shape</td>
<td style="text-align:left">数组的形状</td>
</tr>
<tr>
<td style="text-align:center">data</td>
<td style="text-align:left">指向存放数组数据的python buffer对象</td>
</tr>
<tr>
<td style="text-align:center">flat</td>
<td style="text-align:left">返回数组的一维迭代器</td>
</tr>
<tr>
<td style="text-align:center">imag</td>
<td style="text-align:left">返回数组的虚部</td>
</tr>
<tr>
<td style="text-align:center">real</td>
<td style="text-align:left">返回数组的实部</td>
</tr>
<tr>
<td style="text-align:center">nbytes</td>
<td style="text-align:left">数组中所有元素的字节长度</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.T</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  4,  8],
       [ 1,  5,  9],
       [ 2,  6, 10],
       [ 3,  7, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.size:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.itemsize&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.itemsize)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.dtype&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.ndim&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.flat&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.flat)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.nbytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.nbytes)</span><br></pre></td></tr></table></figure>
<pre><code>a.size:
12
-------------------------
a.itemsize
4
-------------------------
a.dtype
int32
-------------------------
a.ndim
2
-------------------------
a.flat
&lt;numpy.flatiter object at 0x0000023A25BBA040&gt;
-------------------------
a.nbytes
48
</code></pre><h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><ol>
<li>array</li>
<li>noes</li>
<li>zeros</li>
<li>eye：二维单位矩阵</li>
<li>identity：单位矩阵</li>
<li>full：生成由固定值填充的数组</li>
<li>full_like</li>
<li>arange：指定初始值、终值、步长</li>
<li>linspace：指定初始值、终值、元素个数</li>
<li>logspace：与linspaceleisi,但是创建的是等比数列</li>
<li>fromstring:从字符串中读取数据并创建数组</li>
<li>fromfunction：由第一个参数作为计算每个数组元素的函数（函数对象或者lambda表达式均可），第二个参数为数组的形状</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>,k = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0., 1., 0.],
       [0., 0., 1.],
       [0., 0., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full(shape=(<span class="number">2</span>,<span class="number">3</span>),fill_value= <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[2, 2, 2],
       [2, 2, 2]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
       1.e+09, 1.e+10])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="string">&quot;1,2,3,4,5&quot;</span>)</span><br><span class="line">np.fromstring(s1,dtype=<span class="built_in">int</span>,sep=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 4, 5])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s2 = (<span class="string">&quot;1 2 3 4 5&quot;</span>)</span><br><span class="line">np.fromstring(s2,dtype=<span class="built_in">int</span>,sep=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 4, 5])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.fromfunction(<span class="keyword">lambda</span> i,j:i+j,(<span class="number">3</span>,<span class="number">3</span>),dtype =<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">i,j</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i+j</span><br><span class="line"></span><br><span class="line">np.fromfunction(func,(<span class="number">3</span>,<span class="number">3</span>),dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
</code></pre><h2 id="创建特殊的二维数组"><a href="#创建特殊的二维数组" class="headerlink" title="创建特殊的二维数组"></a>创建特殊的二维数组</h2><ol>
<li>diag，返回数组的对角元素，或创建对角阵，对角线由参数k控制</li>
<li>diagflat，以输入作为对角元素，创建一个矩阵，对角线由k控制</li>
<li>tri，生成一个矩阵，在某对角线下元素全为1，其余为0，对角线由k控制</li>
<li>tril，输入一个矩阵，返回一个下三角阵，对角线由k控制</li>
<li>triu，类似tril,但返回矩阵的上三角矩阵</li>
<li>vander，输入一个一维数组，返回一个范德蒙行列式</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(a,k=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([4, 9])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(np.diag(a))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  0,  0],
       [ 0,  5,  0],
       [ 0,  0, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diagflat([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],k=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 0, 0, 0],
       [0, 0, 2, 0, 0],
       [0, 0, 0, 3, 0],
       [0, 0, 0, 0, 4],
       [0, 0, 0, 0, 0]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.tri(<span class="number">3</span>,<span class="number">4</span>,k=<span class="number">1</span>,dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 1, 0, 0],
       [1, 1, 1, 0],
       [1, 1, 1, 1]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.tri(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1., 0., 0., 0.],
       [1., 1., 0., 0.],
       [1., 1., 1., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line">np.tril(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
----------------------





array([[ 0,  0,  0,  0],
       [ 4,  5,  0,  0],
       [ 8,  9, 10,  0]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.triu(a)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 0,  5,  6,  7],
       [ 0,  0, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.vander([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<pre><code>array([[  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [ 64,  16,   4,   1],
       [125,  25,   5,   1]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.vander([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],N=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  2,  1],
       [ 9,  3,  1],
       [16,  4,  1],
       [25,  5,  1]])
</code></pre><h2 id="轴"><a href="#轴" class="headerlink" title="轴"></a>轴</h2><p>多维ndarray中，每一维都叫一个轴axis。有很多对于ndarray对象的运算都是基于axis进行，在入门的时候也接触了一些轴方面的应用，比如下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:,<span class="number">2</span>] <span class="comment"># 第3列所有元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 2,  6, 10])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>] <span class="comment"># 这个也等价于a[1,2]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([6])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">3</span>,:] <span class="comment"># 2到3行所有列 </span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>2.算法(用C语言实现)</title>
    <url>/2021/06/28/2-%E7%AE%97%E6%B3%95%EF%BC%88C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h1><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>设两数为$a、b(a\geqslant b)$，求$a$和$b$的最大公约数步骤：</p>
<ol>
<li>用$a$除以$b(a\geqslant b)$,得$a\div b=q\cdots r_1(0\leqslant r_1)$</li>
<li>若$r_1=0$,则$(a,b)=b$</li>
<li>若$r_1\neq 0$,则再用$b$除以$r_1$,得$b\div r_1=q\cdots r_2(0\leqslant r_2)$</li>
<li>若$r_2=0$，则$(a,b)=r_1$，若$r_2\neq0$,则继续用$r_1$除以$r_2$,……如此下去，直到能整除为止，<br>其最后一个余数为0的除数，即为$(a,b)$的最大公约数</li>
</ol>
<p>简单来说就是$a$和$b$的最大公约数等于 <strong>$a$的余数</strong> 和$b$的最大公约数</p>
<p>C语言代码实现</p>
<p>1.while循环实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max,min,c;</span><br><span class="line">    max=(a&gt;b)?a:b;</span><br><span class="line">    min=(a&lt;b)?a:b;</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = max % min;</span><br><span class="line">        max = min;</span><br><span class="line">        min = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.函数嵌套实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max,min;</span><br><span class="line">    max=(a&gt;b)?a:b;</span><br><span class="line">    min=(a&lt;b)?a:b;</span><br><span class="line">    <span class="keyword">if</span>(max % min==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(max,max % min);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>求出最大公因数，最小公倍数也很容易得出，就是两数乘积除以最大公约数</p>
<h2 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h2><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote>
<p>基本思想：两两比较相邻记录的关键字，，如果反序就交换，直到没有反序为止</p>
</blockquote>
<p>步骤：（正序为例）</p>
<ol>
<li>比较相邻元素，如果第一个比第二个大，则两数交换。</li>
<li>对之后的相邻元素进行同样的工作，从开始到结束,这样最后的元素就是最大的数，也就像泡泡一样浮到顶端不用管了</li>
<li>(小循环)针对前面未排序元素重复以上步骤。</li>
<li>(大循环)重复上述步骤，直到排序完成</li>
</ol>
<p>C语言代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp,m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="keyword">while</span>(m)<span class="comment">//如果已经是有序数组就跳出while循环，从而提高效率</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//循环次数</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N<span class="number">-1</span>-i;j++)<span class="comment">//一次循环的比较次数</span></span><br><span class="line">                <span class="keyword">if</span>(*(p+j)&gt;*(p+j+<span class="number">1</span>))<span class="comment">//相邻两个数进行比较</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        m=<span class="number">1</span>;</span><br><span class="line">                        temp=*(p+j+<span class="number">1</span>);</span><br><span class="line">                        *(p+j+<span class="number">1</span>)=*(p+j);</span><br><span class="line">                        *(p+j)=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序的复杂度分析</strong><br>最好的情况，本身有序</p>
<p>时间复杂度为$O(n)$</p>
<p>最坏的情况：<br>$\sum\limits_{k=2}^n(k-1)=\displaystyle\frac{n(n-1)}{2}$</p>
<p>也就是说最坏的情况，比较了$\displaystyle\frac{n(n-1)}{2}$次</p>
<p>时间复杂度为$O(n^2)$</p>
<p>平均时间复杂度$O(n^2)$</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p>首先在末排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，放在已排好序序列的末尾。</p>
</blockquote>
<p>简单来说就是从后面的数选出较小的数排到前面</p>
<p>C语言代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,i,j;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//循环次数</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;N;j++)<span class="comment">//一次循环的比较次数</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])<span class="comment">//也就是第i+1个数和后面的数比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp=a[j];</span><br><span class="line">                    a[j]=a[i];</span><br><span class="line">                    a[i]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论传入什么数据时间复杂度都是$O(n^2)$</p>
<p>当然这种排序方法也是一般人最容易想到的排序方法n适合处理数据较少的情况。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的个数加一的有序数组<br>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可被认为已经排好序</li>
<li>取出下一个元素，在已经排好的数组中向前扫描</li>
<li>如果已排序的元素大于这个取出的元素，就移到下一个位置</li>
<li>(小循环)重复步骤3，直到找到已排序的元素小于或等于该取出元素</li>
<li>将取出元素插入到该空出的位置</li>
<li>(大循环)重复上述步骤<br>C语言代码实现<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[i];<span class="comment">//储存要插入的数据</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;temp&lt;a[j] &amp;&amp; j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];<span class="comment">//数据向后移，给较小数据挪位</span></span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//插入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>步骤：</p>
<ol>
<li>如果n=1,结束</li>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>将两个子序列分别采用归并排序</li>
<li>将两个排好序的子序列合并成一个最终的排序序列</li>
</ol>
<p>C语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> mid)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">if</span>(end-start&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (start + end)/<span class="number">2</span>; </span><br><span class="line">		mergesort(a,start,mid);<span class="comment">//递归分解数组</span></span><br><span class="line">		mergesort(a,mid+<span class="number">1</span>,end);</span><br><span class="line">		merge(a,start,end,mid);<span class="comment">//归并数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*归并函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=start;</span><br><span class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end)<span class="comment">//两个数组pk比较大小，储存在b中</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">			b[k++]=a[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			b[k++]=a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == mid + <span class="number">1</span>)<span class="comment">//第二个数组剩余的多</span></span><br><span class="line">		<span class="keyword">while</span>(j &lt;= end)</span><br><span class="line">			b[k++]=a[j++];<span class="comment">//那么第二个数组直接排到后面</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(j == end + <span class="number">1</span>)<span class="comment">//第一个数组剩余的多</span></span><br><span class="line">		<span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">			b[k++]=a[i++];</span><br><span class="line">	<span class="keyword">for</span>(i=start,j=<span class="number">0</span>;j&lt;k;i++,j++)</span><br><span class="line">		a[i]=b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	mergesort(a,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>思想：</p>
<ul>
<li>找公共前后缀</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*KMP算法实现*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> string[] ,<span class="keyword">char</span> ch[] ,<span class="keyword">int</span> next[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> next[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j; </span><br><span class="line">	<span class="keyword">char</span> string[<span class="number">15</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">9</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> next[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	next[<span class="number">0</span>]=<span class="number">8</span>;</span><br><span class="line">	<span class="built_in">GetNext</span>(ch,next);</span><br><span class="line">	<span class="comment">//为啥调用完函数后,字符数组ch中的值会消失?</span></span><br><span class="line">	<span class="keyword">char</span> ch1[<span class="number">9</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//没找到解决办法，只好重新创建一个了~_~</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)<span class="comment">//打印出next数组中的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,next[i]);</span><br><span class="line">	j=<span class="built_in">kmp</span>(string,ch1,next);</span><br><span class="line">	<span class="keyword">if</span>(j)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;匹配成功,从第%d个开始\n&quot;</span>,j);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;匹配失败\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> next[])</span><span class="comment">//得到next数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">	next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=next[<span class="number">0</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">0</span>||ch[i]==ch[j])<span class="comment">//这里挺难理解的</span></span><br><span class="line">			next[++i]=++j;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j=next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> string[],<span class="keyword">char</span> ch[],<span class="keyword">int</span> next[])</span><span class="comment">//字符匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=<span class="number">14</span>&amp;&amp;j&lt;next[<span class="number">0</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">0</span>||string[i]==ch[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j == next[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">return</span> i-next[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法花了很长时间，主要浪费的时间不是在思考上，而是找 bug 上，程序没有报错，但是却输出不了正确的值，用笔一步一步推演发现并没有逻辑上的错误，一点点检查才发现,字符数组ch在调用完void Getnext()函数后里面的值竟然消失了，很奇怪，用的编译器是Microsoft visual c++6.0,到网上寻找也没找到答案，最终只好创建一个新的数组 —﹏—。</p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2.栈和队列</title>
    <url>/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>栈和队列是线性表的子集（是插入和删除位置受限的线性表）</strong></p>
<h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><blockquote>
<p>限定只能在表的一端进行插入和删除运算的线性表</p>
</blockquote>
<p>又称为后进先出(Last In First Out)的线性表，简称 <strong>LIFO</strong> 结构</p>
<span id="more"></span>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>栈是进行插入、删除操作的线性表。</p>
<p>表尾称为 <strong>栈顶</strong> Top；表头称为 <strong>栈底</strong> Base</p>
<p>插入元素到 <strong>栈顶</strong> 的操作称为 <strong>入栈</strong> PUSH</p>
<p>从 <strong>栈顶</strong> 删除最后一个元素的操作，称为 <strong>出栈</strong> POP</p>
<p>逻辑结构：一对一</p>
<p>存储结构：用 <strong>顺序栈</strong> 或 <strong>链栈</strong> 均可，顺序栈更常见</p>
<p>运算规则：只能在栈顶运算，且访问结点时依照LIFO原则</p>
<p>分类：</p>
<ul>
<li>静态栈</li>
<li>动态栈</li>
</ul>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>设 <strong>top</strong> 指针，指示栈顶元素在顺序栈中的位置</li>
<li>设 <strong>base</strong> 指针，指示栈底元素在顺序栈中的位置<br>为了方便操作，通常top指示真正的栈顶元素之上</li>
<li>用 <strong>stacksize</strong> 表示栈可使用的最大容量</li>
<li>空栈：base==top</li>
<li>栈满：top-base==stacksize</li>
</ul>
<h2 id="C语言实现链栈的相关操作"><a href="#C语言实现链栈的相关操作" class="headerlink" title="C语言实现链栈的相关操作"></a>C语言实现链栈的相关操作</h2><p>顺序栈也类似<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,* PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PNODE pTop;</span><br><span class="line">	PNODE pBottom;</span><br><span class="line">&#125;STACK,* PSTACK;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK,<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	STACK S;<span class="comment">//内存里面有了两个变量pTop,pBottom</span></span><br><span class="line"></span><br><span class="line">	init(&amp;S);<span class="comment">//造出一个空栈</span></span><br><span class="line">	push(&amp;S,<span class="number">1</span>);<span class="comment">//压栈</span></span><br><span class="line">	push(&amp;S,<span class="number">2</span>);</span><br><span class="line">	traverse(&amp;S);</span><br><span class="line">	clear(&amp;S);</span><br><span class="line">	<span class="comment">//traverse(&amp;S);</span></span><br><span class="line">	<span class="keyword">if</span>(pop(&amp;S, &amp;val))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈成功，出栈的元素是%d\n&quot;</span>,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(&amp;S);<span class="comment">//遍历输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (pS-&gt;pTop == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pS-&gt;pBottom = pS-&gt;pTop;</span><br><span class="line">		pS-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>;<span class="comment">//pS-&gt;pBottom-&gt;pNext = NULL; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pS,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	pNew-&gt;data = val;</span><br><span class="line">	pNew-&gt;pNext = pS-&gt;pTop;<span class="comment">//pS-&gt;pTop不能改成pS-&gt;pBottom</span></span><br><span class="line">	pS-&gt;pTop = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNODE p = pS-&gt;pTop;</span><br><span class="line">	<span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把pS所指向的栈出栈一次，并把出栈的元素存入pVal形参所指向的变量中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pS,<span class="keyword">int</span> * pVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE r =pS-&gt;pTop;</span><br><span class="line">		*pVal = r-&gt;data;</span><br><span class="line">		pS-&gt;pTop=r-&gt;pNext;</span><br><span class="line">		r = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE p = pS-&gt;pTop;	</span><br><span class="line">		<span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">		&#123;</span><br><span class="line">			pS-&gt;pTop = p-&gt;pNext;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">			p = pS-&gt;pTop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>进制转换</strong></p>
<p><strong>括号匹配</strong></p>
<p><strong>表达式求值：</strong></p>
<ul>
<li>表达式组成<ul>
<li>操作符(operand)：常数、变量</li>
<li>运算符(operator)：算术运算符、关系运算符和逻辑运算符</li>
<li>界限符(delimiter)：左右括弧和表达式结束符</li>
</ul>
</li>
<li>需要两个栈：<ul>
<li>算符栈OPTR，用于寄存运算符</li>
<li>操作数栈OPND,用于寄存运算数和运算结果</li>
</ul>
</li>
<li>求值的处理过程是自左向右扫描表达式的每一个字符<ul>
<li>当扫描的是数字，将其压入栈OPND</li>
<li>当扫描到的是运算符<ul>
<li>若这个运算符比OPTR栈顶运算符优先级高，则入栈OPTR</li>
<li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，将运算结果压入栈OPND</li>
</ul>
</li>
</ul>
</li>
<li>继续处理当前字符，直到结束符为止</li>
</ul>
<h1 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h1><blockquote>
<p>只能在表头的一端进行插入运算，在表的另一端进行删除运算的线性表</p>
</blockquote>
<p>队列是一种 <strong>先进先出</strong>(First In First Out—<strong>FLFO</strong>)的线性表。在表一段插入（表尾），在另一端（表头）删除</p>
<h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><p>逻辑结构：一对一</p>
<p>存储结构：<strong>顺序队</strong> 或 <strong>链队</strong>，以循环顺序队列更常见</p>
<p>运算规则：只能在队首和队尾运算，且访问结点时依照FIFO的原则</p>
<p>分类：</p>
<ul>
<li><p>链式队列：用链表实现</p>
</li>
<li><p>静态队列：用数组实现</p>
<ul>
<li>静态队列通常都必须是循环队列</li>
</ul>
</li>
</ul>
<p>循环队列：</p>
<ol>
<li>静态队列为什么必须是循环队列</li>
<li>循环队列需要几个参数来确定</li>
<li>循环队列各个参数的含义</li>
<li>循环队列入队伪算法</li>
<li>循环队列出队伪算法</li>
<li>如何判断循环队列是否为空</li>
<li>如何判断循环队列是否已满</li>
</ol>
<h2 id="队列顺序表示和实现"><a href="#队列顺序表示和实现" class="headerlink" title="队列顺序表示和实现"></a>队列顺序表示和实现</h2><p>设立一个队首指针front,一个队尾指针rear，分别指向队首和队尾元素</p>
<ul>
<li>初始化：front=rear=0</li>
<li>入队：将新元素插入rear所指的位置，然后rear加1</li>
<li>出队：删去front所指的元素，然后加1并返回被删元素</li>
<li>队列为空：front == rear</li>
<li>队满：rear == MAX_QUEUE_SIZE-1或front==rear</li>
</ul>
<p>在非空队列里，队首指针始终指向队头元素，而队尾指针始终指向队尾元素的下一位置。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>1.顺序队列中存在 <strong>“假溢出”</strong> 现象。</p>
<p><strong>假溢出:</strong> 尾指针已超出向量空间的上界而不能做入队操作</p>
<p><strong>解决方法</strong>：引入循环队列<br>C呈现<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span> == MAX_QUEUE_SIZE)</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	i++;</span><br></pre></td></tr></table></figure><br><strong>用模运算可简化为</strong>：i=(i+1) % MAX_QUEUE_SIZE;</p>
<p>2.队空和队满时头尾指针均相等，<strong>无法通过front=rear来判断队列”空”，还是”满”</strong>。</p>
<p><strong>解决方法</strong>:</p>
<ul>
<li>1.另外 <strong>设一个标志tag</strong> 以区别队空、队满（如队满为1，队空为0）</li>
<li>2.另外设一个变量，记录元素个数</li>
<li>3.<strong>少用一个元素空间</strong><ul>
<li>队空：front==rear</li>
<li>队满：(rear+1)%MAX_QUEUE_SIZE==font<br><img src="/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/queue1.png"></li>
</ul>
</li>
</ul>
<h2 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h2><ul>
<li>队列初始化：分配空间，头尾指针置为0</li>
<li><strong>队列长度</strong>：(reat-front+MAX_QUEUE_SIZE)%MAX_QUEUE_SIZE</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2.矩阵</title>
    <url>/2021/06/18/2.%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>如果A和B都是m$\times$n矩阵，称A和B是 <strong>同型矩阵</strong></p>
<h2 id="几类特殊的矩阵"><a href="#几类特殊的矩阵" class="headerlink" title="几类特殊的矩阵"></a>几类特殊的矩阵</h2><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>$<br>\quad\begin{pmatrix}<br>    {\large a}_{11}    \\<br>     &amp; {\large a}_{22}\\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; {\large a}_{nn}<br>\end{pmatrix}^{\large n}<br>$</p>
<p>$=<br>\begin{pmatrix}<br>    {\large a}_{11}^n    \\<br>     &amp; {\large a}_{22}^n\\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; {\large a}_{nn}^n<br>\end{pmatrix}<br>$<br><br><br><br>$<br>\qquad\begin{pmatrix}<br>    {\large k}    \\<br>     &amp; {\large k}\\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; {\large k}<br>\end{pmatrix}$</p>
<p>$=\large k<br>\begin{pmatrix}<br>    1    \\<br>     &amp; 1 \\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; 1<br>\end{pmatrix}<br>$</p>
<h3 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h3><blockquote>
<p>单位矩阵经 <strong>一次初等变换</strong> 所得到的矩阵</p>
</blockquote>
<p>可以是行变换,也可以是列变换</p>
<p>左乘是行变换，右乘是列变换</p>
<ol>
<li>互换两行两列的位置：<br>$E(i,j)$表示交换第$i$行(列)和第$j$行(列)<br><br></li>
<li>以数$k\neq0$乘某行或某列：<br>$E(i(k))$表示第$i$行(列)乘$k$<br><br></li>
<li>以数$k$乘某行(列)加到另一行(列)上去：<br>$E(i,j(k))$表示$j$行(列)乘$k$加到$i$行(列)</li>
</ol>
<p><strong>等价矩阵：</strong></p>
<blockquote>
<p>矩阵A经过有限次初等变换变成矩阵B，记作A$\cong$B</p>
</blockquote>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><blockquote>
<p>满足$A^T=A$</p>
</blockquote>
<h3 id="反对称矩阵"><a href="#反对称矩阵" class="headerlink" title="反对称矩阵"></a>反对称矩阵</h3><blockquote>
<p>满足$A^T=-A$</p>
</blockquote>
<h3 id="幂零矩阵"><a href="#幂零矩阵" class="headerlink" title="幂零矩阵"></a>幂零矩阵</h3><blockquote>
<p>对方阵$A$,如果存在正整数m，使得$A^m=0$,则称$A$为幂零矩阵</p>
</blockquote>
<h3 id="幂等矩阵"><a href="#幂等矩阵" class="headerlink" title="幂等矩阵"></a>幂等矩阵</h3><blockquote>
<p>满足$A^2=A$</p>
</blockquote>
<h3 id="对合矩阵"><a href="#对合矩阵" class="headerlink" title="对合矩阵"></a>对合矩阵</h3><blockquote>
<p>满足$A^2=E$</p>
</blockquote>
<h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><p>令$A=[{\large a}_{ij}]_{m\times s},B=[{\large b}_{ij}]_{s\times n}$<br><br>$AB=C=[{\large c}_{ij}]_{m\times n}$<br><br>${\large c}_{ij}={\large\sum\limits_{k=1}^s}{\large a}_{ik}{\large b}_{kj}$</p>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊:"></a>特殊:</h3><p>$\quad A=[{\large a}_{1j}]_{1\times s}$</p>
<p>$\quad A^T=[{\large a}_{j1}]_{s\times1}$</p>
<p>$\quad 则\;AA^T=\sum\limits_{j=1}^n{\large a}_j^2$</p>
<p>$\therefore\;$<strong>行在前列在后就是一个数</strong></p>
<h2 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h2><blockquote>
<p>$AB=BA=I$</p>
<ul>
<li>$<br>A=<br>\begin{pmatrix}<br>  {\large a}_{11}\\<br>  \\<br>   &amp; {\large a}_{22}\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp; {\large a}_{nn}<br>\end{pmatrix}<br>$<br>$<br>B=<br>\begin{pmatrix}<br>   \displaystyle\frac{1}{ {\large a}_{11} }\\<br>   &amp; \displaystyle\frac{1}{ {\large a}_{22} }\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp;\displaystyle\frac{1}{ {\large a}_{nn} }<br>\end{pmatrix}<br>$<br><br><br>$<br>\because<br>\begin{pmatrix}<br>  {\large a}_{11}\\<br>  \\<br>   &amp; {\large a}_{22}\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp; {\large a}_{nn}<br>\end{pmatrix}<br>\begin{pmatrix}<br>  {\large b}_{11}\\<br>  \\<br>   &amp; {\large b}_{22}\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp; {\large b}_{nn}<br>\end{pmatrix}<br>$<br><br><br>$<br>=\begin{pmatrix}<br>  {\large a}_{11}{\large b}_{11} \\<br>  \\<br>   &amp; {\large a}_{22}{\large b}_{22}\\<br>   \\<br>   &amp;     &amp; \ddots\\<br>   \\<br>   &amp;     &amp;     &amp; {\large a}_{nn}{\large b}_{nn}<br>\end{pmatrix}<br>$</li>
</ul>
</blockquote>
<p>$\therefore AB=BA=I$<br><br>$\therefore A^{-1}=B$<br><br>一些可逆矩阵的证明要想到从定义的角度出发</p>
<hr>
<p>$AA^{ * } =A^{ * }A=|A|I$</p>
<p>推论：</p>
<ol>
<li>$A^{-1}=\displaystyle{ \frac{A^*}{|A|} }\longrightarrow即\;|A|\not=0,\;A^{-1}存在$</li>
</ol>
<p>$\therefore$求逆矩阵先 <strong>看行列式是否为零</strong></p>
<ol>
<li>伴随矩阵$A^{ * }$的一些常用结论 <ul>
<li>$|A^*|=|A|^{n-1}$</li>
<li>$(A^{ * })^{ * }=|A|^{n-2}A$</li>
<li>若$A$可逆，且$A^{ * }$可逆,$(A^{ * })^{-1}=(A^{-1})^{ * }=\displaystyle\frac{1}{|A|}A$</li>
<li>$(AB)^{ * }=B^{ * }A^{ * }$</li>
<li>$(A^{ * })^T=(A^T)^{ * }$</li>
</ul>
</li>
<li><strong>A如果可逆，那么A一定可以表示为有限个初等矩阵的乘积</strong></li>
</ol>
<p>$P_t\cdots P_2P_1A=I$</p>
<p><br></p>
<p>$\because P_t\cdots P_2P_1A=I$</p>
<p>$\therefore A^{-1}=P_t\cdots P_2\;P_1$</p>
<p>$\;P_t\cdots P_2\;P_1\;I=A^{-1}$<br><br><br>$P_t\cdots P_2\;P_1\;A=I$<br><br>$P_t\cdots P_2\;P_1\;I=A^{-1}$</p>
<p>由这两个式子可得：</p>
<p>A经过行初等变换变成$I$</p>
<p>$I$就经过同样的行初等变换变成$A^{-1}$</p>
<p>$<br>\therefore[A\;|\;I\,]\rightarrow\cdots\rightarrow[\,I\;|\;A^{-1}]<br>$<br><br>或者可以这么理解<br>$A^{-1}[A|I]=[I|A^{-1}]$<br><br>用分块矩阵的思想，这样理解更加直观,其实这样求解的原因<br>就是$A$和$I$可以经过相同的变换变成$I$和$A^{-1}$</p>
<p><strong>推广</strong></p>
<p>$AX=B$<br>如果A可逆，$X=A^{-1}B$</p>
<p>令$P=A^{-1}$</p>
<p>由</p>
<p>$\;PA=I$<br><br>$PB=X$</p>
<p>有$\;[A|B]=[I|X]$</p>
<p>即$\;$遇到$A^{-1}B$时，可以将$A，B$拼在一起将$A$化成单位矩阵就是所求的$X$</p>
<h2 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h2><h3 id="分成四块"><a href="#分成四块" class="headerlink" title="分成四块"></a>分成四块</h3><p>$<br>\left(\begin{array}{cc|ccc}<br>     1 &amp; 2 &amp; 0 &amp; 0 &amp; 0\\<br>     3 &amp; 4 &amp; 0 &amp; 0 &amp; 0\\<br>     \hline<br>     0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\<br>     0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\<br>     0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\<br>\end{array}\right)=<br>\left(\begin{array}{cc}<br>     A &amp; O\\<br>     O &amp; B<br>\end{array}\right)<br>$</p>
<p>分块后的矩阵满足四个区域整体满足</p>
<p>矩阵的加法</p>
<p>对角矩阵的乘法</p>
<p>逆矩阵</p>
<h3 id="按行分块"><a href="#按行分块" class="headerlink" title="按行分块"></a>按行分块</h3><ul>
<li>$<br>\left(\begin{array}{ccc}<br>a_{11}&amp;a_{12}&amp;a_{13}\\<br>\hdashline<br>a_{21}&amp;a_{22}&amp;a_{23}\\<br>\hdashline<br>a_{31}&amp;a_{32}&amp;a_{33}<br>\end{array}\right)<br>=\begin{bmatrix}<br>\alpha_1^T\\<br>\alpha_2^T\\<br>\alpha_3^T<br>\end{bmatrix}<br>$<br><br>按行分块一般会加转置符号，主要原因时默认$\alpha$是列向量<h3 id="按列分块"><a href="#按列分块" class="headerlink" title="按列分块"></a>按列分块</h3>类比按行分块<br><br>一般证明的时候会选择按列分块</li>
</ul>
<h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><blockquote>
<p>秩与线性方程组的解有着密切的联系，所以要将线性方程组和秩结合起来，<br>而这样就容易理解后面的n元向量的一些秩的表示形式</p>
</blockquote>
<ul>
<li>矩阵A的一个k阶子式:<br><br>$\qquad$矩阵A中随便找k行随便找k列，按原来次序排列构成的行列式</li>
</ul>
<h3 id="秩的性质"><a href="#秩的性质" class="headerlink" title="秩的性质"></a>秩的性质</h3><ol>
<li>$0\leqslant r(A_{m\times n})\leqslant min(m,n)$<br><br><br></li>
<li>$r(A^T)=r(A)$<br><br><br></li>
<li>$r(A+B)\leqslant r(A)+r(B)$<br><br><br></li>
<li>$r(kA)=r(A)(k\neq0)\;\leftarrow\; r(A)=r(-A)，r(A-E)=r(E-A)$<br><br><br></li>
<li><p>$r(AB)\leqslant min(r(A),r(B))$<br><br><br></p>
</li>
<li><p>如P.Q可逆，则<br>$r(PAQ)=r(A)$<br><br><br></p>
</li>
<li>$\;r\left[\begin{array}{cc} A&amp;O\\O&amp;B\end{array}\right]=r(A)+r(B)$<br><br><br></li>
<li>$max(r(A),r(B))\leqslant r(A，B)\leqslant r(A+B)\leqslant r(A)+r(B)$<br><br>$r(A+B)\leqslant r(A)+r(B)$的证明(三秩相等)<br><br>$<br>\begin{aligned}<br>&amp;设r(A)=r,极大线性无关组：\alpha_{i1}\alpha_{i2}\cdots\alpha_{ir}\\<br>&amp;\quad r(B)=t,极大线性无关组：\beta_{j1}\beta_{j2}\cdots\beta_{jt}\\<br>&amp;A+B=(\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n)\\<br>\end{aligned}<br>$<br><br><br>$<br>\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n可由\alpha_{i1},\cdots,\alpha_{ir},\beta_{j1},\cdots,\beta_{jt}线性表示$<br><br>$则r(\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n)\leqslant r(\alpha_{i1},\cdots,\alpha_{ir},\beta_{j1},\cdots,\beta_{jt})\rightarrow在向量组线性表示里$<br><br><br>$<br>\begin{aligned}<br>\therefore r(A+B)&amp;=r(\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n)\\<br>\\<br>&amp;\leqslant r(\alpha_{i1},\cdots,\alpha_{ir},\beta_{j1},\cdots,\beta_{jt})\leqslant r+t=r(A)+r(B)<br>\end{aligned}<br>$</li>
</ol>
<p>当然理解起来很好理解，因为假设r(A)=m,r(B)=n,r(A+B)的秩必定小于m+n</p>
<h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><p>前提$AB=BA$,<br>那么$(A+B)^n=\sum\limits_{i=0}^nC_n^iA^iB^{n-i}$</p>
<p>矩阵跟线性变换有着紧密的联系，左乘对应行变换，右乘对应列变换，而后面会继续深入学习矩阵的几何意义……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>3.numpy的数据类型</title>
    <url>/2021/07/03/3-numpy%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><strong>因为在numpy中有许多的数据类型，所以今天就来着重梳理一下numpy中的数据类型及其应用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="numpy的数据类型和C的对比"><a href="#numpy的数据类型和C的对比" class="headerlink" title="numpy的数据类型和C的对比"></a>numpy的数据类型和C的对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">numpy的类型</th>
<th style="text-align:left">C的类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">np.bool</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">布尔值(True or False)</td>
</tr>
<tr>
<td style="text-align:left">np.byte</td>
<td style="text-align:left">signed char</td>
<td style="text-align:left">精度平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.ubyte</td>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.short</td>
<td style="text-align:left">short</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.ushort</td>
<td style="text-align:left">unsigned short</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.intc</td>
<td style="text-align:left">int</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.uintc</td>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.int_</td>
<td style="text-align:left">long</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.unint</td>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.longlong</td>
<td style="text-align:left">longlong</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.ulonglong</td>
<td style="text-align:left">unsigned longlong</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.half / np.float16</td>
<td style="text-align:left"></td>
<td style="text-align:left">半精度浮点数：符号位，5位指数，10位尾数</td>
</tr>
<tr>
<td style="text-align:left">np.single</td>
<td style="text-align:left">float</td>
<td style="text-align:left">平台定义的单精度浮点数：通常为1位符号位，8位指数，23位尾数</td>
</tr>
<tr>
<td style="text-align:left">np.double</td>
<td style="text-align:left">double</td>
<td style="text-align:left">平台定义的双精度浮点数：通常为符1位号位，11位指数，52位尾数</td>
</tr>
<tr>
<td style="text-align:left">np.longdouble</td>
<td style="text-align:left">long double</td>
<td style="text-align:left">平台定义的扩展精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">np.csingle</td>
<td style="text-align:left">float complex</td>
<td style="text-align:left">复数，由两个单精度浮点数（实部和虚部）表示</td>
</tr>
<tr>
<td style="text-align:left">np.cdouble</td>
<td style="text-align:left">double complex</td>
<td style="text-align:left">复数，由两个双精度浮点数（实部和虚部）表示</td>
</tr>
<tr>
<td style="text-align:left">np.clongdouble</td>
<td style="text-align:left">long double complex</td>
<td style="text-align:left">复数，由两个扩展精度浮点数（实部和虚部）表示</td>
</tr>
</tbody>
</table>
</div>
<h2 id="numpy中的一组固定大小的别名"><a href="#numpy中的一组固定大小的别名" class="headerlink" title="numpy中的一组固定大小的别名"></a>numpy中的一组固定大小的别名</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">numpy类型</th>
<th style="text-align:left">C的类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">np.int8</td>
<td style="text-align:left">int8_t</td>
<td style="text-align:left">字节(-128—127)</td>
</tr>
<tr>
<td style="text-align:left">np.int16</td>
<td style="text-align:left">int16_t</td>
<td style="text-align:left">整数(-32768—32767)</td>
</tr>
<tr>
<td style="text-align:left">np.int64</td>
<td style="text-align:left">int64_t</td>
<td style="text-align:left">整数($-2^{63}—2^{63}-1$)</td>
</tr>
<tr>
<td style="text-align:left">np.uint8</td>
<td style="text-align:left">uint8_t</td>
<td style="text-align:left">无符号整数(0—255)</td>
</tr>
<tr>
<td style="text-align:left">np.uint16</td>
<td style="text-align:left">uint16_t</td>
<td style="text-align:left">无符号整数(0—65535)</td>
</tr>
<tr>
<td style="text-align:left">np.uint32</td>
<td style="text-align:left">uint32</td>
<td style="text-align:left">无符号整数(0—$2^{32}$)</td>
</tr>
<tr>
<td style="text-align:left">np.uint64</td>
<td style="text-align:left">uint64</td>
<td style="text-align:left">无符号整数(0—$2^{64}$)</td>
</tr>
<tr>
<td style="text-align:left">np.intp</td>
<td style="text-align:left">intptr_t</td>
<td style="text-align:left">用于索引的整数，通常与索引相同ssize_t</td>
</tr>
<tr>
<td style="text-align:left">np.uintp</td>
<td style="text-align:left">uintptr_t</td>
<td style="text-align:left">整数大到足以容纳指针</td>
</tr>
<tr>
<td style="text-align:left">np.float32</td>
<td style="text-align:left">float</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">np.float64/np.float_</td>
<td style="text-align:left">double</td>
<td style="text-align:left">这与内置python float的精度相匹配</td>
</tr>
<tr>
<td style="text-align:left">np.complex64</td>
<td style="text-align:left">float complex</td>
<td style="text-align:left">复数,由两个32位浮点数(实数和虚数)表示</td>
</tr>
<tr>
<td style="text-align:left">np.complex128/np.complex_</td>
<td style="text-align:left">double complex</td>
<td style="text-align:left">注意，这与内置python复合体的精度相匹配</td>
</tr>
</tbody>
</table>
</div>
<p>numpy数据类型是dtype(数据类型)对象的实例</p>
<h2 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.power(<span class="number">100</span>,<span class="number">8</span>,dtype=np.int64)</span><br></pre></td></tr></table></figure>
<pre><code>10000000000000000
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.power(<span class="number">100</span>,<span class="number">8</span>,dtype=np.int32)<span class="comment">#应该输出的是10000000000000000</span></span><br></pre></td></tr></table></figure>
<pre><code>1874919424
</code></pre><h2 id="np-iinfo和np-finfo"><a href="#np-iinfo和np-finfo" class="headerlink" title="np.iinfo和np.finfo"></a>np.iinfo和np.finfo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.iinfo(np.int32)</span><br></pre></td></tr></table></figure>
<pre><code>iinfo(min=-2147483648, max=2147483647, dtype=int32)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.finfo(np.float_)</span><br></pre></td></tr></table></figure>
<pre><code>finfo(resolution=1e-15, min=-1.7976931348623157e+308, max=1.7976931348623157e+308, dtype=float64)
</code></pre>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>3.CSS的背景</title>
    <url>/2021/07/20/3-CSS%E7%9A%84%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS-的背景"><a href="#CSS-的背景" class="headerlink" title="CSS 的背景"></a>CSS 的背景</h1><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><p><strong>background-color</strong> 属性定义了元素的背景颜色<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: 颜色值;</span><br></pre></td></tr></table></figure><br>一般情况下元素背景颜色默认值是 <strong>transparent(透明)</strong>，我们也可以手动指定背景颜色为透明色。</p>
<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p><strong>background-image</strong> 属性描述了元素的背景图像，实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片，优点是便于控制位置<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">绝对或相对位置</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h2><p>如果需要在HTML页面上对背景图像进行平铺，可以使用 <strong>background-repeat</strong> 属性<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-repeat</span>: repeat | no-repeat | repeat-x | repeat-y </span><br></pre></td></tr></table></figure></p>
<h2 id="背景图片位置"><a href="#背景图片位置" class="headerlink" title="背景图片位置"></a>背景图片位置</h2><p>利用 <strong>bcakground-positon</strong> 属性可以改变图片在背景中的位置。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: x y;</span><br></pre></td></tr></table></figure><br>参数代表的意思是：x坐标和y坐标，可以使用方位名词或者精确单位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:left">百分数 / 由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">方位名词：<br>top / center / bottom <br>left / center / right </td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.参数是方位名词</strong></p>
<ul>
<li>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top和top left 效果一样</li>
<li>如果指定了一个方位名词，另一个省略，则第二个值默认居中对齐</li>
</ul>
<p><strong>2.参数是精确单位</strong></p>
<ul>
<li>如果参数值是精确坐标，那么第一个肯定是x坐标，第二个肯定是y坐标</li>
<li>如果只指定一个数值，那该数值一定是x坐标，另一个默认垂直居中</li>
</ul>
<p><strong>3.参数是混合单位</strong></p>
<ul>
<li>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
<h2 id="背景图像固定（背景附着）"><a href="#背景图像固定（背景附着）" class="headerlink" title="背景图像固定（背景附着）"></a>背景图像固定（背景附着）</h2><p><strong>background-attachment</strong> 属性设置背景图像是否固定或者随着页面的其余部分滚动。</p>
<p>background-attachment后期可以制作时差滚动效果<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-attachment</span>: <span class="built_in">fixed</span>(固定) | <span class="built_in">scroll</span>(滚动) </span><br></pre></td></tr></table></figure></p>
<h2 id="背景复合写法"><a href="#背景复合写法" class="headerlink" title="背景复合写法"></a>背景复合写法</h2><p>我们可以将这些属性合并写在同一个属性background中，约定的顺序为：</p>
<p>background:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;</p>
<h2 id="背景色半透明"><a href="#背景色半透明" class="headerlink" title="背景色半透明"></a>背景色半透明</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>rgba也就是red、green、blue、alpha</strong></p>
<ul>
<li>最后一个参数是 <strong>alpha</strong> 透明度，取值范围0~1之间</li>
<li><strong>习惯上把0.3的0省略</strong>，写为background: rgba(0,0,0,.3);</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">background-color</td>
<td style="text-align:left">背景颜色</td>
<td style="text-align:left">预定义颜色值、十六进制、RGB代码</td>
</tr>
<tr>
<td style="text-align:left">background-image</td>
<td style="text-align:left">背景图片</td>
<td style="text-align:left">url(图片路径)</td>
</tr>
<tr>
<td style="text-align:left">background-repeat</td>
<td style="text-align:left">是否平铺</td>
<td style="text-align:left">repeat / no-repeat / repeat-x / repeat-y</td>
</tr>
<tr>
<td style="text-align:left">background-position</td>
<td style="text-align:left">背景位置</td>
<td style="text-align:left">length / positon 分别是x和y坐标</td>
</tr>
<tr>
<td style="text-align:left">background-attachment</td>
<td style="text-align:left">背景附着</td>
<td style="text-align:left">scroll(滚动) / fixed(固定)</td>
</tr>
<tr>
<td style="text-align:left">背景简写</td>
<td style="text-align:left">减少代码量</td>
<td style="text-align:left">background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</td>
</tr>
<tr>
<td style="text-align:left">背景色半透明</td>
<td style="text-align:left">背景颜色半透明</td>
<td style="text-align:left">background:(0,0,0,.3); 后面必须是4个值</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>3.树和森林</title>
    <url>/2021/07/28/3-%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树是n（n&geqslant;0）个结点的有限集.</p>
<ul>
<li>n=0，空树</li>
<li>n&gt;0，则满足以下条件<ul>
<li><strong>有且仅有一个</strong> 特定的称为 <strong>根</strong> 的结点</li>
<li>其余节点可分为m（m&geqslant;0）个互不相交的有限集T1，T2，T3……，Tm，其中每一个集合本身又是一棵树，并称为根的 <strong>子树</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p><strong>根节点</strong>：非空树中无前驱结点的结点</p>
<p><strong>结点的度</strong>：结点拥有的子树数</p>
<p><strong>树的度</strong>：树内各结点的度的最大值</p>
<p><strong>度=0</strong> —&gt; 称为 <strong>叶子结点</strong>（终端结点）</p>
<p><strong>度≠0</strong> —&gt; 称为 <strong>分支结点</strong>（非终端节点）</p>
<p>根节点以外的分支结点称为 <strong>内部节点</strong></p>
<p>结点的子树的根称为该结点的 <strong>孩子</strong>，该结点称为孩子的 <strong>双亲</strong></p>
<p><strong>兄弟</strong>：深度相同，双亲结点相同</p>
<p><strong>堂兄弟</strong>：深度相同，双亲结点不同</p>
<p>结点的 <strong>祖先</strong>：从根到该结点所经分支上的所有结点</p>
<p>结点的 <strong>子孙</strong>：以某结点为根的子树中的任一结点</p>
<p><strong>树的深度</strong>：树中结点的最大层次</p>
<p><strong>有序树</strong>：树中结点的各子树从左至右有次序</p>
<p><strong>无序树</strong>：树中结点的各子树无次序</p>
<p><strong>森林</strong>：是m（m&geqslant;0）棵互不相交的树的集合</p>
<h1 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>二叉树是n（n&geqslant;0）个结点的有限集.或是空集，或是一个根节点和两棵不相交的分别称作这个根的左子树和右子树的二叉树组成</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>每个结点最多有两个孩子（二叉树中不存在度大于2的结点）</li>
<li>子树有左右之分，其次序不能颠倒</li>
<li>二叉树可以是空集合，根可以有空的左子树或空的右子树</li>
</ol>
<p><strong>注意</strong>：二叉树 <strong>不是</strong> 树的特殊情况，它们是两个概念</p>
<p><strong>二叉树</strong> 结点的子树要 <strong>区分左子树和右子树</strong>，即使只有一棵子树也要区分，说明它是左子树，还是右子树</p>
<p><strong>树</strong> 当节点只有一个孩子时，就 <strong>无需区分</strong> 它是左还是右的次序，因此二者是不同的。这是二叉树与树的最主要差别</p>
<h2 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT BinaryTree&#123;</span><br><span class="line">    数据对象D:  D是具有相同特性的数据元素的集合。</span><br><span class="line">    数据关系R:  若D=Φ,则R=Φ;</span><br><span class="line">                若D≠Φ,则R=&#123;H&#125;;H是如下二元关系:</span><br><span class="line">                <span class="number">1.</span>root唯一      <span class="comment">//关于根的说明</span></span><br><span class="line">                <span class="number">2.</span>D_j∩D_k=Φ     <span class="comment">//关于子树不相交的说明</span></span><br><span class="line">                <span class="number">3.</span>……            <span class="comment">//关于数据元素的说明</span></span><br><span class="line">                <span class="number">4.</span>……            <span class="comment">//关于左子树和右子树的说明</span></span><br><span class="line">    基本操作P</span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><blockquote>
<p>所有的结点都在，即深度为k且右 $2^k-1$ 个结点的二叉树称为满二叉树</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的 <strong>满二叉树</strong> 中 <strong>编号</strong> 为1~n的结点 <strong>一一对应</strong> 时，称之为完全二叉树。</p>
</blockquote>
<p><strong>注：</strong> 满二叉树中，最后一个结点开始，<strong>连续</strong> 去掉 <strong>任意</strong> 个结点，即是一棵完全二叉树</p>
<p><strong>满二叉树一定是完全二叉树</strong></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.具有n个节点的完全二叉树深度为 $\lfloor \log_2n \rfloor +1$</p>
<p>注：$\lfloor x \rfloor$：称作x的底，表示不大于x的最大整数</p>
<p>2.如果对对一棵有n个结点的完全二叉树，结点按层序编号，则对 <strong>任一结点i</strong>(i&leqslant;i&leqslant;n),有：</p>
<ul>
<li>如果i = 1，则结点i是二叉树的根，无双亲；如果 i&gt;1 ，则其双亲是 <strong>结点 $\lfloor i/2 \rfloor$</strong></li>
<li>如果2i &gt; n，则结点i为叶子结点，无左孩子；否则，其 <strong>左孩子是结点 2i</strong></li>
<li>如果2i+1 &gt; n，则结点i无右孩子；否则，其 <strong>右孩子是结点 2i+1</strong> </li>
</ul>
<h2 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h2><p>实现：按 <strong>满二叉树</strong> 的结点层次编号，依次存放二叉树中的数据元素<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTSIZE 100</span></span><br><span class="line">Typedef TElemTye SqBiTree[MAXTSIZE]</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>:<br>会浪费空间，所以适合 <strong>满二叉树</strong> 和 <strong>完全二叉树</strong></p>
<h2 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h2><p><strong>二叉链表</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<p>n个结点的二叉链表中有，<strong>n+1</strong> 个空指针域</p>
<ul>
<li>因为每个非空指针域都存放着一个结点</li>
</ul>
<p><strong>三叉链表</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>&#123;</span></span><br><span class="line">    TelemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>*<span class="title">parent</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="comment">//比二叉节点多了一个双亲指针</span></span><br><span class="line">&#125;TriTNode,*TriTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p><strong>方法</strong><br>假设：L：遍历左子树，D：访问根结点，R：遍历右子树</p>
<p>遍历方案共有六种：DLR、LDR、LRD、DRL、RLD</p>
<p>若规定 <strong>先左后右</strong>，则只有前三种情况：</p>
<ul>
<li><strong>DLR</strong>——先序（根）遍历</li>
<li><strong>LDR</strong>——中序（根）遍历</li>
<li><strong>LRD</strong>——后序（根）遍历</li>
</ul>
<p><strong>先序遍历递归算法</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre</span><span class="params">(BiTree *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;data);</span><br><span class="line">        pre(T-&gt;lchild);</span><br><span class="line">        pre(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>中序遍历非递归算法</strong><br>算法设计思路：使用栈<br><strong>二叉树的层次遍历</strong><br>算法设计思路：使用一个队列</p>
<ul>
<li>将根节点进队;</li>
<li>队不空时循环：从队列中出列一个结点*p，访问它；<ul>
<li>若它有左孩子结点，将左孩子结点进队；</li>
<li>若它有右孩子结点，将右孩子结点进队。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">    BTNode *p; SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(qu,b);<span class="comment">//根结点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu))&#123;<span class="comment">//队不为空，则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出队结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//访问结点p</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">            enQueue(qu,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">            enQueue(qu,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h2><ul>
<li>若二叉树中各结点的值均不相同，则二叉树的结点的先序序列，中序序列，后序序列都是唯一的</li>
<li>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树</li>
</ul>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><p>C语言描述<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTree,*pBiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">pBiTree <span class="title">Create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(pBiTree )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pBiTree p=<span class="literal">NULL</span>;</span><br><span class="line">	p=Create();</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建成功\n&quot;</span>);</span><br><span class="line">	traverse(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;遍历成功\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pBiTree <span class="title">Create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	pBiTree T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		T=(pBiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">		T-&gt;data = ch;</span><br><span class="line">		T-&gt;lchild=Create();<span class="comment">//递归</span></span><br><span class="line">		T-&gt;rchild=Create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(pBiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,T-&gt;data);</span><br><span class="line">		traverse(T-&gt;lchild);</span><br><span class="line">		traverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线索二叉树-Threaded-Binary-Tree"><a href="#线索二叉树-Threaded-Binary-Tree" class="headerlink" title="线索二叉树(Threaded Binary Tree)"></a>线索二叉树(Threaded Binary Tree)</h2><p>问题：如何寻找特定遍历序列中二叉树结点的前驱和后继</p>
<p>解决方法：</p>
<ol>
<li>通过遍历寻找—-费时间</li>
<li>再增设前驱、后继指针域—-增加存储负担</li>
<li><p><strong>利用二叉链表中的空指针域</strong></p>
<ul>
<li>如果某个结点的左孩子为空，则将空的左孩子指针域改为 <strong>指向其前驱</strong>；如果某结点的右孩子为空，则将空的右孩子指针域改为 <strong>指向其后继</strong>——这种改变指向的指针称为“线索”</li>
</ul>
<p>为区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：</p>
<ul>
<li>l(r)tag = 0 l(r)child指向该结点的左（右）孩子</li>
<li>l(r)tag = 1 l(r)child指向该结点的前驱（后继）</li>
</ul>
<p><strong>增设了一个头结点</strong>以中序遍历为例）：</p>
<ul>
<li>ltag=0,lchild指向根结点，</li>
<li>rtag=1,rchild指向遍历序列中最后一个结点</li>
<li>遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点</li>
</ul>
</li>
</ol>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>实现：</p>
<ul>
<li>定义结构数组存放树的结点，每个结点含两个域<ul>
<li>数据域：存放结点本身信息</li>
<li>双亲域：指示本结点的双亲结点在数组中的位置</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//树的结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r,n;    <span class="comment">//根结点位置和结点个数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure>
<h2 id="双亲表示法-1"><a href="#双亲表示法-1" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储</p>
<p><strong>特点</strong><br>找孩子容易，找双亲难</p>
<p><strong>孩子结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*childPtr;</span><br></pre></td></tr></table></figure></p>
<p><strong>双亲结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CTbox;</span><br></pre></td></tr></table></figure></p>
<p><strong>树结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;    <span class="comment">//结点数和根结点的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉链表表示法"><a href="#二叉链表表示法" class="headerlink" title="二叉链表表示法"></a>二叉链表表示法</h2><p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其 <strong>第一个孩子结点</strong> 和 <strong>下一个兄弟结点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<h1 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h1><ul>
<li>将树转换成二叉树进行处理，利用二叉树的算法实现对数的操作</li>
<li>由于树和二叉树都可以用二叉链表作存储结构，则 <strong>以二叉链表作媒介</strong> 可以导出树与二叉树之间的一个对应关系。</li>
</ul>
<p><strong>口诀：兄弟相连留长子</strong></p>
<h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><blockquote>
<p>森林是m(m&geqslant;0)棵互不相交的树的集合<br>森林—-&gt;树—-&gt;二叉树</p>
</blockquote>
<p>森林变二叉树：树变二叉根相连</p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><p><strong>1.树的遍历方式（三种）</strong></p>
<ul>
<li><strong>先根（次序）遍历</strong>：<ul>
<li>若树不空，则先访问根结点，然后依次先根遍历各课子树</li>
</ul>
</li>
<li><strong>后根（次序）遍历</strong>:<ul>
<li>若树不空，则先依次后根遍历各棵子树，然后访问根结点</li>
</ul>
</li>
<li><strong>按层次遍历</strong>：<ul>
<li>若树不空，则自上而下自左至右访问树中每个结点</li>
</ul>
</li>
</ul>
<p><strong>2.森林的遍历</strong><br>将森林看作由三部分构成：</p>
<ul>
<li>森林中第一棵树的根结点；</li>
<li>森林中第一棵树的子树森林</li>
<li><p>森林中其它树构成的森林</p>
</li>
<li><p><strong>先序遍历</strong></p>
<ul>
<li>若树不空，则</li>
<li><strong>访问森林中第一棵树的根结点</strong></li>
<li>先序遍历森林中第一棵树的子树森林</li>
<li>先序遍历森林中（除第一棵树外）其余树构成的森林<blockquote>
<p>即依次从左至右对森林中的每一棵树进行先根遍历</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>中序遍历</strong></p>
<ul>
<li>若树不空，则</li>
<li>中序遍历森林中第一棵树的子树森林</li>
<li>访问森林中第一棵树的根结点</li>
<li>中序遍历森林中（除第一棵树外）其余树构成的森林<blockquote>
<p>即依次从左到右对森林中的每一棵树进行后根遍历</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.<strong>路径</strong>：从树中一个结点到另一个结点之间的 <strong>分支</strong> 构成这两个结点间的路径</p>
<p>2.<strong>结点的路径长度</strong>：两个结点路径上的 <strong>分支数</strong></p>
<p>3.<strong>树的路径长度</strong>：从 <strong>树根</strong> 到每个结点的 <strong>路径长度之和</strong>。记作：TL</p>
<p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p>
<p>4.<strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权</p>
<p>5.<strong>结点的带权路径长度</strong>：从根结点到该结点之间的 <strong>路径长度</strong> 与该结点的 <strong>权</strong> 的 <strong>乘积</strong></p>
<p>6.<strong>树的带权路径长度</strong>：树中所有 <strong>叶子</strong> 结点的 <strong>带权路径长度之和</strong> 记WPL</p>
<h2 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h2><p><strong>哈夫曼算法</strong></p>
<ul>
<li>构造森林全是根</li>
<li>选用两小造新树</li>
<li>删除两小添新人</li>
<li>重复2、3剩单根</li>
</ul>
<p>哈夫曼树的结点的度数为0或2，没有度为1的结点</p>
<h2 id="哈夫曼树构造算法的实现"><a href="#哈夫曼树构造算法的实现" class="headerlink" title="哈夫曼树构造算法的实现"></a>哈夫曼树构造算法的实现</h2><p>采用顺序存储结构—-一维结构数组<br>节点类型定义<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent,lch,rch;</span><br><span class="line">&#125;HTNode,*HuffmanTree;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>初始化 <strong>HT[1……2n-1]</strong>; lch=rch=parent=0;</li>
<li>输入初始 <strong>n个叶子结点</strong>：置HT[1……n]的weight值;</li>
<li>进行以下 <strong>n-1次合并</strong>，依次产生n-1个结点HT[i],i=n+1……2n:<ul>
<li>在HT[1…i-1]中选两个 <strong>未被选过</strong>（从parent==0中选）的weight最小的两个结点HT[s1]和HT[s2]，s1、s2为两个最小结点下标</li>
<li>修改HT[s1]和HT[s2]的parent值：HT[s1].parent=i;HT[s2].parent=i;</li>
<li>修改产生的HT[i]：<ul>
<li>HT[i].weight=HT[s1].weight + HT[s2].weight;</li>
<li>HT[i].lch=s1;HT[i].rch=s2;</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHuffmanTree</span><span class="params">(HuffmanTree HT,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;    <span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT=<span class="keyword">new</span> HTNode[m+<span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//将2n-1个元素的lch、rch、parent置为0</span></span><br><span class="line">        HT[i].lch=<span class="number">0</span>;HT[i].rch=<span class="number">0</span>;HT[i].parent=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;HT[i]weight;<span class="comment">//输入前n个元素的weight值</span></span><br><span class="line">    <span class="comment">//初始化完成</span></span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//合并产生n-1个结点---构造Huffman树</span></span><br><span class="line">        Select(HT,i<span class="number">-1</span>,s1,s2);<span class="comment">//在HT[k](1 ≤ k ≤ i-1)中选择两个其双亲域为0</span></span><br><span class="line">        <span class="comment">//且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class="line">        HT[s1].parent=i; HT[s2].parent=i;<span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">        HT[i].lch=s1;HT[i].rch=s2;<span class="comment">//s1.s2分别作为i的左右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>标注时左分支为0，右分支为1</p>
<p>哈夫曼编码是前缀码</p>
<p>哈夫曼编码是最优前缀码</p>
<h3 id="哈夫曼编码的算法实现"><a href="#哈夫曼编码的算法实现" class="headerlink" title="哈夫曼编码的算法实现"></a>哈夫曼编码的算法实现</h3><p><strong>编码</strong></p>
<ul>
<li>将字符集C作为叶子节点；</li>
<li>将频率集W作为叶子节点的权值；</li>
<li>使用C和W构造哈夫曼树；</li>
<li>对哈夫曼树的所有分支，左子树分支编码为0，右子树分支编码为1；</li>
</ul>
<p><strong>解码</strong></p>
<ul>
<li>构造哈夫曼树</li>
<li>依次读入二进制码</li>
<li>读入0，则走向左孩子；读入1，则走向右孩子</li>
<li>一旦到达某叶子时，即可译出字符</li>
<li>然后再从根出发继续译码，直到结束</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3.方程组</title>
    <url>/2021/06/19/3.%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><h2 id="克莱姆法则"><a href="#克莱姆法则" class="headerlink" title="克莱姆法则"></a>克莱姆法则</h2><ul>
<li>形式<br>$\begin{cases}<br>{\large a}_{11}{\large x}_1+{\large a}_{12}{\large x}_2+\cdots+{\large a}_{1n}{\large x}_n={\large b}_1\\<br>{\large a}_{21}{\large x}_1+{\large a}_{22}{\large x}_2+\cdots+{\large a}_{2n}{\large x}_n={\large b}_2\qquad(1)\\<br>\qquad\cdots\cdots\\<br>{\large a}_{n1}{\large x}_1+{\large a}_{n2}{\large x}_2+\cdots+{\large a}_{nn}{\large x}_n={\large b}_b<br>\end{cases}<br>$<br><br>的系数行列式<br><br>$<br>D=\left|\begin{array}{ccc}<br> {\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1n}\\<br> {\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2n}\\<br> \vdots&amp;\vdots&amp;&amp;\vdots\\<br> {\large a}_{n1}&amp;{\large a}_{n2}&amp;\cdots&amp;{\large a}_{nn}<br>\end{array}\right|\not=0<br>$<br><br>则方程组有唯一解<br><br>$\displaystyle {\large x}_1=\frac{D_1}{D},{\large x}_2=\frac{D_2}{D},\cdots, {\large x}_n=\frac{D_n}{D}$<br><br>其中<br><br>$<br>D_j=\left|\begin{array}{ccc}<br>{\large a}_{11}&amp;\cdots&amp;{\large a}_{1 j-1}&amp;{\large b}_1&amp;{\large a}_{1 j+1}&amp;\cdots&amp;{\large a}_{1n}\\<br>{\large a}_{21}&amp;\cdots&amp;{\large a}_{2 j-1}&amp;{\large b}_2&amp;{\large a}_{2 j+1}&amp;\cdots&amp;{\large a}_{2n}\\<br>\vdots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>{\large a}_{n1}&amp;\cdots&amp;{\large a}_{n j-1}&amp;{\large b}_n&amp;{\large a}_{n j+1}&amp;\cdots&amp;{\large a}_{nn}<br>\end{array}\right|<br>$</li>
</ul>
<p>证明：<br>以后补充……<br>推论:</p>
<p>$<br>\begin{cases}<br>{\large a}_{11}{\large x}_1+{\large a}_{12}{\large x}_2+\cdots+{\large a}_{1n}{\large x}_n=0\\<br>{\large a}_{21}{\large x}_1+{\large a}_{22}{\large x}_2+\cdots+{\large a}_{2n}{\large x}_n=0\qquad(2)\\<br>\qquad\cdots\cdots\\<br>{\large a}_{n1}{\large x}_1+{\large a}_{n2}{\large x}_2+\cdots+{\large a}_{nn}{\large x}_n=0<br>\end{cases}<br>$<br><br><br>$|A|\not=0$,则方程只有零解</p>
<p>若齐次方程(2)有非零解,则$|A|=0$</p>
<h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><p>把矩阵化成行阶梯型</p>
<p>然后化成行最简型矩阵</p>
<p>矩阵的 <strong><u>行</u></strong> 初等变换其实就是对应的方程组的三种变换</p>
<h2 id="n元线性方程组-Ax-b"><a href="#n元线性方程组-Ax-b" class="headerlink" title="n元线性方程组$Ax=b$"></a>n元线性方程组$Ax=b$</h2><ol>
<li>无解<br>$\;\Longleftrightarrow\;r(A)+1=r(\overline{A})$<br><br></li>
<li>唯一解<br>$\;\Longleftrightarrow\;r(A)=r(\overline{A})=n\;\longrightarrow\;A是可逆矩阵\Leftrightarrow|A|\neq0$<br><br></li>
<li>无穷多解<br>$\;\Longleftrightarrow\;r(A)=r(\overline{A})&lt; n$<br><br><br> </li>
</ol>
<ul>
<li><p>齐次方程组$Ax=0$<br><br>$\qquad$有非0解$\;\Longleftrightarrow\;r(A) &lt; n$<br><br>$\qquad$只有零解$\;\Longleftrightarrow\;r(A)=n$</p>
</li>
<li><p>$\;$矩阵方程$AX=B$有解$\;\Longleftrightarrow\;r(A)=r(A\vdots B)\longrightarrow\;$其实就是上面的推广</p>
</li>
</ul>
<h2 id="基础解系"><a href="#基础解系" class="headerlink" title="基础解系"></a>基础解系</h2><p>理论基础：$A-m\times n,r(A)=r&lt;n$,则齐次方程组$Ax=0\;$由n-r个线性无关的解，且$Ax=0$的任一个解可由这n-r个线性无关的解线性表示</p>
<blockquote>
<p>基础解系其实就是齐次方程组解向量的极大无关组<br><br>不过要注意与向量组的极大无关组进行区分</p>
<hr>
<p>即，如果满足：<br><br>$\quad$(1)$\eta_1\;\eta_2\;\cdots\;\eta_t\;$是$Ax=0$的解；<br><br><br>$\quad$(2)$\eta_1\;\eta_2\;\cdots\;\eta_t\;$线性无关;<br><br><br>$\quad$(3)$Ax=0$的任一个解均可由$\eta_1\;\eta_2\;\cdots\;\eta_t\;$线性表示<br><br><br>则$\eta_1\;\eta_2\;\cdots\;\eta_t\;$是齐次方程组$Ax=0$的基础解系</p>
</blockquote>
<h3 id="齐次方程求基础解系和通解"><a href="#齐次方程求基础解系和通解" class="headerlink" title="齐次方程求基础解系和通解"></a>齐次方程求基础解系和通解</h3><ul>
<li><strong>例</strong><br><br>求齐次方程组<br><br>$<br>\begin{cases}<br>x_1+2x_2-x_3-5x_5=0\\<br>x_2-x_3+x_4+x_5=0\\<br>2x_1+4x_2-2x_3+x_4-8x_5=0<br>\end{cases}<br>$<br><br>的基础解系与通解<br><br>解：<br>对系数矩阵作初等行变换化为行最简型<br><br>$<br>A=<br>\begin{pmatrix}<br>  1&amp;2&amp;-1&amp;0&amp;-5\\<br>   0&amp;1&amp;-2&amp;1&amp;1\\<br>   2&amp;4&amp;-2&amp;1&amp;-8<br>\end{pmatrix}<br>\longrightarrow<br>\begin{pmatrix}<br>  1&amp;0&amp;3&amp;0&amp;-3\\<br>   0&amp;1&amp;-2&amp;0&amp;1\\<br>   0&amp;0&amp;0&amp;1&amp;2<br>\end{pmatrix}<br>$<br><br><br>$<br>n-r(A)=5-3=2\quad\longrightarrow\;表明该方程组由两个基础解系<br>$<br><br><br>同解方程组<br><br>$<br>\begin{cases}<br>x_1+3x_3-3x_5=0\\<br>x_2-2x_3-x_5=0\\<br>x_4+2x_5=0<br>\end{cases}<br>$<br><br><br>$<br>\begin{cases}<br>x_1=-3x_3+3x_5\\<br>x_2=2x_3+x_5\\<br>x_4=-2x_5<br>\end{cases}<br>$<br><br><br>$<br>分别令\begin{bmatrix}x_3\\x_5\end{bmatrix}为\begin{bmatrix}1\\0\end{bmatrix}和\begin{bmatrix}0\\1\end{bmatrix}<br>$<br><br><br>代入方程组对应求出<br>$<br>\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}为\begin{bmatrix}-3\\2\\0\end{bmatrix}和\begin{bmatrix}3\\1\\ -2\end{bmatrix}<br>$<br><br><br>得到基础解系：<br>$\quad\eta_1=[-3,2,1,0,0]^T$<br><br>$\quad\eta_2=[3,1,0,-2,1]^T$<br><br><br>通解：<br>$k_1\eta_1+k_2\eta_2$<br><br>$即\;\;k_1\begin{bmatrix}-3\\2\\1\\0\\0\end{bmatrix}+k_2\begin{bmatrix}3\\1\\0\\ -2\\1\end{bmatrix}$</li>
</ul>
<h3 id="非齐次线性方程求通解"><a href="#非齐次线性方程求通解" class="headerlink" title="非齐次线性方程求通解"></a>非齐次线性方程求通解</h3><ul>
<li>方程组$Ax=b$的通解：<br><br>$\alpha_0+k_1\eta_1+k_2\eta_2+\cdots+k_{n-r}\eta_{n-r}$<br><br>其中$\eta_1\eta_2\cdots\eta_{n-1}$是导出组$Ax=0$的基础解系$，\alpha_0$是$Ax=b$的一个解<br><br>$\qquad\longrightarrow$微分方程也是这个思想</li>
</ul>
<ul>
<li><strong>例</strong><br><br>解方程组<br><br>$<br>\begin{cases}<br>  x_1-x_2-x_3+x_4=0\\<br>  x_1-x_2+x_3-3x_4=1\\<br>  x_1-x_2-2x_3+3x_4=-\frac{1}{2}<br>\end{cases}<br>$<br><br>解：<br>对增广矩阵做初等行变换，化为行最简型<br><br>$<br>\overline{A}=<br>\begin{pmatrix}<br> 1&amp;-1&amp;-1&amp;1&amp;0\\<br> 1&amp;-1&amp;1&amp;-3&amp;1\\<br> 1&amp;-1&amp;-2&amp;3&amp;-\frac{1}{2}<br>\end{pmatrix}<br>\rightarrow<br>\begin{pmatrix}<br> 1&amp;-1&amp;0&amp;-1&amp;\frac{1}{2}\\<br> 0&amp;0&amp;1&amp;-2&amp;\frac{1}{2}\\<br> 0&amp;0&amp;0&amp;0&amp;0<br>\end{pmatrix}<br>$<br><br>$r(A)=r(\overline{A})=2<4\;\rightarrow\;方程组有无穷解$<br><br>$n-r(A)=4-2=2$<br><br>$<br>\begin{cases}<br>x_1=x_2+x_4+\displaystyle\frac{1}{2}\\<br>x_3=2x_4+\displaystyle\frac{1}{2}<br>\end{cases}$<br><br>令$\;x_2=x_4=0\;\Rightarrow\;x_1=\displaystyle\frac{1}{2},x_3=\displaystyle\frac{1}{2}<br>$<br><br><br>特解$\quad\alpha=\begin{bmatrix}\displaystyle\frac{1}{2}\\0\\ \displaystyle\frac{1}{2}\\0\end{bmatrix}$<br><br><br>令$\begin{bmatrix}x_2\\x_4\end{bmatrix}$分别为$\begin{bmatrix}1\\0\end{bmatrix}和\begin{bmatrix}0\\1\end{bmatrix}<br>$</4\;\rightarrow\;方程组有无穷解$<br></li>
</ul>
<p>$\Rightarrow\begin{bmatrix}x_1\\x_3\end{bmatrix}为\begin{bmatrix}1\\0\end{bmatrix}和\begin{bmatrix}1\\2\end{bmatrix}$<br><br><br>则基础解系为<br><br>$\eta_1=[1,1,0,0]^T，\eta_2=[1,0,2,1]^T$<br><br><br>$\therefore$方程组组的通解：<br><br>$<br>x=<br>\begin{bmatrix}x_1\\x_2\\x_3\\x_4\end{bmatrix}=<br>k_1\begin{bmatrix}1\\1\\0\\0\end{bmatrix}+<br>k_2\begin{bmatrix}1\\0\\2\\1\end{bmatrix}+<br>\begin{bmatrix}\displaystyle\frac{1}{2}\\0\\ \displaystyle\frac{1}{2}\\0\end{bmatrix}<br>$<br><br><br>这里的方程组我认为可以和向量空间，后面继续拓展深入研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>4.CSS的元素显示模式</title>
    <url>/2021/07/20/4-CSS%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS-的元素显示模式"><a href="#CSS-的元素显示模式" class="headerlink" title="CSS 的元素显示模式"></a>CSS 的元素显示模式</h1><blockquote>
<p>元素显示模式就是元素（标签）以什么方式进行显示，比如&lt;div&gt;自己占一行，比如一行可以放多个&lt;span&gt;</p>
</blockquote>
<p>HTML元素一般分为 <strong>块元素</strong> 和 <strong>行内元素</strong></p>
<h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><p>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;li&gt;等，其中&lt;div&gt;标签式最典型的块元素</p>
<p>块级元素特点：</p>
<p>1.独占一行</p>
<p>2.高度，宽度，外边距以及内边距都可以控制。</p>
<p>3.宽度默认是容器（父级宽度）的100%。</p>
<p>4.是一个容器及盒子，里面可以放行内或者块级元素。</p>
<p><strong>注意:</strong></p>
<ul>
<li>文字类元素内不能使用块级元素</li>
<li>&lt;p&gt;标签主要用于存放文字，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt;</li>
<li>同理，&lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素</li>
</ul>
<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签是最典型的行内元素。</p>
<p>行内元素的特点：</p>
<p>1.相邻行内元素在一行上，一行可以显示多个。</p>
<p>2.高、宽直接设置是无效的</p>
<p>3.默认宽度就是它本身内容的宽度。</p>
<p>4.行内元素只能容纳文本或其它行内元素。</p>
<p><strong>注意:</strong></p>
<ul>
<li>链接里面不能再放链接</li>
<li>特殊情况&lt;a&gt;里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全</li>
</ul>
<h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p>在行内元素中有几个特殊的标签 —— &lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，他们同时具有块元素和行内元素的特点，有些资料称它们为行内块元素。</p>
<p>行内块元素的特点：</p>
<p>1.和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙，一行可以显示多个（行内元素特点）</p>
<p>2.默认宽度就是它本身内容的宽度（行内元素的特点）</p>
<p>3.高度、行高、外边距以及内边距都可以控制（块级元素特点）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">元素模式</th>
<th style="text-align:left">元素排列</th>
<th style="text-align:left">设置样式</th>
<th style="text-align:left">默认宽度</th>
<th style="text-align:left">包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">块级元素</td>
<td style="text-align:left">一行只能放一个块级元素</td>
<td style="text-align:left">可以设置宽度高度</td>
<td style="text-align:left">容器的100%</td>
<td style="text-align:left">容器可以包含任何标签</td>
</tr>
<tr>
<td style="text-align:left">行内元素</td>
<td style="text-align:left">一行可以放多个行内元素</td>
<td style="text-align:left">不可以设置宽度高度</td>
<td style="text-align:left">它自身内容的宽度</td>
<td style="text-align:left">容纳文本或者其他行内元素</td>
</tr>
<tr>
<td style="text-align:left">行内块元素</td>
<td style="text-align:left">一行放多个行内块元素</td>
<td style="text-align:left">可以设置宽度高度</td>
<td style="text-align:left">它本身内容的宽度</td>
<td style="text-align:left"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="元素显示模式转换"><a href="#元素显示模式转换" class="headerlink" title="元素显示模式转换"></a>元素显示模式转换</h2><p>特殊情况下，我们需要元素模式的转换，简单理解：一个模式的元素需要另外一种模式的特性，比如想要增加链接&lt;a&gt;的触发范围</p>
<ul>
<li>转换为块元素：display:block;</li>
<li>转换为行内元素： display:inline;</li>
<li>转换为行内块元素： display:inline-block;</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>4.图</title>
    <url>/2021/07/30/4-%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>完全图</strong>：任意两个点都有一条边相连</p>
<ul>
<li>无向完全图：没有方向</li>
<li>有向完全图：有方向<span id="more"></span>
<img style="transform:scale(0.5);" src="/2021/07/30/4-%E5%9B%BE/pic1.png"></li>
</ul>
<p><strong>稀疏图</strong>：有很少边或弧的图</p>
<p><strong>稠密图</strong>：有较多边或弧的图</p>
<p><strong>邻接</strong>：有边/弧相连的两个顶点之间的关系</p>
<ul>
<li>存在 $(v_i,v_j)$，则称 $v_i$ 和 $v_j$ 互为临邻接点</li>
<li>存在 &lt;$v_i,v_j$&gt;，则称 $v_i$ <strong>邻接到</strong> $v_j$ ，$v_j$ <strong>邻接于</strong> $v_i$</li>
</ul>
<p><strong>关联</strong>：边/弧与顶点之间的关系</p>
<ul>
<li>存在 $(v_i,v_j)$ /&lt;$v_i,v_j$&gt; ，则称该边/弧关联于 $v_i$ 和 $v_j$</li>
</ul>
<p><strong>顶点的度</strong>：与该顶点相关联的边的数目，记为TD(v)</p>
<ul>
<li>在有向图中，顶点的度等于该顶点的 <strong>入度</strong> 和 <strong>出度</strong> 之和<ul>
<li>顶点v的 <strong>入度</strong> 是 <strong>以v为终点</strong> 的有向边的条数，记作ID(v)</li>
<li>顶点v的 <strong>出度</strong> 是以 <strong>v为始点</strong> 的有向边的条数，记作OD(v)</li>
</ul>
</li>
</ul>
<p><strong>路径</strong>：接续的边构成的顶点序列</p>
<p><strong>路径长度</strong>：路径上边或弧的数目/权值之和</p>
<p><strong>回路（环）</strong>：第一个顶点和最后一个顶点相同的路径</p>
<p><strong>简单路径</strong>：除路径起点和终点可以相同外，其余顶点均不相同的路径</p>
<p><strong>简单回路</strong>：除路径起点和终点相同外，其余顶点均不相同</p>
<p><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic2.png"></p>
<p><strong>连通图（强连通图）</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic3.png"></p>
<p><strong>权</strong>：图中边或弧所具有的相关数称为 <strong>权</strong>。表明从一个顶点到另一个顶点的距离或耗费</p>
<p><strong>网</strong>：边/弧带权的图</p>
<p><strong>子图</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic4.png"></p>
<p><strong>连通分量（强连通分量）</strong></p>
<ul>
<li>无向图G的 <strong>极大连通子图</strong> 称为G的 <strong>连通分量</strong><br>极大连通子图：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通</li>
<li>有向图G的极大强连通子图称为G的强连通分量<br>极大强连通子图：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的</li>
</ul>
<p><strong>极小连通子图</strong>：该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通</p>
<p><strong>生成树</strong>：包含无向图G所有顶点的极小连通子图</p>
<p><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合<br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic5.png"></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>1、数组（邻接矩阵）表示法</p>
<ul>
<li>建立一个 <strong>顶点表</strong>（记录各个顶点信息）和一个 <strong>邻接矩阵</strong>（表示各个顶点之间关系）</li>
</ul>
<p><strong>无向图的邻接矩阵表示法：</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic6.png"></p>
<p><strong>有向图的邻接矩阵表示法：</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic7.png"></p>
<p><strong>行为出度，列为入度</strong></p>
<p><strong>网（即有权图）的邻接矩阵表示法</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic8.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VerTexType;<span class="comment">//设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType; <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum]; <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125;AMGragh;<span class="comment">//Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure>
<p>2、采用邻接矩阵表示法 <strong>创建无向网</strong></p>
<ul>
<li>输入总顶点数和总边数</li>
<li>依次输入点的信息存入顶点表中</li>
<li>初始化邻接矩阵，使每个权值初始化为极大值</li>
<li>构造邻接矩阵</li>
</ul>
<p>邻接矩阵优点：</p>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便计算任一顶点的”度”</li>
</ul>
<p>缺点：</p>
<ul>
<li>不便于增加或删除顶点</li>
<li>浪费空间—-存稀疏图（点很多而且边很少）有大量无效元素<ul>
<li>当然对稠密图（特别是完全图）划算</li>
</ul>
</li>
<li>浪费时间—-统计稀疏图中一共有多少条边</li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>1、邻接表表示法（链式）<br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic9.png"></p>
<ul>
<li>顶点：<ul>
<li>按编号顺序将顶点数据存储在 <strong>一维数组</strong> 中</li>
</ul>
</li>
<li>关联同一顶点的边（以顶点为尾的弧）：<ul>
<li>用线性 <strong>链表</strong> 存储</li>
</ul>
</li>
</ul>
<p><strong>顶点结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br></pre></td></tr></table></figure></p>
<p><strong>弧（边）的结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br></pre></td></tr></table></figure></p>
<p><strong>图的结构定义</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//vertices--vertex的复数</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure></p>
<p>2、采用邻接表法创建无向网</p>
<p>算法思想</p>
<ul>
<li>输入总顶点数和总边数</li>
<li>建立顶点表<ul>
<li>依次输入点的信息存入顶点表中</li>
<li>使每个表头结点的指针域初始化为NULL</li>
</ul>
</li>
<li><p>创建邻接表</p>
<ul>
<li>依次输入每条边依附的两个顶点</li>
<li>确定两个顶点的序号i和j，建立边结点</li>
<li>将此边结点分别插入到$v_i$和$v_j$对应的两个边链表的头部</li>
</ul>
</li>
<li><p>方便找任一顶点的所有“邻接点”</p>
</li>
<li>节约稀疏图的空间<ul>
<li>需要N个头指针+2E个结点（每个结点至少两个域）</li>
</ul>
</li>
<li>计算任一顶点的“度”<ul>
<li>对无向图：是</li>
<li>对有向图：只能计算“出度”；需要构造“逆邻接表”来计算“入度”</li>
</ul>
</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul>
<li>深度优先搜索（Depth_First Search—-DFS）</li>
<li>广度优先搜索（Breadth_First Search—-BFS）</li>
</ul>
<h3 id="深度优先遍历的算法实现"><a href="#深度优先遍历的算法实现" class="headerlink" title="深度优先遍历的算法实现"></a>深度优先遍历的算法实现</h3><p>邻接矩阵表示的无向图深度遍历实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMGraph G,<span class="keyword">int</span> V)</span></span>&#123;<span class="comment">//图G为邻接矩阵类型</span></span><br><span class="line">    cout&lt;&lt;v;visited[v]=<span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)<span class="comment">//依次检查邻接矩阵v所在的行</span></span><br><span class="line">        <span class="keyword">if</span>((G.arcs[v][w]!=<span class="number">0</span>)&amp;&amp;(!visited[w]))</span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        <span class="comment">//w是v的邻接点，如果w未访问，则递归调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历算法实现"><a href="#广度优先遍历算法实现" class="headerlink" title="广度优先遍历算法实现"></a>广度优先遍历算法实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;v;visted[v]=<span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);<span class="comment">//v进队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;<span class="comment">//队列非空</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,u);<span class="comment">//队头元素出队并置为u</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstAdjVex</span>(G,u);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextAdjVex</span>(G,u,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            cout&lt;&lt;w;visted[w]=<span class="literal">true</span>; <span class="built_in">EnQueue</span>(Q,w);<span class="comment">//w进队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><strong>1、普利姆（prim）算法</strong><br>适应范围：稠密图<br>时间复杂度$O(n^2)$<br><strong>2、克鲁斯卡尔(Kruskal)算法</strong><br>适应范围：稀疏图<br>时间复杂度：$O(e\log e)$</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ol>
<li>单源最短路径—用 Dijkstra(迪杰斯特拉)算法<ul>
<li>初始化：先找出从源点 $v_0$ 到各终点 $v_k$ 的直达路径($v_0$,$v_k$)，即通过一条弧到达的路径</li>
<li>选择：从这些路径中找出一条长度最短的路径($v_0$ , u)</li>
<li>更新：然后对其余各条路径进行适当调整：<ul>
<li>若在途中存在弧（u , $v_k$），且($v_0$ , u)+(u , $v_k$) &lt; ($v_0$ , $v_k$)，则以路径则以路径($v_0$ , u , $v_k$)代替($v_0$ , $v_k$)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li>所有顶点间的最短路径—用 Floyd(弗洛伊德)算法<br>s</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4.索引补充</title>
    <url>/2021/07/04/4-%E7%B4%A2%E5%BC%95%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>5
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 3, 4])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11]],

       [[12, 13, 14, 15, 16, 17],
        [18, 19, 20, 21, 22, 23]]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])
</code></pre><h1 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">arr2d</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:<span class="number">2</span>] <span class="comment"># 表示选取前两行</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[<span class="number">1</span>:] <span class="comment"># 表示选取第1行之后的所有行</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:<span class="number">2</span>,<span class="number">1</span>:] <span class="comment"># 两个结合起来使用，第一个选取行，第二个选取列</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [5, 6, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:,<span class="number">2</span>] <span class="comment"># 只有冒号表示整个轴</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 2,  6, 10])
</code></pre><h1 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = np.array([<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;wang&quot;</span>,<span class="string">&quot;zhang&quot;</span>,<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;zhang&quot;</span>,<span class="string">&quot;wang&quot;</span>,<span class="string">&quot;wang&quot;</span>])</span><br><span class="line">data =  np.arange(<span class="number">21</span>).reshape(<span class="number">7</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure>
<pre><code>array([&#39;liu&#39;, &#39;wang&#39;, &#39;zhang&#39;, &#39;liu&#39;, &#39;zhang&#39;, &#39;wang&#39;, &#39;wang&#39;],
      dtype=&#39;&lt;U5&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14],
       [15, 16, 17],
       [18, 19, 20]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[name == <span class="string">&quot;liu&quot;</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[name == <span class="string">&quot;liu&quot;</span>,:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1],
       [ 9, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[(name==<span class="string">&#x27;liu&#x27;</span>)|(name==<span class="string">&#x27;wang&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 9, 10, 11],
       [15, 16, 17],
       [18, 19, 20]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[data &lt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre><p>也就是说布尔索引会把括号里面为真的按顺序返回</p>
<h1 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h1><blockquote>
<p>利用整数数组进行索引</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    arr[i] = i</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[2., 2., 2., 2.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [1., 1., 1., 1.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([ 2, 11,  5, 10])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]][:,[<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5,  6],
       [ 9, 10]])
</code></pre><p>花式索引和切片不一样，它总是复制到新数组中</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>5.CSS盒子模型</title>
    <url>/2021/07/20/5-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h1><h2 id="盒子模型组成"><a href="#盒子模型组成" class="headerlink" title="盒子模型组成"></a>盒子模型组成</h2><p><strong>盒子模型：</strong> 就是把HTML页面中的 <strong>布局元素看作是一个矩形的盒子</strong>，或者说是一个盛装内容的容器。</p>
<p>CSS盒子模型包括：边框，外边距，内边距，内容。</p>
<h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><div style="width: 300px; height: 200px; border:5px solid #CCE8CF;text-align: center;line-height: 300px"><span style="width: 150px; height: 100px; border:5px solid #CCE8CF;  display:inline-block;"></span></div>

<p><strong>border</strong> 属性用于设置边框，三部分：边框宽度、样式、颜色</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">border-width</td>
<td style="text-align:left">边框粗细，单位是px</td>
</tr>
<tr>
<td style="text-align:left">border-style</td>
<td style="text-align:left">边框样式</td>
</tr>
<tr>
<td style="text-align:left">border-color</td>
<td style="text-align:left">边框颜色</td>
</tr>
</tbody>
</table>
</div>
<h3 id="边框的复合写法"><a href="#边框的复合写法" class="headerlink" title="边框的复合写法"></a>边框的复合写法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: border-width border-style border-color;</span><br></pre></td></tr></table></figure>
<p><strong>没有顺序</strong>，但一般按照此顺序书写</p>
<h3 id="边框的分开写法"><a href="#边框的分开写法" class="headerlink" title="边框的分开写法"></a>边框的分开写法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br><span class="line">只设定上边框，其余的同理</span><br></pre></td></tr></table></figure>
<h3 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h3><p><strong>border-collapse</strong> 属性控制浏览器绘制 <strong>表格边框</strong> 的方式，它控制相邻单元格的边框。</p>
<p>语法：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>: collapse;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>collapse是合并的意思</li>
<li>border-collapse: collapse;表示相邻边框合并在一起</li>
</ul>
<h3 id="边框影响盒子的实际大小"><a href="#边框影响盒子的实际大小" class="headerlink" title="边框影响盒子的实际大小"></a>边框影响盒子的实际大小</h3><p>边框会额外增加盒子的实际大小</p>
<p>解决方案:</p>
<ol>
<li>测量盒子大小的时候，不量边框</li>
<li>如果测量的时候包含了边框，则需要盒子长宽减去边框宽度</li>
</ol>
<h2 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h2><p>padding属性用于设置内边距，即边框与内容之间的距离。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">padding-left</td>
<td style="text-align:left">左内边距</td>
</tr>
<tr>
<td style="text-align:left">padding-right</td>
<td style="text-align:left">右内边距</td>
</tr>
<tr>
<td style="text-align:left">padding-top</td>
<td style="text-align:left">上内边距</td>
</tr>
<tr>
<td style="text-align:left">padding-bottom</td>
<td style="text-align:left">下内边距</td>
</tr>
</tbody>
</table>
</div>
<h3 id="padding复合写法"><a href="#padding复合写法" class="headerlink" title="padding复合写法"></a>padding复合写法</h3><p><strong>padding</strong> 属性可以有一到四个值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值的个数</th>
<th style="text-align:left">意思</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1个值 padding: 5px;</td>
<td style="text-align:left">上下左右内边距都是5px</td>
</tr>
<tr>
<td style="text-align:left">2个值 padding: 5px;10px;</td>
<td style="text-align:left">上下内边距是5px，左右内边距是10px</td>
</tr>
<tr>
<td style="text-align:left">3个值 padding: 5px 10px 20px;</td>
<td style="text-align:left">上内边距是5px，左右内边距10px，下内边距是20px</td>
</tr>
<tr>
<td style="text-align:left">4个值 padding: 5px 10px 20px 30px;</td>
<td style="text-align:left">上是5px，右是10px，下是20px，左是30px（顺时针）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="padding影响盒子实际大小"><a href="#padding影响盒子实际大小" class="headerlink" title="padding影响盒子实际大小"></a>padding影响盒子实际大小</h3><p>如果盒子已经有了宽度和高度，也就是内容和边框有了距离，添加了内边距后就会撑大盒子</p>
<p><strong>解决方法：</strong><br>如果保证盒子跟效果图大小保持一致，则 <strong>减去多出的内边距</strong> </p>
<p><strong>如果盒子本身没有指定长宽属性，则padding不会撑开盒子</strong></p>
<h2 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h2><p><strong>margin</strong> 属性用于设置外边距，即控制盒子和盒子之间的距离。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">margin-left</td>
<td style="text-align:left">左外边距</td>
</tr>
<tr>
<td style="text-align:left">margin-right</td>
<td style="text-align:left">右外边距</td>
</tr>
<tr>
<td style="text-align:left">margin-top</td>
<td style="text-align:left">上外边距</td>
</tr>
<tr>
<td style="text-align:left">margin-bottom</td>
<td style="text-align:left">下外边距</td>
</tr>
</tbody>
</table>
</div>
<p><strong>简写方式和padding一样</strong></p>
<p><strong>1.块级盒子水平居中</strong><br>外边距可以让块级盒子 <strong>水平居中</strong>，但是必须满足两个条件：</p>
<ol>
<li>盒子 <strong>必须制定宽度</strong></li>
<li>盒子左右的外边距都设置为auto<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123; <span class="attribute">width</span>: <span class="number">960px</span>; <span class="attribute">margin</span>:<span class="number">0</span> auto;&#125;</span><br></pre></td></tr></table></figure>
常见的写法，以下三种都可以：</li>
</ol>
<ul>
<li>margin-left: auto; margin-right: auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;</li>
</ul>
<p><strong>注意:</strong><br>以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 <strong>text-align: center</strong> 即可</p>
<p><strong>2.嵌套块元素垂直外边距的塌陷</strong><br>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p>
<p>解决方案：</p>
<p>1.可以为父元素定义边框</p>
<p>2.可以为父元素定义内边距</p>
<p>3.可以为父元素添加 <strong>overflow: hidden</strong></p>
<p>还有其他方法，比如浮动，固定，绝对定位的盒子不会有塌陷问题</p>
<h2 id="清除内外边距"><a href="#清除内外边距" class="headerlink" title="清除内外边距"></a>清除内外边距</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距，但是转换为块级和行内块元素就可以了</p>
<h1 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h1><p>border-radius 属性用于设置元素的外边框圆角<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: length;</span><br><span class="line">这里length可以用百分比表示，例如<span class="number">50%</span>表示是高度的<span class="number">50%</span></span><br></pre></td></tr></table></figure><br>radius 半径（圆的半径）原理：（椭）圆与边框的交集形成圆角效果</p>
<p>border-radius可以跟多个数值1~4个</p>
<h1 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h1><p><strong>box-shadow</strong> 属性为盒子添加阴影<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset（outset是默认值不能写）;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h-shadow</td>
<td style="text-align:left">必须，水平阴影的位置，允许负值</td>
</tr>
<tr>
<td style="text-align:left">v-shadow</td>
<td style="text-align:left">必须，垂直阴影的位置，允许负值</td>
</tr>
<tr>
<td style="text-align:left">blur</td>
<td style="text-align:left">可选，模糊距离</td>
</tr>
<tr>
<td style="text-align:left">spread</td>
<td style="text-align:left">可选，阴影的尺寸</td>
</tr>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">可选，阴影的颜色</td>
</tr>
<tr>
<td style="text-align:left">inset</td>
<td style="text-align:left">可选，将外部阴影（outset）改为内部阴影</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意</strong><br>1.默认的是外阴影（outset）,但不可以写这个单词，否则阴影无效</p>
<p>2.盒子阴影不占用空间，不会影响其他盒子排列</p>
<h1 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h1><p>语法：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-shadow blur color</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>4.n维向量</title>
    <url>/2021/06/20/4.n%E7%BB%B4%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="n维向量"><a href="#n维向量" class="headerlink" title="n维向量"></a>n维向量</h1><blockquote>
<p>n个数$a_1,a_2,\cdots a_n$构成的有序数组</p>
</blockquote>
<p>$\left[\begin{array}{c}a_1\\a_2\\ \vdots \\a_n\end{array}\right]$<br>或$\left[\begin{array}{c}a_1\;a_2\;\cdots\;a_n\end{array}\right]^T\longrightarrow$列向量<br><br><br>$\left[\begin{array}{c}a_1\;a_2\;\cdots\;a_n\end{array}\right]\longrightarrow$行向量</p>
<h2 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h2><p>运算方法其实就是矩阵的运算方法</p>
<h2 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h2><h3 id="向量的线性表示"><a href="#向量的线性表示" class="headerlink" title="向量的线性表示"></a>向量的线性表示</h3><blockquote>
<p>m个n维向量$\alpha_1\alpha_2\cdots\alpha_m$及m个实数$k_1,k_2,\cdots,k_m$,称</p>
<p>$\quad k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m$</p>
<p>是向量$\alpha_1\alpha_2\cdots\alpha_m$的一个线性组合，$k_1,k_2,\cdots,k_m$为这个线性组合的系数<br><br><br>如果向量$\beta$能表示为$\alpha_1\alpha_2\cdots\alpha_m$的线性组合，即</p>
<p>$\qquad\qquad \beta=k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m$</p>
<p>则称向量$\beta$可由$\alpha_1\alpha_2\cdots\alpha_m$线性表示</p>
</blockquote>
<p>$[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}k_1\\k_2\\ \vdots\\k_m\end{array}\right]=\beta$<br><br>$\Longleftrightarrow方程组$<br>$[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}x_1\\x_2\\ \vdots\\x_m\end{array}\right]=\beta\;\;有解$<br><br>$\Longleftrightarrow r(\alpha_1\alpha_2\cdots\alpha_m)= r(\alpha_1\alpha_2\cdots\alpha_m\beta)$</p>
<p><strong>例</strong></p>
<p>$设\alpha_1=[1,-1,1]^T，\alpha_2=[-2,1,1]^T$<br>$\alpha_3=[4,-3,1]^T，\beta=[3,-1,3]^T$<br><br>$判断\beta能否由\alpha_1\alpha_2\alpha_3线性表示$</p>
<p>解：<br>$设k_1\alpha_1+k_2\alpha_2+k_3\alpha_3=\beta$<br><br>即<br>$k_1[1,-1,1]^T+k_2[-2,1,1]^T+k_3[4,-3,1]^T$<br>$=[3,-1,3]^T$<br></p>
<ul>
<li>即<br>$\begin{cases}<br>  k_1-2k_2+4k_3=3\\<br>  -x_1+x_2-3x_3=-1\\<br>  x_1+x_2+x_3=-1\\<br>\end{cases}$</li>
</ul>
<p>$下面就转化为了高斯消元法进行求解出k_1k_2k_3$<br><br>$\qquad\qquad\downarrow$<br><br>$\overline{A}=<br>\begin{pmatrix}<br>    1&amp;-2&amp;4&amp;3\\<br>    -1&amp;1&amp;-3&amp;-1\\<br>    1&amp;1&amp;1&amp;-3<br>\end{pmatrix}$<br><br>$\therefore$可以将上面的向量直接转化成增广矩阵进行求解</p>
<p>在这里将方程组用矩阵进行表示就可以抽象为<br><br>$<br>\begin{pmatrix}<br>    1&amp;-2&amp;4&amp;3\\<br>    -1&amp;1&amp;-3&amp;-1\\<br>    1&amp;1&amp;1&amp;-3<br>\end{pmatrix}<br>\begin{pmatrix}<br>    x_1\\<br>    x_2\\<br>    x_3\\<br>    x_4<br>\end{pmatrix}<br>=\begin{pmatrix}<br>    -3\\<br>    1\\<br>    -1<br>\end{pmatrix}<br>$<br><br>也就是说一组坐标经过有限次线性变换后可以将其转化成$\beta$</p>
<h3 id="向量组的线性表示"><a href="#向量组的线性表示" class="headerlink" title="向量组的线性表示"></a>向量组的线性表示</h3><blockquote>
<p>设向量组<br>$(a)\alpha_1,\alpha_2,\cdots,\alpha_s,\;<br> \;(b)\beta_1,\beta_2,\cdots,\beta_t$<br><br>若(a)中的每个向量$\alpha_i(i=1,2,\cdots,s)$ <strong>均</strong> 可由(b)线性表示，则称向量组(a)可由向量组(b)线性表示,如果两个向量组可以互相表示，则称两个向量组等价</p>
</blockquote>
<p><strong>例</strong></p>
<p>设$A，B$均为3阶矩阵，且$AB=C$</p>
<p>证明：$C$的列向量可由$A$的列向量线性表示,若矩阵$B$可逆,则$C$和$A$的列向量组等价。</p>
<p>设$A=[\alpha_1\;\alpha_2\;\alpha_3],C=[\gamma_1\;\gamma_2\;\gamma_3],B=[b_{ij}]_{3\times3}$</p>
<p>$A$和$C$都是按照按列进行划分</p>
<p>$由\;AB=C\;有$<br><br><br>$<br>[\alpha_1\;\alpha_2\;\alpha_3]<br>\left[\begin{array}{ccc}b_{11}&amp;b_{12}&amp;b_{13}\\<br>    b_{21}&amp;b_{22}&amp;b_{23}\\<br>    b_{31}&amp;b_{32}&amp;b_{33}<br>\end{array}\right]=[\gamma_1\;\gamma_2\;\gamma_3]<br>$</p>
<ul>
<li>即<br>$<br>\begin{cases}<br>b_{11}\alpha_1+b_{21}\alpha_2+b_{31}\alpha_3=\gamma_1\\<br>b_{12}\alpha_1+b_{22}\alpha_2+b_{32}\alpha_3=\gamma_2\\<br>b_{13}\alpha_1+b_{23}\alpha_2+b_{33}\alpha_3=\gamma_3\\<br>\end{cases}<br>$<br><br>$<br>\therefore\;C的列向量可由A的列向量线性表示<br>$</li>
</ul>
<p>$\because B可逆$<br><br>$\therefore A=CB^{-1}\;,记B^{-1}=[k_{ij}]_{3\times3}$<br><br><br>$<br>[\alpha_1\;\alpha_2\;\alpha_3]<br>=[\gamma_1\;\gamma_2\;\gamma_3]<br>\left[\begin{array}{ccc}<br>    k_{11}&amp;k_{12}&amp;k_{13}\\<br>    k_{21}&amp;k_{22}&amp;k_{23}\\<br>    k_{31}&amp;k_{32}&amp;k_{33}<br>\end{array}\right]<br>$</p>
<ul>
<li>即<br>$<br>\begin{cases}<br>k_{11}\gamma_1+k_{21}\gamma_2+k_{31}\gamma_3=\alpha_1\\<br>k_{12}\gamma_1+k_{22}\gamma_2+k_{32}\gamma_3=\alpha_2\\<br>k_{13}\gamma_1+k_{23}\gamma_2+k_{33}\gamma_3=\alpha_3\\<br>\end{cases}<br>$<br><br>$ \therefore A的列向量可由C的列向量线性表示$<br><br>$\therefore C$的列向量可由A的列向量线性表示</li>
</ul>
<p>因为矩阵$B$可逆</p>
<p>则$C$和$A$的列向量组等价。<br></p>
<h4 id="矩阵和向量组等价的概念区分"><a href="#矩阵和向量组等价的概念区分" class="headerlink" title="矩阵和向量组等价的概念区分"></a>矩阵和向量组等价的概念区分</h4><p>矩阵的A和B等价：A经初等变换可以变成B<br><br>向量组(a)和(b)等价：(a)和(b)可以 <strong>互相</strong> 线性表示<br><br>$\therefore$两者没有必然的联系，不要搞混</p>
<h4 id="用方程组理解向量组的线性表示"><a href="#用方程组理解向量组的线性表示" class="headerlink" title="用方程组理解向量组的线性表示"></a>用方程组理解向量组的线性表示</h4><blockquote>
<p>向量组$\beta_1\;\beta_2\;\cdots\;\beta_t$可以用向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$线性表示，<br><br>则$r(B)\leqslant r(A)$<br><br>其中$B=(\beta_1\;\beta_2\;\cdots\;\beta_t),$<br><br>$A=(\alpha_1\;\alpha_2\;\cdots\;\alpha_s)$<br><br><br>如果$r(A)=r(B)$，则两个向量组等价</p>
</blockquote>
<p>个人直观理解：<br>B的秩肯定小于A的秩，如果大于的话矩阵最后有几行就不能被表示了，<br>小于的话，最后几行就算多出来，$k_{ij}$令为0就行了<br>而两者的秩如果相等，那么两者就正好能被互相表示出来，也就是说两个向量组等价</p>
<p>证明：<br>$\beta_1\;\beta_2\;\cdots\;\beta_t$可由$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$线性表示</p>
<p>$\Leftrightarrow\;$方程组</p>
<p>$\quad\; Ax=\beta_1，Ax=\beta_2，\cdots，Ax=\beta_t$有解</p>
<p>$\Leftrightarrow\;r(A)=r(A,B)$</p>
<p>$\because r(B)\leqslant r(A,B)\;\longleftarrow\;$矩阵的秩的性质</p>
<p>$\therefore r(B)\leqslant r(A)$</p>
<h2 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h2><blockquote>
<p>$给定m个n维向量\alpha_1\;\alpha_2\;\cdots\;\alpha_m，$如果存在不全为零的数$k_1，k_2，\cdots，k_m$使得<br><br>$\qquad k_1\alpha_1+k_2\alpha_2+\cdots k_m\alpha_m=0$<br><br>则称向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_m$线性相关，否则为线性无关</p>
</blockquote>
<p>个人直观理解：<br>线性相关其实就是向量经过长度变换能够首尾相连，就是线性表示的一种特殊情况</p>
<p><strong>注意</strong>：<br>有零向量的向量组肯定线性相关</p>
<hr>
<p>线性相关同样可以用高斯消元法求出$k_1,k_2,\cdots k_m$，<br><br>因为这其实就是线性表示$\beta$为零向量，且$k_i$不全为零的一种特殊情况<br><br><br>$[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}k_1\\k_2\\ \vdots\\k_m\end{array}\right]=0$<br><br>$\Longleftrightarrow方程组$<br><br>$\qquad[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}x_1\\x_2\\ \vdots\\x_m\end{array}\right]=0\;\;有非零解$<br><br>$\Longleftrightarrow r(\alpha_1\alpha_2\cdots\alpha_m)&lt; m$<br>$\quad m$就是方程组解的个数</p>
<p><strong>推论</strong></p>
<ol>
<li>$n个n维向量\alpha_1\;\alpha_2\;\cdots\;\alpha_n\;$相关<br><br>$\Leftrightarrow\;|\alpha_1\;\alpha_2\;\cdots\;\alpha_n|=0\;$<br><br></li>
<li>$n+1个n维向量必线性相关 \rightarrow r \leqslant n &lt; n+1$<br><br></li>
<li>如果$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$线性相关，则$\alpha_1\;\alpha_2\;\cdots\;\alpha_s\;\cdots\;\alpha_t$线性相关<br><br></li>
<li>如果向量组线性无关，增加维度仍然线性无关</li>
</ol>
<h3 id="相关定理及结论"><a href="#相关定理及结论" class="headerlink" title="相关定理及结论"></a>相关定理及结论</h3><ol>
<li>向量组$<br>\alpha_1,\alpha_2,\cdots,\alpha_s(s\leqslant2)$线性相关<br>$\Leftrightarrow\;$至少有一个向量$\alpha_i$可由其余向量$\alpha_1,\alpha_2,\cdots,\alpha_{i-1},\alpha_{i+1},\cdots,\alpha_s$线性表示<br><br></li>
<li>如果n维向量组$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关，而$\alpha_1,\alpha_2,\cdots,\alpha_s,\beta\;$线性相关，则向量$\beta\;$必能由$\alpha_1,\alpha_2,\cdots,\alpha_s$线性表示，且表示法唯一<br><br></li>
<li>如果$\alpha_1,\alpha_2,\cdots,\alpha_s$可由$\;\beta_1,\beta_2,\cdots,\beta_t\;$线性表示，且$s&gt;t$,则$\alpha_1,\alpha_2,\cdots,\alpha_s$必线性相关<br><br>推论：如果$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关，且$\alpha_1,\alpha_2,\cdots,\alpha_s$可由$\;\beta_1,\beta_2,\cdots,\beta_t\;$线性表示,则$\;s\leqslant t$（极大线性无关组）<br><br></li>
<li>$n+1$个$n$维向量必线性相关<br><br></li>
<li>初等 <strong>行变换</strong> 不改变矩阵的 <strong>列向量组</strong> 之间的线性关系；初等 <strong>列变换</strong> 不改变 <strong>行向量组</strong> 之间的线性关系<br><br></li>
<li>一个零向量线性相关，一个非零向量线性无关</li>
</ol>
<blockquote>
<p>线性表示和线性相关无关的定理和结论都是从定义出发进行推理的，推理主要是通过方程组的思想。</p>
</blockquote>
<h2 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h2><blockquote>
<p>向量组的$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的极大线性无关组中所含 <strong>向量的个数r</strong> 称为向量组的秩.<br>记为$R(\alpha_1\;\alpha_2\;\cdots\;\alpha_s)=r$<br><br>规定只有零向量的向量组的秩为0<br>三秩相等：矩阵A的秩等于A 的列向量的秩，也等于A的行向量的秩</p>
</blockquote>
<h3 id="极大线性无关组："><a href="#极大线性无关组：" class="headerlink" title="极大线性无关组："></a>极大线性无关组：</h3><blockquote>
<p>$\qquad$在向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$中，如果存在r个向量$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}$线性 <strong>无关</strong> ，<strong>再</strong> 添加任一个向量$\alpha_j,(j=1,2,\cdots,s)$,向量组$\alpha_{i1}\;\alpha_{i2}\;\cdots\alpha_{ir}\alpha_j$就线性 <strong>相关</strong> ，则称$\alpha_{i1}\;\alpha_{i2}\;\cdots\alpha_{ir}$是向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的一个极大线性无关组。<br><br><br>其实很好理解，极大线性无关组就是把向量组中挑出来一组最多线性无关的向量能够表示这个向量组的任何向量。</p>
</blockquote>
<p>定理：<br>如果$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$与$\alpha_{j1}\;\alpha_{j2}\;\cdots\;\alpha_{jt}\;$都是向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的极大线性无关组，则$r=t$</p>
<p>证：<br>因为$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$是$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的极大线性无关组，</p>
<p>那么$\forall\alpha_{jp}(p=1,2,\cdots,t),$<br><br>必有$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\alpha_{jp}$线性相关；<br><br>又因$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$线性无关<br><br>那么$\alpha_{jp}(p=1,2,\cdots,t)$<br><br>能够由$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$线性表示<br><br>于是$\alpha_{j1}\;\alpha_{j2}\;\cdots\;\alpha_{jt}\;$可由$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$线性表示<br><br>又因为$\alpha_{j1}\;\alpha_{j2}\;\cdots\;\alpha_{jt}\;$线性无关<br><br>则有$\;t\leqslant r$.<br><br>又因为两者地位相等，同理可得$\;r\leqslant t$.<br><br>所以$r=t$</p>
<p>PA=B$\;\longrightarrow$A经过有限次行变换变成B<br><br>A的列向量与B的列向量<br>a.相同的线性相关性<br>b.相同的线性表示.</p>
<ul>
<li>例.求向量组$\alpha_1=(2,1,4,3)^T,$ $\alpha_2=(-1,1,-6,6)^T,$ $\alpha_3=(-1,-2,2,-9)^T,$ $\alpha_4=(1,1,-2,7)^T,$ $\alpha_5=(2,4,4,9)^T$的秩,一个极大线性无关组，并把其余的向量用该极大线性无关组线性表示。<br><br><br>解：构造矩阵$\;A=(\alpha_1\alpha_2\alpha_3\alpha_4\alpha_5)$作初等变换化为行最简型，有<br><br>$<br>A=\begin{pmatrix}<br>  2&amp;-1&amp;-1&amp;1&amp;2\\<br>  1&amp;1&amp;-2&amp;1&amp;4\\<br>  4&amp;-6&amp;2&amp;-2&amp;4\\<br>  3&amp;6&amp;-9&amp;7&amp;9<br>\end{pmatrix}<br>$<br><br><br>$<br>\longrightarrow<br>\begin{pmatrix}<br>  1&amp;0&amp;-1&amp;0&amp;4\\<br>  0&amp;1&amp;-1&amp;0&amp;3\\<br>  0&amp;0&amp;0&amp;1&amp;-3\\<br>  0&amp;0&amp;0&amp;0&amp;0<br>\end{pmatrix}<br>$<br><br><br>$r(\alpha_1\alpha_2\alpha_3\alpha_4\alpha_5)=3$</li>
</ul>
<p>极大线性无关组：$\alpha_1\;\alpha_2\;\alpha_4$</p>
<p>$\therefore\alpha_3=-\alpha_1-\alpha_2$</p>
<p>$\quad\alpha_5=4\alpha_1+3\alpha_2-3\alpha_4$</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>5.查找</title>
    <url>/2021/08/08/5-%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><blockquote>
<p><strong>查找表</strong> 是由同一类型的数据元素（或记录）构成的 <strong>集合</strong></p>
</blockquote>
<ul>
<li><strong>关键字</strong>：用来表示一个数据元素（或记录）的某个数据项的值<ul>
<li>主关键字：可唯一的标识一个记录的关键字</li>
<li>次关键字：用以识别若干记录的关键字</li>
</ul>
</li>
</ul>
<p>对查找表经常进行的 <strong>操作</strong>：</p>
<ul>
<li><strong>查询</strong> 某个“特定的”数据元素是否在查找表中</li>
<li><strong>检索</strong> 某个“特定的”数据元素的各种属性</li>
<li>在查找表中 <strong>插入</strong> 一个数据元素</li>
<li><strong>删除</strong> 查找表中的某个数据元素</li>
</ul>
<span id="more"></span>
<p>查找表可分为两类：</p>
<ul>
<li>静态查找表：仅作“查询”（检索）操作的查找表</li>
<li>动态查找表：作“插入”和“删除”操作的查找表</li>
</ul>
<p><strong>查找算法的评价指标</strong>：<br>关键字的平均比较次数，也称 <strong>平均查找长度ASL</strong></p>
<script type="math/tex; mode=display">ASL = \sum\limits_{i=1}^np_ic_i</script><p>n：记录的个数</p>
<p>$p_i$：查找第i个记录的概率（通常认为$p_i=\displaystyle\frac 1n$）</p>
<p>$c_i$：找到第i个记录所需的比较次数</p>
<h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="顺序查找（线性查找）"><a href="#顺序查找（线性查找）" class="headerlink" title="顺序查找（线性查找）"></a>顺序查找（线性查找）</h2><p>应用范围：</p>
<ul>
<li>顺序表或线性链表表示的 <strong>静态查找表</strong></li>
<li>表内元素之间 <strong>无序</strong></li>
</ul>
<p>数据元素类型定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;<span class="comment">//关键字域</span></span><br><span class="line">    ……          <span class="comment">//其他域</span></span><br><span class="line">&#125;ElemType;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *R;<span class="comment">//表基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;<span class="comment">//Sequential Search Table</span></span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br></pre></td></tr></table></figure>
<p>顺序查找算法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(ST.R[i].key==key) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其他形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.R[i].key != key;i--)</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>改进</strong>：把待查关键字key存入表头（“哨兵”、“监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST.R[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.R[i].key!=key;i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><blockquote>
<p>每次将待查记录所在区间缩小一半</p>
</blockquote>
<p><strong>非递归算法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> Search <span class="title">Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    low = <span class="number">1</span>;high = ST.lenght;<span class="comment">//置区间初值</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.R[mid].key == key) <span class="keyword">return</span> mid;<span class="comment">//找到待查元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.R[mid].key)<span class="comment">//缩小查找区间</span></span><br><span class="line">            high = mid<span class="number">-1</span>;        <span class="comment">//继续在前半区间进行查找</span></span><br><span class="line">        <span class="keyword">else</span> low = mid+<span class="number">1</span>;       <span class="comment">//继续在后半区间进行查找  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//顺序表中不存在待查元素</span></span><br><span class="line">&#125;<span class="comment">//Search_Bin</span></span><br></pre></td></tr></table></figure></p>
<p><strong>递归算法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查找不到时返回0</span></span><br><span class="line">    mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==ST.elem[mid],key) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;ST.elem[mid].key)</span><br><span class="line">        <span class="built_in">Search_Bin</span>(SSTable ST,KeyType key,<span class="keyword">int</span> low,<span class="keyword">int</span> high);<span class="comment">//递归，在前半区间进行查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Search_Bin</span>(SSTable ST,KeyType key,<span class="keyword">int</span> mid,<span class="keyword">int</span> high);<span class="comment">//递归，在后半区间进行查找        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><blockquote>
<p>索引顺序查找 </p>
</blockquote>
<h1 id="数表的查找"><a href="#数表的查找" class="headerlink" title="数表的查找"></a>数表的查找</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>定义</strong>：<br>二叉排序树或是空树，或是满足如下性质的二叉树：</p>
<ul>
<li>若其 <strong>左子树</strong> 非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若其 <strong>右子树</strong> 非空，则右子树上所有结点的值均大于等于根结点的值</li>
<li>其左右子树本身又各是一棵二叉排序树</li>
</ul>
<p>对二叉排序树中序遍历，值递增</p>
<p><strong>二叉排序树的存储结构</strong>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">    InfoType otherinfo;<span class="comment">//其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;<span class="comment">//定义二叉排序树</span></span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>二叉排序树递归查找</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iT||key==T-&gt;data.key) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild,key);<span class="comment">//在左子树中继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild,key);<span class="comment">//在右子树中继续查找</span></span><br><span class="line">&#125;<span class="comment">//SearchBST</span></span><br></pre></td></tr></table></figure></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>若二叉排序树为空，则插入结点作为根节点插入到空树中</p>
<p>否则，继续在其左、右子树上查找</p>
<ul>
<li>树中已有，不再插入</li>
<li>树中没有<ul>
<li>查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li>
</ul>
</li>
</ul>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除后仍然保持是二叉排序树</p>
<p>三种情况：</p>
<ul>
<li>在叶子结点</li>
<li>有左孩子或右孩子</li>
<li>左右孩子都有</li>
</ul>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 (AVL)"></a>平衡二叉树 (AVL)</h2><p>一棵平衡二叉树或者空树，或者具有下列性质的二叉树：</p>
<ul>
<li>左子树与右子树的高度之差的绝对值 <strong>小于等于1</strong>；</li>
<li>左子树和右子树也是平衡二叉树</li>
</ul>
<p>为了方便起见，给每个结点附加一个数字，给出 <strong>该结点左子树与右子树的高度差</strong>，这个数字称为结点的 <strong>平衡因子</strong>（BF）</p>
<script type="math/tex; mode=display">平衡因子 = 节点左子树的深度 - 节点右子树的深度</script><h3 id="失衡二叉排序树的分析与调整"><a href="#失衡二叉排序树的分析与调整" class="headerlink" title="失衡二叉排序树的分析与调整"></a>失衡二叉排序树的分析与调整</h3><p>平衡调整的四种类型：<br><strong>LL型</strong></p>
<p><strong>LR型</strong></p>
<p><strong>RL型</strong></p>
<p><strong>RR型</strong></p>
<h1 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h1><h2 id="散列表基本概念"><a href="#散列表基本概念" class="headerlink" title="散列表基本概念"></a>散列表基本概念</h2><blockquote>
<p>基本思想：记录的存储位置与关键字之间存在对应关系</p>
</blockquote>
<p>优点：查找效率高</p>
<p>缺点：空间效率低</p>
<h2 id="散列表的若干术语"><a href="#散列表的若干术语" class="headerlink" title="散列表的若干术语"></a>散列表的若干术语</h2><p><strong>散列方法（杂凑法）</strong><br>选取某个函数，依该函数按关键字 <strong>计算元素的存储位置</strong>，并按此存放</p>
<p>查找时，<strong>由同一个函数对给定值k计算地址</strong>，将k与地址单元中元素关键码进行比对，确定查找是否成功</p>
<p><strong>散列函数（杂凑函数）</strong>：散列方法中使用的 <strong>转换函数</strong></p>
<p><strong>散列表（杂凑表）</strong>：按上述思想构造的表</p>
<p>散列函数：H(key)=k</p>
<p><strong>冲突</strong>：不同的关键码映射到同一个散列地址</p>
<p><strong>同义词</strong>：具有相同函数值的多个关键字</p>
<h2 id="散列表的构造方法"><a href="#散列表的构造方法" class="headerlink" title="散列表的构造方法"></a>散列表的构造方法</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p><strong>Hash(key)=a·key + b</strong></p>
<p>优点：以关键码key的某个线性函数值为散列地址，不会产生冲突</p>
<p>缺点：要占用连续空间，空间效率低</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p><strong>Hash(key)= key mod p</strong></p>
<p>技巧：设表长为m，<strong>取p&leqslant;m 且为质数</strong></p>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><h3 id="开地址法"><a href="#开地址法" class="headerlink" title="开地址法"></a>开地址法</h3><p>基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>基本思想：相同散列地址的记录链成一单链表</p>
<p><img style="transform=scale(0.7)" src="/2021/08/08/5-%E6%9F%A5%E6%89%BE/pic1.png"></p>
<p>优点：非同义词不会冲突，无“聚集”现象</p>
<h2 id="几点结论"><a href="#几点结论" class="headerlink" title="几点结论"></a>几点结论</h2><ul>
<li>散列表技术具有很好的平均性能，优于一些传统的技术</li>
<li>链地址法优于开地址法</li>
<li>除留余数法作散列函数优于其他类型函数</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.通用函数</title>
    <url>/2021/07/04/5-%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。</p>
<p><strong>一元ufunc</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abs、fabs</td>
<td style="text-align:left">计算整数、浮点数或复数的绝对值，对于非复数值，可以用更快的fabs</td>
</tr>
<tr>
<td style="text-align:left">sqrt</td>
<td style="text-align:left">计算各元素的平方根，相当于arr ** 0.5</td>
</tr>
<tr>
<td style="text-align:left">square</td>
<td style="text-align:left">计算元素的平方，相当于arr ** 2</td>
</tr>
<tr>
<td style="text-align:left">exp</td>
<td style="text-align:left">计算各元素的指数$e^x$</td>
</tr>
<tr>
<td style="text-align:left">log、log10</td>
<td style="text-align:left">分别为自然对数、以10为底的对数</td>
</tr>
<tr>
<td style="text-align:left">sign</td>
<td style="text-align:left">计算各元素的正负号：1（正），0（零），-1（负）</td>
</tr>
<tr>
<td style="text-align:left">ceil</td>
<td style="text-align:left">计算各元素的ceiling值，即大于等于该值的最小整数</td>
</tr>
<tr>
<td style="text-align:left">floor</td>
<td style="text-align:left">计算各元素的floor值，即小于等于该值的最大整数</td>
</tr>
<tr>
<td style="text-align:left">rint</td>
<td style="text-align:left">将各元素值四舍五入到最接近的整数，保留dtype</td>
</tr>
<tr>
<td style="text-align:left">modf</td>
<td style="text-align:left">将数组的小数和整数部分以两个独立数组的形式返回</td>
</tr>
<tr>
<td style="text-align:left">isnan</td>
<td style="text-align:left">返回一个表示“哪些值是NaN”的布尔型数组</td>
</tr>
<tr>
<td style="text-align:left">isfinite、isinf</td>
<td style="text-align:left">分别返回一个元素“哪些元素是有穷的”或“哪些元素是无穷的”的布尔型数组</td>
</tr>
<tr>
<td style="text-align:left">cos、cosh、sin、sinh、tan、tanh</td>
<td style="text-align:left">普通型和双曲型三角函数</td>
</tr>
<tr>
<td style="text-align:left">arccos、arccosh、arcsin、arcsinh…</td>
<td style="text-align:left">反三角函数</td>
</tr>
<tr>
<td style="text-align:left">logical_not</td>
<td style="text-align:left">计算各元素not x的真值，相当于~arr</td>
</tr>
</tbody>
</table>
</div>
<p><strong>二元ufunc</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add</td>
<td style="text-align:left">将数组中对应的元素相加</td>
</tr>
<tr>
<td style="text-align:left">subtract</td>
<td style="text-align:left">从第一个数组中减去第二个数组中的元素</td>
</tr>
<tr>
<td style="text-align:left">multiply</td>
<td style="text-align:left">数组元素相乘</td>
</tr>
<tr>
<td style="text-align:left">divide、floor_divide</td>
<td style="text-align:left">除法或向下圆整除法（丢弃余数）</td>
</tr>
<tr>
<td style="text-align:left">power</td>
<td style="text-align:left">对第一个数组中的元素A，根据第二个数组中的相应元素B，计算$A^B$</td>
</tr>
<tr>
<td style="text-align:left">maximum、fmax</td>
<td style="text-align:left">元素级的最大值计算，fmax将忽略NaN</td>
</tr>
<tr>
<td style="text-align:left">minmum、fmin</td>
<td style="text-align:left">元素级的最小值计算，fmin将忽略NaN</td>
</tr>
<tr>
<td style="text-align:left">mod</td>
<td style="text-align:left">元素级的求模运算（除法的余数）</td>
</tr>
<tr>
<td style="text-align:left">copysign</td>
<td style="text-align:left">将第二个数组中的符号复制给第一个数组中的值</td>
</tr>
<tr>
<td style="text-align:left">greater、greater_equal、less、less_equal、equal、not_equal</td>
<td style="text-align:left">执行元素级的比较运算符，相当于中缀运算符&gt;、&gt;=、&lt;、&lt;=、==、!=</td>
</tr>
<tr>
<td style="text-align:left">logical_and、loagical_or、logical_xor</td>
<td style="text-align:left">执行元素级的真值逻辑运算，相当于中缀运算符&amp;、&#124; 、^</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>5.向量空间</title>
    <url>/2021/06/21/5.%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><blockquote>
<p>{n维向量；+，数乘}</p>
</blockquote>
<h2 id="向量空间的子空间"><a href="#向量空间的子空间" class="headerlink" title="向量空间的子空间"></a>向量空间的子空间</h2><p>W是n维向量的非空集合，且</p>
<p>(1) $\forall\alpha,\beta\in W\;\Rightarrow\;\alpha+\beta\in W$<br><br>(2) $\forall\alpha\in W,\forall k\;\Rightarrow\;k\alpha\in W$</p>
<p>则称W是n维向量空间的子空间</p>
<h2 id="向量空间的基和维数"><a href="#向量空间的基和维数" class="headerlink" title="向量空间的基和维数"></a>向量空间的基和维数</h2><p>$\quad$如果向量空间V中的向量$\alpha_1\alpha_2\cdots\alpha_m$<br><br>满足：<br>$\qquad$(1)$\alpha_1\alpha_2\cdots\alpha_m$线性无关;<br><br>$\qquad$(2)V中任意向量$\beta$均可由$\alpha_1\alpha_2\cdots\alpha_m$线性表示，即<br><br>$\qquad\quad x_1\alpha_1+x_2\alpha_2+\cdots+x_m\alpha_m=\beta$</p>
<p>$\qquad$则称$\alpha_1\alpha_2\cdots\alpha_m$是向量空间V的基$\;\longrightarrow\;$其实就是向量组里极大无关组的概念</p>
<p>$\qquad$m称为向量空间的维数，称V是m维向量空间</p>
<h2 id="过渡矩阵"><a href="#过渡矩阵" class="headerlink" title="过渡矩阵"></a>过渡矩阵</h2><p>如果$\;\alpha_1,\alpha_2,\alpha_3\;$与$\;\beta_1,\beta_2,\beta_3\;$是$R^3$的两个基，<br></p>
<p>设<br>$<br>\beta_1={\large c}_{11}\alpha_1+{\large c}_{21}\alpha_2+{\large c}_{31}\alpha_3$</p>
<p>$\beta_2={\large c}_{12}\alpha_1+{\large c}_{22}\alpha_2+{\large c}_{32}\alpha_3$</p>
<p>$\beta_3={\large c}_{13}\alpha_1+{\large c}_{23}\alpha_2+{\large c}_{33}\alpha_3$<br><br><br>$<br>\begin{aligned}<br>即\;\;<br>[\beta_1\;\beta_2\;\beta_3]<br>&amp;=[\alpha_1\;\alpha_2\;\alpha_3]<br>\begin{bmatrix}<br>{\large c}_{11}&amp;{\large c}_{12}&amp;{\large c}_{13}\\<br>{\large c}_{21}&amp;{\large c}_{22}&amp;{\large c}_{23}\\<br>{\large c}_{31}&amp;{\large c}_{32}&amp;{\large c}_{33}<br>\end{bmatrix}\\<br>\\<br>&amp;=[\alpha_1\;\alpha_2\;\alpha_3]C<br>\end{aligned}<br>$<br><br><br>称矩阵C为由基$\;\alpha_1,\alpha_2,\alpha_3\;$到基$\;\beta_1,\beta_2,\beta_3\;$的过渡矩阵</p>
<h3 id="坐标变换公式"><a href="#坐标变换公式" class="headerlink" title="坐标变换公式"></a>坐标变换公式</h3><p>设$\;\alpha_1,\alpha_2,\alpha_3\;$与$\;\beta_1,\beta_2,\beta_3\;$是$R^3$的两个基<br>且$(\beta_1\;\beta_2\;\beta_3)=(\alpha_1\;\alpha_2\;\alpha_3)C$<br><br>若向量$\gamma$在这两个基下的坐标分别是</p>
<p>$(x_1,x_2,x_3)^T\;与\;(y_1,y_2,y_3)^T$</p>
<p>即<br>$\gamma=x_1\alpha_1+x_2\alpha_2+x_3\alpha_3=(\alpha_1\;\alpha_2\;\alpha_3)<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3<br>\end{bmatrix}$</p>
<p>$\gamma=y_1\beta_1+y_2\beta_2+y_3\beta_3=(\beta_1\;\beta_2\;\beta_3)<br>\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}$</p>
<p>那么<br>$<br>\qquad\begin{aligned}<br>(\alpha_1\;\alpha_2\;\alpha_3)<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3<br>\end{bmatrix}<br>&amp;=<br>(\beta_1\;\beta_2\;\beta_3)<br>\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}\\<br>&amp;=(\alpha_1\;\alpha_2\;\alpha_3)<br>C\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}<br>\end{aligned}<br>$<br><br></p>
<hr>
<p>$\therefore\;\;<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3<br>\end{bmatrix}=<br>C\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}<br>\longrightarrow$坐标变换公式<br><br>$\; x=Cy$</p>
<p>向量空间是属于n维向量中的内容，虽然目前知道了一些基本概念，但对n维空间理解的并不好，因此单独拿出来，后面进行单独的理解学习，并对笔记进行扩充</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>6.线性代数（numpy）</title>
    <url>/2021/07/05/6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88numpy%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="矩阵乘法-三种"><a href="#矩阵乘法-三种" class="headerlink" title="矩阵乘法(三种)"></a>矩阵乘法(三种)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">y = np.array([[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">x.dot(y)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.</span></span><br><span class="line">np.dot(x,y) </span><br></pre></td></tr></table></figure>
<pre><code>array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.</span></span><br><span class="line">x@y</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
</code></pre><h2 id="np-linalg"><a href="#np-linalg" class="headerlink" title="np.linalg"></a>np.linalg</h2><p>这里面有一组标准的矩阵分解运算以及诸如求逆和行列式之类的</p>
<p><strong>常用的线性代数的函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">diag</td>
<td style="text-align:left">以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一堆数组转换为方阵（非对角线元素为0）</td>
</tr>
<tr>
<td style="text-align:left">dot</td>
<td style="text-align:left">矩阵乘法</td>
</tr>
<tr>
<td style="text-align:left">trace</td>
<td style="text-align:left">计算对角线元素的和</td>
</tr>
<tr>
<td style="text-align:left">det</td>
<td style="text-align:left">计算矩阵行列式</td>
</tr>
<tr>
<td style="text-align:left">eig</td>
<td style="text-align:left">计算方阵的特征值和特征向量</td>
</tr>
<tr>
<td style="text-align:left">inv</td>
<td style="text-align:left">计算方阵的逆</td>
</tr>
<tr>
<td style="text-align:left">pinv</td>
<td style="text-align:left">计算矩阵的Moore-Penrose伪逆</td>
</tr>
<tr>
<td style="text-align:left">qr</td>
<td style="text-align:left">计算QR分解</td>
</tr>
<tr>
<td style="text-align:left">svd</td>
<td style="text-align:left">计算奇异值分解(SVD)</td>
</tr>
<tr>
<td style="text-align:left">solve</td>
<td style="text-align:left">解线性方程组Ax = b,其中A为一个方阵</td>
</tr>
<tr>
<td style="text-align:left">lstsq</td>
<td style="text-align:left">计算Ax=b的最小二乘解</td>
</tr>
</tbody>
</table>
</div>
<p><strong>例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [4, 5, 6],
       [9, 4, 5]])
</code></pre><ul>
<li>np.diag</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(A)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 5, 5])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(np.diag(A))</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 0, 0],
       [0, 5, 0],
       [0, 0, 5]])
</code></pre><ul>
<li>np.trace</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.trace(A)</span><br></pre></td></tr></table></figure>
<pre><code>11
</code></pre><ul>
<li>np.linalg.det</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.det(A)</span><br></pre></td></tr></table></figure>
<pre><code>-17.999999999999996
</code></pre><ul>
<li>np.linalg.inv</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.inv(A)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.05555556, -0.11111111,  0.16666667],
       [-1.88888889,  1.22222222, -0.33333333],
       [ 1.61111111, -0.77777778,  0.16666667]])
</code></pre><ul>
<li>np.linalg.eig</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eig(A)</span><br></pre></td></tr></table></figure>
<pre><code>(array([12.76913689, -2.36514612,  0.59600923]),
 array([[-0.28796344, -0.47551397,  0.10554127],
        [-0.67379758, -0.38580557, -0.83390437],
        [-0.68049532,  0.79059505,  0.54172368]]))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eigvals(A)</span><br></pre></td></tr></table></figure>
<pre><code>array([12.76913689, -2.36514612,  0.59600923])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eig(A)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.28796344, -0.47551397,  0.10554127],
       [-0.67379758, -0.38580557, -0.83390437],
       [-0.68049532,  0.79059505,  0.54172368]])
</code></pre><ul>
<li>np.linalg.solve</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">np.linalg.solve(A,B)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.22222222, -1.44444444,  1.55555556])
</code></pre><p>简单的使用了一下Numpy中关于线性代数的函数,也发现了一些问题，就是求行列式的值存在精度丢失，目前接触到的应用大概就这么多，当然后面会阅读一些文档对这一部分内容进行扩充</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>6.特征值与特征向量</title>
    <url>/2021/06/22/6.%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="向量的内积与正交矩阵"><a href="#向量的内积与正交矩阵" class="headerlink" title="向量的内积与正交矩阵"></a>向量的内积与正交矩阵</h1><h2 id="向量的内积"><a href="#向量的内积" class="headerlink" title="向量的内积"></a>向量的内积</h2><blockquote>
<p>设$\alpha=(a_1,a_2,\cdots,a_n)^T$ ,$\beta=(b_1,b_2,\cdots,b_n)$<br><br>令$[\alpha,\beta]=\large\sum\limits_{k=1}^{n}a_kb_k$<br><br>称为向量$\;\alpha\;$和$\;\beta\;$的内积</p>
</blockquote>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>$[\alpha,\beta]=[\beta,\alpha]$</li>
<li>$[\alpha+\beta,\gamma]=[\alpha,\gamma]+[\beta,\gamma]$</li>
<li>$[k\alpha,\beta]=k[\alpha,\beta]$</li>
<li>$[\alpha,\alpha]\geqslant0\;且\;[\alpha,\alpha]=0\;\Leftrightarrow\;\alpha=0$</li>
<li>柯西不等式$\;[\alpha,\beta]^2\leqslant[\alpha,\alpha][\beta,\beta]$<br><br>当且仅当$\;\alpha,\beta\;$线性相关时取等</li>
</ol>
<p>如果$\;[\alpha,\beta]=0\;$称$\;\alpha\;$与$\;\beta\;$正交</p>
<p><strong>柯西不等式的证明：</strong></p>
<p>$<br>\begin{aligned}<br>&amp;a. 若\;\alpha,\beta\;线性无关,\;\forall x\in R都有x\alpha+\beta\neq 0\\<br>&amp;\quad\; [x\alpha+\beta,x\alpha+\beta]\\<br>&amp;=[\alpha,\alpha]x^2+2[\alpha,\beta]x+[\beta,\beta]&gt;0\\<br>&amp;作为x的二次函数，对\forall x，f(x)&gt;0\\<br>&amp;故\;\;[2[\alpha,\beta]]^2-4[\alpha,\alpha][\beta,\beta]&lt;0\\<br>&amp;\therefore\;[\alpha,\beta]^2&lt;||\alpha||\cdot||\beta||\\<br>\end{aligned}<br>$</p>
<p>$<br>\begin{aligned}<br>&amp;b. 若\;\alpha,\beta\;线性相关\\<br>&amp;当\;\alpha=0（或\;\beta=0）\\<br>&amp;\qquad[\alpha,\beta]^2=||\alpha||\cdot||\beta||\\<br>&amp;当\beta=k\alpha\neq0\\<br>&amp;\qquad[\alpha,\beta]^2\\<br>&amp;=[\alpha,k\alpha]^2\\<br>&amp;=k^2[\alpha,\alpha]^2\\<br>&amp;=[\alpha,\alpha]\cdot[k\alpha,k\alpha]\\<br>&amp;=||\alpha||\cdot||\beta||<br>\end{aligned}<br>$</p>
<h2 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h2><blockquote>
<p>$||\alpha||=\sqrt{[\alpha,\alpha]}=\sqrt{\sum\limits_{k=1}^n{\large a}_k^2}$</p>
</blockquote>
<p>如果$||\alpha||=1\;$称$\;\alpha\;$为单位向量<br><br>$\displaystyle\frac{1}{||\alpha||}\alpha\;\longrightarrow$单位化<br><br></p>
<hr>
<p>定理：若n维向量$\alpha_1,\alpha_2,\cdots,\alpha_r$是一组两两正交的非零向量，<br>则$\alpha_1,\alpha_2,\cdots,\alpha_r$线性无关。</p>
<p>证：设$k_1\alpha_1+k_2\alpha_2+\cdots+k_r\alpha_r=0$</p>
<p>用$\alpha_1$对等式两边作内积</p>
<p>$\quad[\alpha_1,k_1\alpha_1+k_2\alpha_2+\cdots+k_r\alpha_r]=[\alpha_1,0]$</p>
<p>$\quad k_1[\alpha_1,\alpha_1]+\cdots+k_r[\alpha_1,\alpha_r]=0$</p>
<p>$\quad$因$\;\alpha_1\neq0,[\alpha_1,\alpha_1]&gt;0$<br>$\quad$而$\;[\alpha_1,\alpha_i]=0,i\geqslant2$</p>
<p>$\quad\therefore\;k_1[\alpha_1,\alpha_1]=0\;$必有$k_1=0$</p>
<p>$\quad$同理$\;k_2=0,\cdots,k_r=0$</p>
<h2 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h2><p>设$\alpha_1,\alpha_2,\alpha_3\;$线性无关</p>
<p>令$\quad\beta_1=\alpha_1$</p>
<p>$\quad\beta_2=\alpha_2-\displaystyle\frac{[\alpha_2\;\beta_1]}{[\beta_1\;\beta_1]}\beta_1$</p>
<p>$\quad\beta_3=\alpha_3-\displaystyle\frac{[\alpha_3\;\beta_1]}{[\beta_1\;\beta_1]}\beta_1-\displaystyle\frac{[\alpha_3\;\beta_2]}{[\beta_2\;\beta_2]}\beta_2$</p>
<p>则$\;\beta_1\;\beta_2\;\beta_3\;$两两正交<br><br><br>再单位化<br>$\qquad\gamma_1=\displaystyle\frac{\beta_1}{||\beta_1||}$,<br>$\gamma_2=\displaystyle\frac{\beta_2}{||\beta_2||}$,<br>$\gamma_3=\displaystyle\frac{\beta_3}{||\beta_3||}$</p>
<p>这样其实就相当于构建直角坐标系</p>
<h2 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h2><blockquote>
<p>设$A$是n阶矩阵，满足<br>$AA^T=A^TA=E$,<br>则称$A$为正交矩阵</p>
</blockquote>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>$A$是正交矩阵$\;\Leftrightarrow\;A^T=A^{-1}$</p>
</li>
<li><p>$A=(\alpha_1\;\alpha_2\;\alpha_3)$是正交矩阵<br>$\quad\Leftrightarrow\;\alpha_1,\alpha_2,\alpha_3\;$都是单位向量，且两两正交<br><br>证：<br>$<br>\begin{aligned}<br>A^TA<br>&amp;=\begin{bmatrix}<br> \alpha_1^T\\<br> \alpha_2^T\\<br> \alpha_3^T<br>\end{bmatrix}<br>[\alpha_1\;\alpha_2\;\alpha_3]\\<br>&amp;=\begin{bmatrix}    \alpha_1^T\alpha_1&amp;\alpha_1^T\alpha_2&amp;\alpha_1^T\alpha_3\\    \alpha_2^T\alpha_1&amp;\alpha_2^T\alpha_2&amp;\alpha_2^T\alpha_3\\<br>\alpha_3^T\alpha_1&amp;\alpha_3^T\alpha_2&amp;\alpha_3^T\alpha_3<br>\end{bmatrix}<br>=\begin{bmatrix}<br> 1&amp;0&amp;0\\<br> 0&amp;1&amp;0\\<br> 0&amp;0&amp;1<br>\end{bmatrix}\\<br>&amp;=E<br>\end{aligned}<br>$<br><br></p>
</li>
<li>如果$A$是正交矩阵，则$|A|$=1或-1<br><br></li>
<li>若$A,B$都是正交矩阵，则$AB$也是正交矩阵<br><br>证：<br>$(AB)(AB)^T=A(BB^T)A^T=AA^T=E$</li>
</ol>
<h3 id="规范正交基"><a href="#规范正交基" class="headerlink" title="规范正交基"></a>规范正交基</h3><p>设$e_1,e_2,\cdots,e_n$是向量空间的一个基，<br><br>如果<br>$\qquad[e_i,e_j]=<br>\begin{cases}<br>    1\qquad i=j\\<br>     0\qquad i\neq j<br>\end{cases}<br>$</p>
<p>$\qquad$则称$e_1,e_2,\cdots,e_n$为规范正交基。</p>
<p><strong>例</strong></p>
<p>$<br>A=\begin{bmatrix}<br>    1&amp;0&amp;0&amp;-2\\<br>    0&amp;1&amp;0&amp;1<br>\end{bmatrix}<br>$</p>
<p>$Ax=0\;$基础解系</p>
<p>$\eta_1=(0,0,1,0)^T,\eta_2=(2,-1,0,1)^T$</p>
<p>解空间的基：$\eta_1,\eta_2$</p>
<p>解空间维数：2</p>
<p>规范正交基：</p>
<p>$(0,0,1,0)^T,{\large\frac{1}{\sqrt{6}}}(2,-1,0,1)^T$</p>
<h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><blockquote>
<p>设A是n阶矩阵，<span class="mark">$\alpha$是n维非0列向量</span>，满足<br>$\qquad A\alpha=\lambda\alpha$<br><br>则称:<br>$\lambda$是矩阵$A$的特征值<br><br>$\alpha$是矩阵$A$对应于特征值$\lambda$的特征向量.</p>
</blockquote>
<p>$A\alpha=\lambda\alpha\;$这个等式个人直观理解：特征向量$\alpha$经过A矩阵变换后等于特征向量$\alpha$的$\lambda$倍</p>
<ol>
<li>如果$\alpha$是$A$对应于特征值$\lambda$的特征向量，<br><br>那么只要$k\neq0$,则$k\alpha$仍是$A$对应于特征值$\lambda$的特征向量<br><br>$\because\;$如果$\;A\alpha=\lambda\alpha,\;\alpha\neq0$<br><br>$\quad$那么$A(k\alpha)=kA\alpha=k(\lambda\alpha)=\lambda(k\alpha)$<br><br></li>
<li>若$\alpha_1,\alpha_2$都是矩阵$A$关于特征值$\lambda$的特征向量，<br><br>则$\;\forall k_1,k_2$，当$k_1\alpha_1+k_2\alpha_2\neq0$时，<br>$k_1\alpha_1+k_2\alpha_2$仍是$A$对应于$\lambda$的特征向量<br><br>由$A\alpha_1=\lambda\alpha_1,A\alpha_2=\lambda\alpha_2$<br><br><br>$<br>\begin{aligned}<br>得到： A(k_1\alpha_1+k_2\alpha_2)<br>&amp;=k_1A\alpha_1+k_2A\alpha_2\\<br>&amp;=k_1(\lambda\alpha_1)+k_2(\lambda\alpha_2)\\<br>&amp;=\lambda(k_1\alpha_1+k_2\alpha_2)\\<br>\end{aligned}<br>$</li>
</ol>
<h2 id="求解步骤和原理"><a href="#求解步骤和原理" class="headerlink" title="求解步骤和原理"></a>求解步骤和原理</h2><p>$\quad A\alpha=\lambda\alpha$</p>
<p>$\Rightarrow(\lambda E-A)\alpha=0$</p>
<p>$\quad\alpha\;$是$\;(\lambda E-A)x=0$的非零解</p>
<p>$\rightarrow\;|\lambda E-A|=0$</p>
<p>(1) 由$\;|\lambda E-A|=0\;$求特征值$\;\lambda_i$<br><br>$\quad$共n个(含重根)<br><br>(2) 由$\;(\lambda_iE-A)x=0\;$求基础解系<br><br>$\quad$即$\lambda_i$线性无关的特征向量</p>
<p><strong>例</strong><br>求<br>$<br>A=\begin{bmatrix}<br>    0&amp;2&amp;-2\\<br>     2&amp;4&amp;4\\<br>     -2&amp;4&amp;-3<br>\end{bmatrix}<br>$<br>特征值，特征向量</p>
<p>解：由特征多项式<br><br>$\quad\;<br>\begin{aligned}|\lambda E-A|<br>&amp;=\left|\begin{array}{ccc}<br>    \lambda&amp;-2&amp;2\\<br>    -2&amp;\lambda-4&amp;-4\\<br>     2&amp;-4&amp;\lambda+3<br>\end{array}\right|\\<br>&amp;=\left|\begin{array}{ccc}<br>    \lambda&amp;-2&amp;2-2\lambda\\<br>    -2&amp;\lambda-4&amp;0\\<br>     2&amp;-4&amp;\lambda-1<br>\end{array}\right|\\<br>&amp;=\left|\begin{array}{ccc}<br>    \lambda+4&amp;-10&amp;0\\<br>    -2&amp;\lambda-4&amp;0\\<br>     2&amp;-4&amp;\lambda-1<br>\end{array}\right|\\<br>&amp;=(\lambda-1)(\lambda^2-36)<br>\end{aligned}$<br><br><br>$\therefore\;A的特征值为\;1,\pm6$<br><br></p>
<ol>
<li>当$\;\lambda=1\;时,由\;(E-A)x=0$<br><br>$E-A=\begin{bmatrix}<br> 1&amp;-2&amp;2\\<br> -2&amp;-3&amp;-4\\<br> 2&amp;-4&amp;4<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br> 1&amp;0&amp;2\\<br> 0&amp;1&amp;0\\<br> 0&amp;0&amp;0<br>\end{bmatrix}$<br><br><br>$\qquad\therefore\;\alpha_1=(-2,0,1)^T$<br><br><br></li>
<li>当$\;\lambda=6\;时，由(6E-A)x=0$<br><br>$6E-A=\begin{bmatrix}<br> 6&amp;-2&amp;2\\<br> -2&amp;2&amp;-4\\<br> 2&amp;-4&amp;9<br>\end{bmatrix}<br>\stackrel{把第一行写成0,0,0} { \huge\longrightarrow }<br>\begin{bmatrix}<br> 0&amp;0&amp;0\\<br> -2&amp;2&amp;4\\<br> 2&amp;-4&amp;9<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br> 1&amp;-1&amp;2\\<br> 0&amp;-2&amp;5\\<br> 0&amp;0&amp;0<br>\end{bmatrix}$<br><br><br>$\qquad\therefore\;\alpha_2=(1,5,2)^T$<br><br><br></li>
<li>当$\lambda=-6时，由(-6E-A)x=0$<br><br>$-6E-A=\begin{bmatrix}<br> -6&amp;-2&amp;2\\<br> -2&amp;-10&amp;-4\\<br> 2&amp;-4&amp;-3<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br> 1&amp;1&amp;0\\<br> 0&amp;2&amp;1\\<br> 0&amp;0&amp;0<br>\end{bmatrix}$<br><br>$\quad\therefore\;\alpha_3=(-1,1,-2)^T$</li>
</ol>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><ol>
<li>设$A$是n阶矩阵<br><br>(1)$\;\sum\lambda_i=\sum {\large a}_{ii}=trA\;\rightarrow\;tr为矩阵的迹$<br><br>(2)$\;\prod\lambda_i=|A|$<br><br></li>
<li>$A$可逆$\;\Leftrightarrow\;$$A$的n个特征值全不为0<br><br></li>
<li>矩阵$A$对应于不同特征值的特征向量的特征向量是线性无关的<br><br><strong>证</strong>:$\quad$设$\lambda_1,\lambda_2,\cdots,\lambda_s$是矩阵$A$的S个不同的特征值，对应的特征向量分别是$\alpha_1,\alpha_2,\cdots,\alpha_s$<br><br>$\;$用数学归纳法<br><br>$\;那么,当S=1时，因\alpha_1\neq0,命题正确$<br><br>$\;假设S=k-1(k\geqslant2)时,结论成立$<br><br>$\;$当$S=k$时，<br>$x_1\alpha_1+x_2\alpha_2+\cdots+x_{k-1}\alpha_{k-1}+x_k\alpha_k=0\qquad(1)$<br><br>$\;用A左乘上式，有$<br><br>$\;x_1\lambda_1\alpha_1+x_2\lambda_2\alpha_2+\cdots+x_{k-1}\lambda_{k-1}\alpha_{k-1}+x_k\lambda_k\alpha_k=0\quad(2)$<br><br>$\;用\lambda_k乘(1)又有$<br><br>$\;x_1\lambda_k\alpha_1+x_2\lambda_k\alpha_2+\cdots+x_{k-1}\lambda_k\alpha_{k-1}+x_k\lambda_k\alpha_k=0\;\,\,\quad(3)$<br><br>$\;$(2)-(3):<br><br>$\;x_1(\lambda_1-\lambda_k)\alpha_1+x_2(\lambda_2-\lambda_k)\alpha_2+\cdots+x_{k-1}(\lambda_{k-1}-\lambda_k)\alpha_{k-1}=0$<br><br>$\;又因为\alpha_1,\alpha_2,\cdots,\alpha_{k-1}线性无关$<br><br>$\;所以x_1(\lambda_1-\lambda_k)=0,x_2(\lambda_2-\lambda_k)=0,\cdots,x_{k-1}(\lambda_{k-1}-\lambda_k)=0$<br><br>$\;因特征值\lambda_i\neq\lambda_j,从而\\<br>\quad x_1=0,x_2=0,\cdots,x_{k-1}=0$<br><br>$\;代入(1)式，得\\<br>\qquad x_k\alpha_k=0$<br><br>$\;因\;\alpha\neq0,\quad得\;x_k=0$<br><br>$\;故\alpha_1,\alpha_2,\cdots,\alpha_k线性无关$<br><br>所以当$S=k$时，命题成立<br><br>由数学归纳法可知对一切自然数，命题均成立。<br><br></li>
<li>若$\;A\alpha=\lambda\alpha,\alpha\neq0$<br><br>$(A+kE)\alpha=(\lambda+k)\alpha$<br><br></li>
<li>由$\;A\alpha=\lambda\alpha$<br><br>有$\;A^2\alpha=A(\lambda\alpha)=\lambda A\alpha=\lambda^2\alpha$<br><br>$\;\Rightarrow\;A^n\alpha^n=\lambda^n\alpha$<br><br></li>
<li>由$A\alpha=\lambda\alpha,A$可逆<br><br>可得到$A^{-1}\alpha=\displaystyle\frac{1}{\lambda}\alpha$<br><br>$\qquad\quad A^*\alpha=\displaystyle\frac{|A|}{\lambda}\alpha$</li>
</ol>
<h1 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h1><blockquote>
<p>设$A,B$都是n阶矩阵，如果存在可逆矩阵P,使得<br><br>$\qquad P^{-1}AP=B$<br><br>就称矩阵$A$相似于矩阵$B$，$B$是$A$的相似矩阵<br><br>记成$A\sim B$</p>
</blockquote>
<h2 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h2><ol>
<li>$A\sim B$<br><br></li>
<li>如果$A\sim B$,则$B\sim A$.<br><br></li>
<li>如果$A\sim B,B\sim C$则$\;A\sim C$.<br><br></li>
<li>如果$A\sim B$,那么<br><br>(1) $A^2\sim B^2$<br><br>(2) $A+kE\sim B+kE$<br><br>(3) 如果$A$可逆，则$\;A^{-1}\sim B^{-1}$<br><br>(4)如果$A_1\sim B_1,A_2\sim B_2$<br><br>$\quad$则$\;diag(A_1,A_2)\sim diag(B_1,B_2)$</li>
</ol>
<h2 id="两个矩阵相似的必要条件"><a href="#两个矩阵相似的必要条件" class="headerlink" title="两个矩阵相似的必要条件"></a>两个矩阵相似的必要条件</h2><p>如果$A\sim B$,</p>
<ol>
<li>$|\lambda E-A|=|\lambda E-B|\;\Rightarrow\lambda_A=\lambda_B$<br><br></li>
<li>$r(A)=r(B)$<br><br></li>
<li>$|A|=|B|$<br><br></li>
<li>$trA=trB\;\longrightarrow\;即\sum {\large a}_{ii}=\sum {\large b}_{ii}$</li>
</ol>
<h2 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h2><h3 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h3><p>$A\sim\land$$\;\Leftrightarrow\;$存在可逆矩阵$P$,使得$P^{-1}AP=\land$<br></p>
<p><strong>证</strong>:下面以三阶矩阵为例</p>
<p>首先将$P$按列分块<br><br>得到<br>$A(\alpha_1,\alpha_2,\alpha_3)=(\alpha_1,\alpha_2,\alpha_3)\;diag(a_1,a_2,a_3)$<br><br>即<br>$(A\alpha_1,A\alpha_2,A\alpha_3)=(a_1\alpha_1,a_2\alpha_2,a_3\alpha_3)$<br><br>$\therefore A\alpha_1=a_1\alpha_1\quad A\alpha_2=a_2\alpha_2\quad A\alpha_3=a_3\alpha_3$<br><br>$\qquad\downarrow$<br><br>不难发现，这就是特征值的定义形式<br>$\therefore A的特征值为:a_1,a_2,a_3\;\longrightarrow\;\land$<br><br>$\quad A的特征向量为:\alpha_1,\alpha_2,\alpha_3\rightarrow\; P$<br><br>$\therefore P$可逆$\;\Rightarrow\;|\alpha_1\;\alpha_2\;\alpha_3|\neq0\quad\alpha_1,\alpha_2,\alpha_3$线性无关<br><br>反之，若$A$有三个无关的特征向量$\;\alpha_1,\alpha_2,\alpha_3\;$,满足$\;A\alpha_i=\lambda_i\alpha_i\;(i=1,2,3)$</p>
<p>则有</p>
<p>$(A\alpha_1,A\alpha_2,A\alpha_3)$</p>
<p>$\begin{aligned}<br>&amp;=(\lambda_1\alpha_1,\lambda_2\alpha_2,\lambda_3\alpha_3)\\<br>&amp;=(\alpha_1,\alpha_2,\alpha_3)\;diag(\lambda_1,\lambda_2,\lambda_3)<br>\end{aligned}<br>$<br><br>即得到$\;AP=P\land$<br><br>$\therefore\;P^{-1}AP=\land=diag(\lambda_1,\lambda_2,\lambda_3)$<br><br>其实这就很容易看出此问题最终还是转化为特征值特征向量问题<br></p>
<p>定理:$A\sim\land\Longleftrightarrow$ $A$有n个线性无关的特征向量<br><br>如果$A$有n个不同的特征值，则$A\sim\land$</p>
<h3 id="求-A-n-的方法"><a href="#求-A-n-的方法" class="headerlink" title="求$A^n$的方法"></a>求$A^n$的方法<br></h3><p>$\because P^{-1}A^nP=\land^n$<br><br>$\therefore A^n=P\land^n P^{-1}$</p>
<p><strong>方法虽然不难，但是需要耐心和仔细！！</strong></p>
<h1 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h1><blockquote>
<p>若$A$矩阵的元素都是实数，且A的转置等于它本身，则称$A$为是对称矩阵</p>
</blockquote>
<h2 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h2><ol>
<li>若$A$是n阶实对称矩阵,则$A$的特征值都是<strong>实数</strong><br><br></li>
<li>$\lambda_1$与$\lambda_2$是$A$不同的特征值，$\alpha_1,\alpha_2$分别是属于$\lambda_1$与$\lambda_2$的特征向量，则$\alpha_1$与$\alpha_2$正交<br><br><br><strong>证</strong> 2：<br>$由A\alpha_1=\lambda_1\alpha_1,A\alpha_2=\lambda_2\alpha_2,\lambda_1\neq\lambda_2$ $\;\rightarrow\;[\alpha_1,\alpha_2]=\alpha_1^T\alpha_2=\alpha_2^T\alpha_1$<br><br>$<br>\begin{aligned}<br>\qquad\lambda_1\alpha_2^T\alpha_1<br>&amp;=\alpha_2^T A\alpha_1\;\rightarrow\;用\alpha_2^T来乘\\<br>&amp;=\alpha_2^T A^T\alpha_1\\<br>&amp;=(A\alpha_2)^T\alpha_1\\<br>&amp;=(\lambda_2\alpha_2)^T\alpha_1\\<br>&amp;=\lambda_2\alpha_2^T\alpha_1<br>\end{aligned}<br>$<br><br>$\quad\therefore\;(\lambda_1-\lambda_2)\alpha_2^T\alpha_1=0$<br><br>$\quad\therefore\;\alpha_2^T\alpha_1=0$<br><br></li>
<li>对任意一个n阶实对称矩阵$A$,总存在n阶 <strong>正交矩阵</strong> $\;Q$，使得<br><br>$\qquad\qquad Q^{-1}AQ=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>$\qquad$证明用数学归纳法<br><br>大体思路是：因为要证明的$Q$是正交矩阵，所以可以构造出来一组规范正交基，将$A\alpha_i$表示出来，从而就能构造出$AP=PB$这种形式，下面只需要说明$B$这个矩阵能够进行相似对角化，且是通过正交矩阵相似对角化，其中不要忘记使用正交矩阵的性质$A^{-1}=A^T$。<br><br></li>
<li>n=1成立<br><br></li>
<li>假设n-1成立<br><br>那么n时<br><br>$A\alpha_1=\lambda_1\alpha_1,将\alpha_1扩展到R^n，取一组单位正交基\alpha_1,\alpha_2,\cdots,\alpha_n$<br><br>$由A\alpha_1=\lambda_1\alpha_1 \;\rightarrow\; 因为A\alpha_1是空间里的一个向量，那么A\alpha_2\cdots也能用规范正交基表示$<br><br>$可得A\alpha_2=b_{12}\alpha_1+b_{22}\alpha_2+\cdots+b_{n2}\alpha_n\quad\rightarrow\;正交基的系数用字母代替，不需要具体表示$<br><br>$\qquad\qquad\qquad\cdots$<br><br>$\qquad A\alpha_2=b_{1n}\alpha_1+b_{2n}\alpha_2+\cdots+b_{nn}\alpha_n$<br><br>将上式用矩阵表示，并用分块矩阵的知识将矩阵分成四块<br><br>$A(\alpha_1,\alpha_2,\cdots,\alpha_n)=(\alpha_1,\alpha_2,\cdots,\alpha_n)<br>\begin{bmatrix}<br> \lambda_1&amp;b\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>$令(\alpha_1,\alpha_2,\cdots,\alpha_n)=Q_1$<br>$得到AQ_1=Q_1<br>\begin{bmatrix}<br> \lambda_1&amp;b\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>$即Q_1^{-1}AQ_1=<br>\begin{bmatrix}<br> \lambda_1&amp;b\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>两边同时转置(注意正交矩阵的性质:$\;Q_1^{-1}=Q^T$)<br><br>$[Q_1^{-1}AQ_1]^T=Q_1^{-1}AQ_1=<br>\begin{bmatrix}<br> \lambda_1&amp;0\\<br>  b^T&amp;B^T\\<br>\end{bmatrix}\;\rightarrow这是一个对称矩阵<br>$<br><br>$\therefore\;b=b^T=0,B=B^T,即B是n-1阶实对称矩阵$<br><br>$\therefore\;Q_1^{-1}AQ_1=<br>\begin{bmatrix}<br> \lambda_1&amp;0\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>因为B是个n-1阶实对称矩阵，所以按归纳假设B一定可以用正交矩阵相似对角化<br><br>现在假设这个正交矩阵为$P$<br><br>$那么可得到\;P^{-1}BP=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>$<br>然后令Q_2=<br>\begin{bmatrix}<br> 1&amp;0\\<br> 0&amp;P\\<br>\end{bmatrix}\;\rightarrow\;这个分块矩阵的构造可通过矩阵变换的思想理解<br>$<br><br>其实这里也可以用相似矩阵的性质：<br>如果$A_1\sim B_1,A_2\sim B_2$<br><br>$\quad$则$\;diag(A_1,A_2)\sim diag(B_1,B_2)$<br><br><br>$那么Q_2^{-1}Q_1^{-1}AQ_1Q_2=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>$令Q=Q_1Q_2,则Q^{-1}=Q_2^{-1}Q_1^{-1}$<br><br>$因为Q_1，Q_2是正交矩阵,所以Q是正交矩阵\;\rightarrow\;正交矩阵的性质$<br><br>$\therefore\;Q^{-1}AQ=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>即n时结论成立<br><br>那么可得到结论成立<br>   </li>
</ol>
<h2 id="求解是对称矩阵相似对角化的步骤"><a href="#求解是对称矩阵相似对角化的步骤" class="headerlink" title="求解是对称矩阵相似对角化的步骤"></a>求解是对称矩阵相似对角化的步骤</h2><ul>
<li>求特征值  </li>
<li>求特征向量  </li>
<li>改造特征向量  <ul>
<li>$\lambda_i\neq\lambda_j$只需单位化  </li>
<li>$\lambda_i=\lambda_j$<ul>
<li>$[\alpha_i,\alpha_j]=0$只需单位化  </li>
<li>$[\alpha_i,\alpha_j] \neq0$施密特正交化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>特征值与特征向量$\;\rightarrow\;$相似对角化$\;\rightarrow\;$实对称矩阵相似对角化$\;\rightarrow\;$二次型的正交变换法</p>
<p>线性代数最核心的就是矩阵和行列式，由此衍生出其他的东西，之间其实联系还是很紧密的。而这一章核心就是特征值与特征向量，其实特征值可以理解为特征向量经过矩阵变换后的伸缩倍数，还有一些工具像施密特正交化，也给了一些其他概念，比如向量的内积(通过内积来理解柯西不等式感觉挺不错)，正交矩阵，相似矩阵，实对称矩阵，而这一章通过这些概念工具就能够让一些矩阵相似对角化。虽然清楚这些概念，但是对于特征值这个特征的理解总感觉缺少了什么，以前学习微分方程的时候有特征方程这个概念，究竟这两个特征的本质是否是同一个概念，后面继续进行学习研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>6.CSS浮动</title>
    <url>/2021/07/20/6-CSS%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div style="width: 200px;height: 200px;"><div style="float: left;width: 100px;height: 100px;background: rgba(0,0,0,.1);"></div><div style="float: right;width: 100px;height: 100px;background: rgba(0,0,0,.3);"></div><div style="float: left;width: 100px;height: 100px;background: rgba(0,0,0,.5);"></div><div style="float: right;width: 100px;height: 100px;background: rgba(0,0,0,.7);"></div></div>

<h1 id="浮动的用法"><a href="#浮动的用法" class="headerlink" title="浮动的用法"></a>浮动的用法</h1><p><strong>float</strong> 属性用于创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘</p>
<p>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">float</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left">元素不浮动（默认）</td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">元素向左浮动</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">元素向右浮动</td>
</tr>
</tbody>
</table>
</div>
<h1 id="浮动的特性"><a href="#浮动的特性" class="headerlink" title="浮动的特性"></a>浮动的特性</h1><p>1.浮动元素会脱离标准流（脱标）</p>
<p>2.浮动的元素会一行内显示并且元素顶部对齐</p>
<p>3.浮动的元素会具有行内块元素的特性</p>
<hr>
<p>设置了浮动（float）的元素 <strong>最重要</strong> 的特性：</p>
<p>1.脱离标准流的控制（浮）移动到指定位置（动），（俗称脱标）</p>
<p>2.浮动的盒子不再保留原先位置</p>
<h1 id="浮动布局的注意点"><a href="#浮动布局的注意点" class="headerlink" title="浮动布局的注意点"></a>浮动布局的注意点</h1><p><strong>1.浮动和标准流的父盒子搭配</strong><br>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</p>
<p><strong>2.一个元素浮动了，理论上其余的兄弟元素也要浮动</strong><br>一个元素里面有多个子盒子，如果其中一个盒子浮动了 ，那么其他兄弟也应该浮动，否则会出现错误。</p>
<p>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。</p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>如果 <strong>父类盒子没有高度</strong>，由于子盒子浮动不占有位置，最后父级盒子高度为0，那么就会影响下面的标准流盒子，从而影响排版。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1.<strong>额外标签法</strong> 也称为隔离法，是W3C推荐的做法。</p>
<p>2.<strong>父级</strong> 添加overflow属性</p>
<p>3.<strong>父级</strong> 添加after伪元素</p>
<p>4.<strong>父级</strong> 添加双伪元素</p>
<p>策略：<strong>闭合浮动</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">clear</span>: 属性值 &#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">不允许有左侧浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td style="text-align:left">both</td>
<td style="text-align:left">同时清楚左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
</div>
<p>实际工作中几乎只用 <strong>clear: both;</strong></p>
<h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><p>额外标签法就是在浮动元素末尾添加一个空的标签。例如&lt;div style=”clear: both”&gt;&lt;/div&gt;,或者其他标签（如&lt;br/&gt;等）。</p>
<ul>
<li>优点：通俗易懂，书写方便</li>
<li>缺点：添加许多无意义的标签，结构化较差<br><strong>注意:这个新的空标签必须是块级元素</strong></li>
</ul>
<h3 id="父级添加overflow"><a href="#父级添加overflow" class="headerlink" title="父级添加overflow"></a>父级添加overflow</h3><p>可以给 <strong>父级</strong> 添加overflow属性，将其属性值设置为hidden、auto或scroll</p>
<ul>
<li>优点：代码简洁</li>
<li>缺点：无法显示溢出部分</li>
</ul>
<h3 id="after伪元素法"><a href="#after伪元素法" class="headerlink" title=":after伪元素法"></a>:after伪元素法</h3><p>:after方式是额外标签的升级版，也是给父元素添加<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;<span class="comment">/*IE6、7专有*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优点：没有增加标签，结构更简单</li>
<li>缺点：照顾低版本浏览器</li>
<li>代表网站：百度、淘宝网、网易等</li>
</ul>
<h3 id="双伪元素清除浮动"><a href="#双伪元素清除浮动" class="headerlink" title="双伪元素清除浮动"></a>双伪元素清除浮动</h3><p>也是给父元素添加<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before,.clearfix:after &#123;</span><br><span class="line">    content:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优点：代码更简洁</li>
<li>缺点：照顾低版本浏览器</li>
<li>代表网站：小米、腾讯等</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>7.CSS 定位</title>
    <url>/2021/07/20/7-CSS%E7%9A%84%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="定位的组成"><a href="#定位的组成" class="headerlink" title="定位的组成"></a>定位的组成</h1><p><strong>定位:</strong> 将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子</p>
<p><strong>定位 = 定位模式 + 边偏移</strong></p>
<p>定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置</p>
<p><strong>1、定位模式</strong><br>定位模式决定元素的定位方式，它通过CSS 的 <strong>position</strong> 属性来设置，其值可以分为四个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">语义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">static</td>
<td style="text-align:left">静态定位</td>
</tr>
<tr>
<td style="text-align:left">relative</td>
<td style="text-align:left">相对定位</td>
</tr>
<tr>
<td style="text-align:left">absolute</td>
<td style="text-align:left">绝对定位</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">固定定位</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2、边偏移</strong><br>边偏移就是定位的盒子移动到最终位置，有top、bottom、left和right4个属性 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">边偏移属性</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">top: 80px</td>
<td style="text-align:left">顶端偏移量</td>
</tr>
<tr>
<td style="text-align:left">bottom</td>
<td style="text-align:left">bottom: 80px</td>
<td style="text-align:left">底部偏移量</td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">left: 80px</td>
<td style="text-align:left">左侧偏移量</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">right: 80px</td>
<td style="text-align:left">右侧偏移量</td>
</tr>
</tbody>
</table>
</div>
<h1 id="静态定位（了解）"><a href="#静态定位（了解）" class="headerlink" title="静态定位（了解）"></a>静态定位（了解）</h1><p>静态定位就是元素的默认定位方式，无定位的意思<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; positon: static; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>静态定位按照标准流特性摆放位置，它没有边偏移</li>
<li>静态定位在布局时很少用到</li>
</ul>
<h1 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h1><p>相对定位是元素在移动位置的时候，是相对于他原来位置来说的<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: relative; &#125;</span><br></pre></td></tr></table></figure><br><strong>特点:</strong></p>
<ul>
<li>它是相对于原来的位置移动的</li>
<li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它</li>
</ul>
<h1 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h1><p>相对定位是元素在移动位置的时候，是相对于它祖先元素来说的<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure><br><strong>特点:</strong></p>
<ul>
<li>如果 <strong>没有祖先元素</strong> 或者 <strong>祖先元素没有定位</strong>，则以浏览器为准定位（Document文档）</li>
<li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li>
<li>绝对定位不在占有原来的位置（脱标）</li>
</ul>
<h1 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h1><p><strong>意思：</strong> 子集是绝对定位的话，父级要用相对定位</p>
<ul>
<li>自己相对定位，不会占有位置，可以放到父盒子里面的任何地方，不会影响其他兄弟盒子</li>
<li>父盒子需要加定位限制子盒子在父盒子内显示</li>
<li>父盒子布局时，需要占有位置，因此父盒子只能是相对定位</li>
</ul>
<h1 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h1><p>固定定位是元素固定于浏览器可视区的位置。主要适用场景：可以在浏览器页面滚动时元素的位置不会改变</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: fixed;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点:</strong><br>1.以浏览器的可视窗口为参照点移动元素</p>
<ul>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动</li>
</ul>
<p>2.固定定位不占有原来位置</p>
<p>固定定位也是脱标的，其实固定定位也可以看作是一种特殊的绝对定位</p>
<h2 id="固定定位小技巧"><a href="#固定定位小技巧" class="headerlink" title="固定定位小技巧"></a>固定定位小技巧</h2><p>固定在版心右侧位置</p>
<p><strong>小算法:</strong></p>
<p>1、让固定定位的盒子left:50%，走到浏览器可视区（也可以看作版心）的一半位置</p>
<p>2、让固定定位的盒子margin-left:版心宽度的一半距离</p>
<h1 id="粘性定位-sticky（了解）"><a href="#粘性定位-sticky（了解）" class="headerlink" title="粘性定位 sticky（了解）"></a>粘性定位 sticky（了解）</h1><p>粘性定位可以被认为是相对定位和绝对定位的混合。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: sticky; <span class="attribute">top</span>:<span class="number">10px</span>; &#125;</span><br></pre></td></tr></table></figure><br>特点：</p>
<p>1.以浏览器的可视窗口为参照点移动元素（固定定位特点）</p>
<p>2.粘性定位占有原先的位置（相对定位的特点）</p>
<p>3.必须添加top、left、right、bottom其中的一个才有效</p>
<p>跟页面滚动搭配使用，兼容性较差，IE不支持。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">定位模式</th>
<th style="text-align:left">是否脱标</th>
<th style="text-align:left">移动位置</th>
<th style="text-align:left">是否常用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">static静态定位</td>
<td style="text-align:left">否</td>
<td style="text-align:left">不能使用边偏移</td>
<td style="text-align:left">很少</td>
</tr>
<tr>
<td style="text-align:left">relative相对定位</td>
<td style="text-align:left">否（占有位置）</td>
<td style="text-align:left">相对于自身位置移动</td>
<td style="text-align:left">常用</td>
</tr>
<tr>
<td style="text-align:left">absolute绝对定位</td>
<td style="text-align:left">是（不占有位置）</td>
<td style="text-align:left">带有定位的父级</td>
<td style="text-align:left">常用</td>
</tr>
<tr>
<td style="text-align:left">fixed固定定位</td>
<td style="text-align:left">是（不占有位置）</td>
<td style="text-align:left">浏览器可视区</td>
<td style="text-align:left">常用</td>
</tr>
<tr>
<td style="text-align:left">sticky粘性定位</td>
<td style="text-align:left">否（占有位置）</td>
<td style="text-align:left">浏览器可视区</td>
<td style="text-align:left">当前阶段少</td>
</tr>
</tbody>
</table>
</div>
<h1 id="定位叠放次序-z-index"><a href="#定位叠放次序-z-index" class="headerlink" title="定位叠放次序 z-index"></a>定位叠放次序 z-index</h1><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以用z-index来控制盒子的前后次序（z轴）<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">z-index</span>: <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>数值可以是正整数、负数或0，默认是auto，数值越大，盒子越靠上</li>
<li>如果属性值是相同，按照书写顺序，后来居上</li>
<li>数字后面不能加单位</li>
<li>只有定位的盒子才有z-index属性</li>
</ul>
<h1 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h1><h2 id="绝对定位的盒子居中"><a href="#绝对定位的盒子居中" class="headerlink" title="绝对定位的盒子居中"></a>绝对定位的盒子居中</h2><p>加了绝对定位的盒子不能通过margin:0 auto水平居中，但是可以通过以下计算方法实现水平和垂直居中。</p>
<ul>
<li>left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。</li>
<li>margin-left: 盒子自身宽度的一半。</li>
</ul>
<h2 id="定位特殊性"><a href="#定位特殊性" class="headerlink" title="定位特殊性"></a>定位特殊性</h2><p>绝对定位和固定定位也和浮动类似。</p>
<ol>
<li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度。</li>
<li>块级元素添加绝对或者固定定位，如果不给宽度或高度，默认大小是内容的大小。</li>
</ol>
<h2 id="脱标的盒子不会触发外边距塌陷"><a href="#脱标的盒子不会触发外边距塌陷" class="headerlink" title="脱标的盒子不会触发外边距塌陷"></a>脱标的盒子不会触发外边距塌陷</h2><p>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题。</p>
<h2 id="绝对定位（固定定位）会完全压住盒子"><a href="#绝对定位（固定定位）会完全压住盒子" class="headerlink" title="绝对定位（固定定位）会完全压住盒子"></a>绝对定位（固定定位）会完全压住盒子</h2><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p>
<p>但是绝对定位（固定定位）会压住下面标准流的所有内容。</p>
<p>浮动之所以不会压住文字，是因为浮动产生的目的最初是为了作文字环绕效果的。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>7.二次型</title>
    <url>/2021/06/23/7.%E4%BA%8C%E6%AC%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><ol>
<li>二次型的矩阵表示<br>$f(x_1,x_2,x_3)$<br><br>$\begin{aligned}<br>&amp;=x_1^2+5x_2^2-4x_3^2-2x_1x_2+6x_2x_3\\<br>&amp;=[x_1\;x_2\;x_3]<br>\begin{bmatrix}<br> 1&amp;-1&amp;0\\<br> -1&amp;5&amp;3\\<br> 0&amp;3&amp;-4<br>\end{bmatrix}<br>\begin{bmatrix}<br> x_1\\<br> x_2\\<br> x_3<br>\end{bmatrix}\\<br>&amp;=x^TAx<br>\end{aligned}<br>$<br><br>其中$A$是对称矩阵，即$A^T=A$<br><br>此矩阵称为二次型矩阵<br><br></li>
<li>标准形<blockquote>
<p>二次型只有平方项<br><br>例如，$x_1^2+x_2^2-4x_3^2$<br><br></p>
</blockquote>
</li>
<li>规范形<blockquote>
<p>标准型里面平方项系数只有$\pm1或0$<br><br>例如，$x_1^2-x_2^2+x_4^2$<br><br></p>
</blockquote>
</li>
<li>正惯性指数p，负惯性指数q，符号差<blockquote>
<p>p,q就是标准形系数正负个数<br><br>符号差就是p-q<br><br>例$x_1^2+x_2^2-4x_3^2\quad$</p>
<p>正惯性指数=2，负惯性指数=1,符号差=1<br><br></p>
</blockquote>
</li>
<li>二次型的秩<blockquote>
<p>$r(f)=r(A)$<br><br></p>
</blockquote>
</li>
<li>坐标变换<br>即$x=Cy$<br><br>这里可以参照向量空间坐标变换公式，注意$|C|\neq0$<br><br></li>
<li>合同<blockquote>
<p>如果$C^TAC=B$,其中$C$可逆矩阵<br><br>称矩阵A和B合同，记作$A\simeq B$</p>
</blockquote>
</li>
</ol>
<h2 id="标准形"><a href="#标准形" class="headerlink" title="标准形"></a>标准形</h2><p>方法：<br>1.配方法；2.正交变换法</p>
<h3 id="配方法"><a href="#配方法" class="headerlink" title="配方法"></a>配方法</h3><ul>
<li><strong>例</strong> ：化二次型<br>$\quad f=x_1^2+2x_2^2+5_3^2+2x_1x_2+2x_1x_3+6x_2x_3$成标准形，并写出所用坐标变换。<br><br>解：<br>$\begin{aligned}<br>f<br>&amp;=x_1^2+2x_1x_2+2x_1x_3+2x_2^25x_3^2+6x_2x_3\\<br>&amp;=[x_1^2+2x_1(x_2+x_3)+(x_2+x_3)^2]\\<br>&amp;\quad -(x_2+x_3)^2+2x_2^2+5x_3^2+6x_2x_3\\<br>\\<br>&amp;=(x_1+x_2+x_3)^2+x_2^2+4x_2x_3+4x_3^2\\<br>&amp;=(x_1+x_2+x_3)^2+(x_2+x_3)^2<br>\end{aligned}<br>$<br><br>令<br>$<br>\begin{cases}<br>y_1=x_1+x_2+x_3\\<br>y_2=x_2+x_3\\<br>y_3=x_3<br>\end{cases}<br>$<br><br>即<br>$<br>\begin{cases}<br>x_1=y_1-y_2+y_3\\<br>x_2=y_2-2y_3\\<br>x_3=y_3<br>\end{cases}<br>$<br><br>坐标变换公式<br>$x=Cy$<br><br>$C=<br>\begin{bmatrix}<br>  1&amp;-1&amp;1\\<br>  0&amp;1&amp;-2\\<br>  0&amp;0&amp;1<br>\end{bmatrix}<br>$<br><br>得$f=y_1^2+y_2^2$</li>
</ul>
<h3 id="正交变换法"><a href="#正交变换法" class="headerlink" title="正交变换法"></a>正交变换法</h3><blockquote>
<p>定理：任意一个二次型$f=x^TAx$，其中$A^T=A$,总存在正交变换$x=py$,(其中$P$是正交矩阵)，使二次型化为标准形<br><br>$\quad x^TAx=y^T\land y=\lambda_1y_1^2+\cdots+\lambda_n y_n^2$<br><br>($\lambda$是A的特征值)</p>
</blockquote>
<ul>
<li><strong>证</strong>：<br>首先要知道二次型中$A$是实对称矩阵<br><br>因为实对称矩阵，$Q^{-1}AQ=\land$<br><br>$Q$是正交矩阵(则$Q^T=Q^{-1}$)<br><br>所以$Q^TAQ=\land$<br><br>若令$x=Qy$,则<br><br>$<br>\begin{aligned}<br>x^TAx<br>&amp;=(Qy)^TA(Qy)\\<br>&amp;=y^TQ^TAQy\\<br>&amp;=y^T\land y\\<br>&amp;=\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2<br>\end{aligned}<br>$</li>
</ul>
<p><strong>例</strong>：将二次型<br>$f=x_1^2+x_2^2+x_3^2+4x_1x_2+4x_1x_3+4x_2x_3$<br>用正交变换化成标准形，并写出所用坐标变换。</p>
<p><strong>解</strong>：二次型矩阵为<br>$<br>A=<br>\begin{bmatrix}<br>1&amp;2&amp;2\\<br>2&amp;1&amp;2\\<br>2&amp;2&amp;1<br>\end{bmatrix}<br>$</p>
<p>由特征多项式<br>$<br>\begin{aligned}<br>|\lambda E-A|<br>&amp;=\left|\begin{array}{ccc}<br>\lambda-1&amp;-2&amp;-2\\<br>-2&amp;\lambda-1&amp;-2\\<br>-2&amp;-2&amp;\lambda-1<br>\end{array}\right|\\<br>&amp;=(\lambda-5)(\lambda+1)^2<br>\end{aligned}<br>$</p>
<p>$\therefore A$的特征值为5，-1，-1</p>
<p>$\lambda=5$时，由$(5E-A)x=0$<br><br>得<br>$<br>\begin{bmatrix}<br>4&amp;-2&amp;-2\\<br>-2&amp;4&amp;-2\\<br>-2&amp;-2&amp;4<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br>1&amp;0&amp;-1\\<br>0&amp;1&amp;-1\\<br>0&amp;0&amp;0<br>\end{bmatrix}<br>$</p>
<p>$得到\alpha_1=(1,1,1)^T$</p>
<p>$\lambda=-1$时，由$(-E-A)x=0$</p>
<p>得<br>$<br>\begin{bmatrix}<br>-2&amp;-2&amp;-2\\<br>-2&amp;-2&amp;-2\\<br>-2&amp;-2&amp;-2<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br>1&amp;1&amp;1\\<br>0&amp;0&amp;0\\<br>0&amp;0&amp;0<br>\end{bmatrix}<br>$</p>
<p>得$\alpha_2=(-1,1,0)^T，\alpha_3=(-1,0,1)^T$</p>
<p>因为这两个向量不垂直</p>
<p>$\therefore 将\alpha_2,\alpha_3$施密特正交化</p>
<p>$\beta_2=\alpha_2=\begin{bmatrix}-1\\1\\0\end{bmatrix}$</p>
<p>$<br>\beta_3=\alpha_3-\displaystyle\frac{ [\alpha_3\;\beta_2] }{ [\beta_2\;\beta_3] }\beta_2<br>=\frac12\begin{bmatrix}-1\\ -1\\2\end{bmatrix}<br>$</p>
<p>单位化</p>
<p>$<br>\gamma_1=\displaystyle\frac{1}{\sqrt{3} }\begin{bmatrix}1\\1\\1\end{bmatrix},<br>\gamma_2=\displaystyle\frac{1}{\sqrt{2} }\begin{bmatrix}-1\\1\\0\end{bmatrix},$<br>$\gamma_3=\displaystyle\frac{1}{\sqrt{6} }\begin{bmatrix}-1\\ -1\\2\end{bmatrix}$</p>
<p>令<br>$<br>\;P=(\gamma_1\;\gamma_2\;\gamma_3)<br>=\begin{bmatrix}<br>\displaystyle\frac{1}{\sqrt{3} }&amp;-\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp;\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp; 0 &amp;\displaystyle\frac{2}{\sqrt{6} }<br>\end{bmatrix}<br>$</p>
<p>那么，二次型$x^TAx$经正交变换</p>
<p>$<br>\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=<br>\begin{bmatrix}<br>\displaystyle\frac{1}{\sqrt{3} }&amp;-\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp;\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp; 0 &amp;\displaystyle\frac{2}{\sqrt{6} }<br>\end{bmatrix}<br>\begin{bmatrix}y_1\\y_2\\y_3\end{bmatrix}<br>$</p>
<p>化为标准形</p>
<p>$f=x^TAx=y^T\land y=5y_1^2-y_2^2-y_3^2$</p>
<p>二次型求规范形的求解步骤其实可以参照前面实对称矩阵相似对角化求解步骤</p>
<p><strong>推论：</strong></p>
<p>任意一个n元二次型$f=x^TAx$都存在坐标变换$x=Cz$使$f$化为规范形</p>
<ul>
<li><strong>例</strong>:<br>$f=y_1^2+3y_2^2-2y_3^2$<br><br>令<br>$\begin{cases}<br>y_1=z_1\\<br>y_2=\displaystyle\frac{1}{\sqrt{3} }z_2\\<br>y_3=\displaystyle\frac{1}{\sqrt{2} }z_3<br>\end{cases}<br>$<br><br>那么$f=z_1^2+z_2^2-z_3^2$</li>
</ul>
<p>变成规范形步骤：</p>
<p>(配方法，正交变换法)$\;\rightarrow\;$标准形$\;\rightarrow\;$规范形</p>
<h2 id="惯性定理"><a href="#惯性定理" class="headerlink" title="惯性定理"></a>惯性定理</h2><blockquote>
<p>对一个二次型$x^TAx$,经坐标变换化为标准形，其正惯性指数和负惯性指数都是唯一确定的</p>
</blockquote>
<p>即二次型的规范形是唯一的</p>
<ul>
<li><strong>证</strong>：<br>大体思路：既然要证唯一性，那么就假设其不唯一，也就是能被两个不同的规范形表示，<br>那么如果证明出来这两个规范形整数项必定相等，则结论成立，这里就需要反证法，推出矛盾<br><br>设$r(C^TAC)=r(A)=r(f)=r$<br><br>如果经坐标变换$x=Py\;$和$\;x=Qz$<br><br>二次型$x^TAx$化成规范形，分别为<br><br>$f=y_1^2+y_2^2+\cdots+y_s^2-y_{s+1}^2-\cdots-y_r^2 \; (I)$<br><br>$f=z_1^2+z_2^2+\cdots+z_t^2-z_{t+1}^2-\cdots-z_r^2 \; (II)$<br><br><strong>反证法</strong><br>如果$s &lt; t$的话$\;\rightarrow\;$也就是说$(I)$的正数项和$(II)$的正数项不相等<br><br>$\qquad$由$\;y=P^{-1}x$和$\;z=Q^{-1}x$<br><br>不妨设<br><br>$\qquad y_i=c_{i1}x_1+c_{i2}x_2+\cdots+c_{in}x_n\qquad$<br><br>$\qquad z_i=d_{i1}x_1+d_{i2}x_2+\cdots+d_{in}x_n\qquad$<br><br>其中($i=1,2,\cdots,n$)<br><br><br>在这两个n元线性方程组中选择，选择$(I)$中的系数为正的项和$(II)$中系数为负的项<br><br>即$y_1—y_s,z_{t+1}—z_n$，令他们为0,构造齐次方程组,这样取就是为了推出矛盾<br><br>即<br>$<br>\begin{cases}<br>y_1=0\\<br>\cdots\\<br>y_s=0\\<br>z_{t+1}=0\\<br>\cdots\\<br>z_{n}=0<br>\end{cases}<br>$<br><br>也就是<br>$<br>\begin{cases}<br>c_{11}x_1+c_{12}x_2+\cdots c_{1n}x_n=0\\<br>\qquad\cdots\cdots\\<br>c_{s1}x_1+c_{s2}x_2+\cdots c_{sn}x_n=0\\<br>&amp;(1)\\<br>d_{(t+1)1}x_1+d_{(t+1)2}x_2+\cdots d_{(t+1)n}x_n=0\\<br>\qquad\cdots\cdots\\<br>d_{n1}x_1+d_{n2}x_2+\cdots d_{nn}x_n=0<br>\end{cases}<br>$<br><br>方程个数<br>$s+(n-t)=n+s-t&lt; n$<br><br>方程组(1)必有非零解<br><br>设$\;\eta=(k_1,k_2,\cdots,k_n)^T$是(1)的非零解<br><br>将该解代入两个n元线性方程组，可以得到$y_i,z_i$的值用$y^o_i,z^o_i表示$<br><br>因为$P,Q$均为可逆矩阵，$\eta\neq0$<br><br>$\therefore\;y^o=P^{-1}\eta=(0,\cdots,0,y_{s+1}^o,\cdots,y_n^o)^T\neq0$<br><br>$\quad\;z^o=Q^{-1}\eta=(z_1^o,\cdots,z_t^o,0,\cdots,0)^T\neq0$<br><br>把$\eta$代入$(I)$和$(II)$,有<br><br>$f(\eta)=-(y_{s+1}^o)^2-\cdots-(y_r^o)^2&lt; 0$<br><br>$f(\eta)=(z_1^o)^2+\cdots+(z_t^o)^2&gt;0$<br><br>矛盾<br><br>$\because s,t$地位相等<br><br>$\therefore\;s=t$</li>
</ul>
<p>由惯性定理推出:</p>
<p>实对称矩阵$A$和$B$合同</p>
<p>$\Leftrightarrow p_A=p_B,q_A=q_B\;$<br>(p为正惯性指数，q为负惯性指数)</p>
<h1 id="二次型的正定性"><a href="#二次型的正定性" class="headerlink" title="二次型的正定性"></a>二次型的正定性</h1><h2 id="正定矩阵"><a href="#正定矩阵" class="headerlink" title="正定矩阵"></a>正定矩阵</h2><blockquote>
<p>设二次型$f(x)=x^TAx$<br><br>如果$\forall x=(x_1,x_2,\cdots,x_n)^T\neq0$,<br><br>恒有$f(x)&gt;0$，则称$f$为正定二次型，二次型矩阵$A$称为正定矩阵</p>
</blockquote>
<p>正定的话，平方项系数要严格大于零，也就是说正惯性指数为n</p>
<p>二次型经坐标变换，其正定性不变</p>
<p>$x^TAx$正定</p>
<p>$\Leftrightarrow\;$p(正惯性指数)=n</p>
<p>$\Leftrightarrow\;A\simeq E$,即存在可逆矩阵$C,$</p>
<p>$C^TAC=E(或写成A=C^TEC，E可省略)$</p>
<p>$\Leftrightarrow\;A$特征值全大于0</p>
<p>$\Leftrightarrow\;A$的顺序主子式 <strong>全</strong> 大于0</p>
<p>$x^TAx$正定的必要条件$a_{ii}&gt;0$</p>
<p><strong>例</strong>：判断二次型</p>
<p>$2x_1^2+5x_2^2+5x_3^2+4x_1x_2-4x_1x_3-8x_2x_3$</p>
<p>是否是正定二次型。</p>
<p><strong>解</strong>：</p>
<ul>
<li>顺序主子式<br>二次型矩阵<br><br>$A$=$<br>\left|\begin{array}{ccc}<br>2&amp;2&amp;-2\\<br>2&amp;5&amp;-4\\<br>-2&amp;-4&amp;5<br>\end{array}\right|<br>$<br><br>$\Delta_1=2&gt;0，\Delta_2=\left|\begin{array}{ccc}2&amp;2\\2&amp;5\end{array}\right|=6&gt;0$<br><br>$\Delta_3=|A|=10&gt;0$<br><br>$\therefore\;f\;$是正定二次型</li>
</ul>
<hr>
<ul>
<li>特征值<br>由特征多项式<br><br>$<br>\begin{aligned}<br>|\lambda E-A|<br>&amp;=\left|\begin{array}{ccc}<br>\lambda-2&amp;-2&amp;2\\<br>-2&amp;\lambda-5&amp;4\\<br>2&amp;4&amp;\lambda-5<br>\end{array}\right|\\<br>&amp;=(\lambda-1)^2(\lambda-10)<br>\end{aligned}<br>$<br><br>$A$的特征值：1,1,10$\quad$全大于零<br><br>$\therefore\;f\;$是正定二次型</li>
</ul>
<hr>
<ul>
<li>配方法$^*$<br><br>$<br>\begin{aligned}<br>f<br>&amp;=2x_1^2+5x_2^2+5x_3^2+4x_1x_2-4x_1x_3-8x_2x_3\\<br>&amp;=2[x_1^2+2x_1(x_2-x_3)+(x_2-x_3)^2]\\<br>&amp;\quad -2(x_2-x_3)^2+5x_2^2+5x_3^2-8x_2x_3\\<br>&amp;=(x_1+x_2-x_3)^2+3x_2^2+3x_3^2-4x_2x_3\\<br>&amp;=(x_1+x_2-x_3)^2+3(x_2-\frac23x_3)^2+\frac53x_3^2<br>\end{aligned}<br>$<br><br>$p=3,q=0$<br><br>$\therefore\;f\;$是正定二次型</li>
</ul>
<h2 id="半正定，负定，半负定矩阵"><a href="#半正定，负定，半负定矩阵" class="headerlink" title="半正定，负定，半负定矩阵"></a>半正定，负定，半负定矩阵</h2><p>根据正定可以类比出</p>
<p>半正定$f\geqslant0$</p>
<p>负定$f&lt;0$</p>
<p>半负定$f\leqslant0$</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>9.元素的显示与隐藏</title>
    <url>/2021/07/20/9-%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="元素显示与隐藏"><a href="#元素显示与隐藏" class="headerlink" title="元素显示与隐藏"></a>元素显示与隐藏</h1><p>本质：让一个元素在页面中隐藏或者显示出来</p>
<ol>
<li>display 显示隐藏</li>
<li>visibility 显示隐藏</li>
<li>overflow 溢出显示隐藏</li>
</ol>
<h2 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h2><p><strong>display</strong> 属性用于设置一个元素应如何显示</p>
<ul>
<li>display: none; 隐藏对象</li>
<li>display: block; 除了转换为块级元素之外，同时还有显示元素的意思</li>
</ul>
<p><strong>display 隐藏元素后，不在占有原来的位置</strong></p>
<h2 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h2><p><strong>visibility</strong> 属性用于指定一个元素应可见还是隐藏</p>
<ul>
<li>visibility: visible; 元素可见</li>
<li>visibility: hidden; 元素隐藏</li>
</ul>
<p><strong>visibility隐藏元素后，继续占有原来的位置</strong></p>
<h2 id="overflow-溢出"><a href="#overflow-溢出" class="headerlink" title="overflow 溢出"></a>overflow 溢出</h2><p><strong>overflow</strong> 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度）时</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">visible</td>
<td style="text-align:left">不见且内容也不添加滚动条</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td style="text-align:left">scroll</td>
<td style="text-align:left">不管有无超出内容，总是显示滚动条</td>
</tr>
<tr>
<td style="text-align:left">auto</td>
<td style="text-align:left">超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意:</strong> 如果有定位的盒子，请慎用overflow:hidden 因为它会隐藏多余的部分</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>7.统计方法与排序（numpy）</title>
    <url>/2021/07/07/7-%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%92%E5%BA%8F%EF%BC%88numpy%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h1><p><strong>基本数组统计方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sum</td>
<td style="text-align:left">对数组中全部或某轴向的元素求和。零长度的数组的sum为0</td>
</tr>
<tr>
<td style="text-align:left">mean</td>
<td style="text-align:left">算术平均数。零长度的数组的mean为NaN</td>
</tr>
<tr>
<td style="text-align:left">std、var</td>
<td style="text-align:left">分别为标准差和方差，自由度可调（默认为n）</td>
</tr>
<tr>
<td style="text-align:left">min、max</td>
<td style="text-align:left">最大值和最小值</td>
</tr>
<tr>
<td style="text-align:left">argmin、argmax</td>
<td style="text-align:left">分别为最大和最小元素的索引</td>
</tr>
<tr>
<td style="text-align:left">cumsum</td>
<td style="text-align:left">所有元素的累计和</td>
</tr>
<tr>
<td style="text-align:left">cumprod</td>
<td style="text-align:left">所有元素的累计积</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.54723045,  0.58597431, -0.96045403, -1.702082  ],
       [ 1.06630288, -1.0836272 ,  2.29730989, -0.30115381],
       [-0.95468451,  1.05624793,  1.01693306,  0.09056162],
       [-0.36292065,  0.19475411, -0.01906396, -1.24974648],
       [-1.90823323, -0.31973005,  1.06666693,  0.81091118]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.mean()</span><br></pre></td></tr></table></figure>
<pre><code>-0.06116322299092232
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.mean(arr)</span><br></pre></td></tr></table></figure>
<pre><code>-0.06116322299092232
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>-1.2232644598184463
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<pre><code>2.2973098855173615
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>
<pre><code>-1.9082332261211672
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.std()</span><br></pre></td></tr></table></figure>
<pre><code>1.0584749116858456
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.var()</span><br></pre></td></tr></table></figure>
<pre><code>1.1203691386683585
</code></pre><p>mean和sum这类函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.mean(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-0.65594804,  0.49470794,  0.30226452, -0.35924424, -0.08759629])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-2.70676596,  0.4336191 ,  3.40139188, -2.35150948])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.mean(<span class="number">1</span>)<span class="comment">#计算行的平均值</span></span><br></pre></td></tr></table></figure>
<pre><code>array([-0.65594804,  0.49470794,  0.30226452, -0.35924424, -0.08759629])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">sum</span>(<span class="number">0</span>)<span class="comment">#计算每列的和</span></span><br></pre></td></tr></table></figure>
<pre><code>array([-2.70676596,  0.4336191 ,  3.40139188, -2.35150948])
</code></pre><p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr= np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.cumprod(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]], dtype=int32)
</code></pre><p>当然可以使用布尔型数组，布尔值会被强制转换为1和0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]])</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1,  2,  3],
       [-1, -2, -3]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(arr&gt;<span class="number">0</span>).<span class="built_in">sum</span>()<span class="comment">#这样就得到了数组中大于零的元素个数</span></span><br></pre></td></tr></table></figure>
<pre><code>3
</code></pre><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]])</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [6, 4, 3],
       [2, 3, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.sort()</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [3, 4, 6],
       [2, 3, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="number">0</span>)<span class="comment">#按0轴排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [2, 3, 6],
       [3, 4, 7]])
</code></pre>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>8.CSS网页布局及用户界面样式</title>
    <url>/2021/07/20/8-CSS%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E5%8F%8A%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h1><p><strong>网页布局的核心本质就是利用CSS摆盒子</strong></p>
<p><strong>网页布局的第一准则:</strong><br>多个块级元素纵向排列用标准流，多个块级元素横向排列用浮动。</p>
<p><strong>网页布局的第二准则:</strong><br>先设置盒子大小，后设置盒子位置。</p>
<h2 id="传统网页布局的三种方式"><a href="#传统网页布局的三种方式" class="headerlink" title="传统网页布局的三种方式"></a>传统网页布局的三种方式</h2><p>网页布局的本质————用CSS来摆放盒子</p>
<p>CSS提供了三种传统布局方式：</p>
<ul>
<li>标准流（最基本）</li>
<li>浮动</li>
<li>定位</li>
</ul>
<h2 id="常见的网页布局"><a href="#常见的网页布局" class="headerlink" title="常见的网页布局"></a>常见的网页布局</h2><table style="width: 370px;background-color: #ecedf8;text-align: center;">
  <tr>
    <td style="width: 370px;height: 65px;border:1px dashed;border-collapse: collapse;">top</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 25px;border:1px dashed;border-collapse: collapse;">banner</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 145px;border:1px dashed;border-collapse: collapse;">main</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 90px;border:1px dashed;border-collapse: collapse;">footer</td>
  </tr>
</table>

<p><table style="width: 370px;background-color: #ecedf8;text-align: center;">
  <tr>
    <td style="width: 370px;height: 65px;border:1px dashed;border-collapse: collapse;">top</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 25px;border:1px dashed;border-collapse: collapse;">banner</td>
  </tr>
   <tr>
    <td style="float:left;width: 115px;height: 145px;border:1px dashed;line-height: 145px;border-top:0;border-bottom:0;">left</td>
    <td style="float:right;width: 195px;height: 145px;border:0;border-right:1px dashed;line-height: 145px;">right</td>
  </tr>
   <tr>
    <td style="height: 90px;border:1px dashed;border-collapse: collapse;">footer</td>
  </tr>
</table></p>
<div style="width: 100%;overflow:auto;">
    <div style="width: 500px;height: 420px;border:1px solid;text-align:center;">
    <div style="float:left;width: 480px;height: 25px;line-height:25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 10px 0px;">top</div>
    <div style="float:left;width: 360px;height: 80px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 70px 0px;line-height: 80px">banner</div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px 70px;"></div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 70px 0px 5px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px 70px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 480px;height: 90px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 10px 0px;line-height:90px;">footer</div>
    </div>
</div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过CSS浮动、定位可以让每个盒子排列成为网页。</p>
<p>一个完整的网页，是标准流、浮动、定位一起完成的布局的，每个都有自己专门的用法。</p>
<p><strong>1.标准流</strong><br>可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。<br><strong>2.浮动</strong><br>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。<br><strong>3.定位</strong><br>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</p>
<h1 id="CSS-用户界面样式"><a href="#CSS-用户界面样式" class="headerlink" title="CSS 用户界面样式"></a>CSS 用户界面样式</h1><h2 id="鼠标样式-cursor"><a href="#鼠标样式-cursor" class="headerlink" title="鼠标样式 cursor"></a>鼠标样式 cursor</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123; <span class="attribute">cursor</span>: pointer; &#125;</span><br></pre></td></tr></table></figure>
<p>设置或检索在对象上移动的鼠标指针来采用何种系统预定义的光标形状</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">default</td>
<td style="text-align:left">默认</td>
</tr>
<tr>
<td style="text-align:left">pointer</td>
<td style="text-align:left">小手</td>
</tr>
<tr>
<td style="text-align:left">move</td>
<td style="text-align:left">移动</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">文本</td>
</tr>
<tr>
<td style="text-align:left">not-allowed</td>
<td style="text-align:left">禁止</td>
</tr>
</tbody>
</table>
</div>
<h2 id="轮廓线"><a href="#轮廓线" class="headerlink" title="轮廓线"></a>轮廓线</h2><p>给表单添加 outline: 0;或者outline: none;样式之后，就可以去掉默认的蓝色边框。</p>
<h2 id="防止拖拽文本域-resize"><a href="#防止拖拽文本域-resize" class="headerlink" title="防止拖拽文本域 resize"></a>防止拖拽文本域 resize</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span> &#123; <span class="attribute">resize</span>: none &#125;</span><br></pre></td></tr></table></figure>
<h1 id="vertical-align-属性应用"><a href="#vertical-align-属性应用" class="headerlink" title="vertical-align 属性应用"></a>vertical-align 属性应用</h1><p>CSS的vertical-align属性使用场景：经常用于设置图片或者表单（行内块元素）和文字垂直对齐<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: baseline | top | middle | bottom</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">baseline</td>
<td style="text-align:left">默认，元素放置在父元素的基线上</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">把顶端元素与行中最高元素的顶端对齐</td>
</tr>
<tr>
<td style="text-align:left">middle</td>
<td style="text-align:left">把此元素放置在父元素的中间</td>
</tr>
<tr>
<td style="text-align:left">bottom</td>
<td style="text-align:left">把元素的顶端与行中最低的元素顶端对齐</td>
</tr>
</tbody>
</table>
</div>
<h1 id="溢出文字用省略号"><a href="#溢出文字用省略号" class="headerlink" title="溢出文字用省略号"></a>溢出文字用省略号</h1><h2 id="单行文字溢出用省略号"><a href="#单行文字溢出用省略号" class="headerlink" title="单行文字溢出用省略号"></a>单行文字溢出用省略号</h2><p>1.单行文本溢出显示省略号—必须满足三个条件<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1.先强制一行内显示文本 */</span></span><br><span class="line"><span class="attribute">white-space</span>: nowrap; （默认 <span class="attribute">normal</span> 自动换行）</span><br><span class="line"><span class="comment">/* 2.超出的部分隐藏 */</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="comment">/* 3.文字用省略号替代超出的部分 */</span></span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure></p>
<h2 id="多行文本溢出显示省略号"><a href="#多行文本溢出显示省略号" class="headerlink" title="多行文本溢出显示省略号"></a>多行文本溢出显示省略号</h2><p>多行文本溢出显示省略号，有较大兼容性问题，适合于webkit浏览器或移动端（移动端大部分是webkit内核）<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="comment">/* 弹性伸缩盒子模型显示 */</span></span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line"><span class="comment">/* 限制在一个块元素显示的文本的行数 */</span></span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line">-webkit-box-crient: vertical;</span><br></pre></td></tr></table></figure></p>
<h1 id="CSS-初始化"><a href="#CSS-初始化" class="headerlink" title="CSS 初始化"></a>CSS 初始化</h1><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS初始化</p>
<p><strong>简单理解:</strong> CSS初始化是指重设浏览器的样式（也称为CSS reset）</p>
<p>每个网页都必须首先进行CSS 初始化</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基本结束</title>
    <url>/2021/07/23/CSS%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="154acc6670c3fccef6b5070cdeefb85ec2bfb1ab3262f6db66ad7844de5f0ea2">b932aaa1676845656e99a89ce5708d0a6d629f27376e686be0b7b81e242a554ca974cb7c0d19940d116aac2233fcde8c0eaaa3f436a53ab205c47dd54ff1d66cf3e524aec81cb572511195ff71a4c0e06e620fff646ae43ba520c1ae0f329c5dffba1e93b59f84a0c2e570805a0ed6ceb0b9ed142ef2b3b0e86f5b7c752329902963b266d8ecf12d7ce1be312d2bb6f9595f2b670482e5713110f82d2a2f865ca301078ffccbd1b588c0c1f26f4500ba867d1fde9951ff463ee5b992cc3f349d0d89b4caa0eb3460a8f1be637f6bc948af3229c57d9f719e0c0f45513e595a66df62e9da096655e355d51cdd32e2b3efd3308c1a2de4424c9e3e5f059bf33fa7a46d57972a8d440a32545d2ffa75a01f81c0af8979df87c4f26acc1d4182e2bad9cba8141bd49abfc20b5003ffd4cc257503ab6e6b033d9b7c0fd3b43c0fdc002b171748afd46465acc9c815726462deaab4dbb33bddef490b9c7ebd92c8fb6456f0514904c9ad8113f340dde00d732685885b2e385d031b479fe63577c4d1b23f5f8078b36cc740f42088e90928138f9009a40b4395864efa7a7c5bf260aaab586cdb5038261e732af4f590172a80da25ce2428968f4fb65d633565835c234e7af59c42688b6eee0a4af2bff261222e1db6e70c76de745169f21cb5f30ea07413b269bb6a5ee1db52c340716ce9bba780efec8c127d342e1cea8d9d512a0bad41dac05c1df697104b9b854bd2ee01ed388fcde9dd7e4b38c3eb175b252561738ae0951d66dad00017b3d289893ecedae8b0348ed5b8930c0d7d513ec5c5e2196be2e420b1b5765866346d897c46a35f5c7c75072171f6f05b0cd323c78f65bf566c218ed41b55ed0ab2627667a1fdc45e6b41eec9caeabead248b2511153f28354bc8e19bd4ba1e4f1704ea51360102836f9df69029f028da1f12148a752505951c45259c797f9de8d5e0b401388cee0a94db8142e48bd4c1b2366d5daaeb0fbb84b9a3f52f8bdedfdb35d196cff2348974898e43eea53d0f72e00324ac63e35678c1dbf387e26b0b339cc7586da82bf06dc4656343e1fd19432f90c8907a2f1b95a2a00c8621042b2008d6082630487f88b9d12f302398c16481dcef16ec9f191c35874ebf618b60d18d79773f906c8fd84e7216a0b72331f904acd594fc517029fb180ca3c98e7e86ece146ee0e0a4159fa9a6c04391f627d55b33897436374d348461462ef4f789ae835f58f6d15c5b1485b4aa5f45886cb6f36e960736961adf0e01bf40b7b0b027714074332d028120d2411d6cad85e08781323b8fa863b8a57ff2ae12df3a956da80abf1628af630961f7dd35630d958297b031fcef9a82584b1360332c9893e060e7c0db98bf9f223c1427dc94e0c78755f9ca67efb5c4c2e705a84a723e4552585b3177540098fa3dc14892f17359d695d21c22f9d7d275b35e6473ad3fe70ea3551d11c51279e50781b228df2bcd877ca1c98ec59e4be884a2b10172bfeb4745bd761ff636361b64117450f5354ceb458e18d94ae3c1f09cdbcb44806c07dbf4fd1dc6038867cf3f5e2ab5c15efa9c3b81f79c14e9b1ea0727b5646192aafe64b9368b4286304ed2c7e06f4f7e7bbdba109d3f0e21a401af9f92b78c706cb442726281fa0c2db860f43c3d95a73a22e8eb1f576a9291601e5ff37b0d155fbaccc523e9667b8ca9f57f82f5b5baea5ab6973aae819048c2379affe2d5a1ec62dfb5c76f2c693d191f357be27e7089fe9ee260a3822403441185a1c5c20a06d1878d50c0773bf45fbdf78b6d482037c3dab78c229f25b39eb21cc12de02f033836efdefc45fd83e53703d7d7be02a900e45c320f31fee52916d2aca92dfd5ebf07d7e8cee2ef14511d347eee5dbc8f10227e67c2d8065d736d9c84c3d89cab53af17d2dc36122ff644ca23213f13c6086a9cc4894a688d8dc565efe7b08e9871a0a4fe8f747e7f142f5d477c4e8704cb751934f44ddc981f34d4c0fb88226daa062e23a28d80533ea919232eeb851864988b2bba4fac817d208375c848ff4f0aeebff6a0b2c99bdb54301fc5f4bb27f1756a45ec8fe3b54e544a4ce764632bc019bc10bf6ed3d84cf00032c9ce42063fa3a5962bdabcd17ba2193f8186d638e942a6263c17fa85a67edff0f77166febbd88a4bb40eed61d3fdcbd7e01b40629cf64ec2612ed79e12fc538a1b99dd14728e8c0c6e6826fe7a4fa97d8ad5b1b46d117d7f15eec4a1c36c17f5c8c95b4df05fd0ec4d9fb28686bc585cdcafcb2a7718016c50c542c910944972a775f0d55b5a1c11b0ab4d1b0a78cf452a87af4530e484a41c50da2b767fba5fd311689b649f0027ecd9989e561d936ff78ca4e9852934b66e81b108bbecc5f27244fa8f0e196148af554db5eb1751ea9890a128401032bab179b1ef650bcdb2c65dcc445fbded5097c422968fb09191a7cb706debad66f67b83fdf295fa936b1474168cd4f83ed9c3d87</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>end</title>
    <url>/2021/06/24/end/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>线性代数的内容已经基本结束，但是后面还会对于一些细节进行扩充，并结合一些几何知识进行分析，当然今后也会结合线性代数这一工具来学习高数等知识，并对其用处进行深入研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/15/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>初入</title>
    <url>/2021/06/15/%E5%88%9D%E5%85%A5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b0ca2ef9541fede87b8c708a533c49229e736ec76cfc1393c6388623a747d871">b932aaa1676845656e99a89ce5708d0a6d629f27376e686be0b7b81e242a554ca974cb7c0d19940d116aac2233fcde8c0eaaa3f436a53ab205c47dd54ff1d66cf3e524aec81cb572511195ff71a4c0e06e620fff646ae43ba520c1ae0f329c5dffba1e93b59f84a0c2e570805a0ed6ceb0b9ed142ef2b3b0e86f5b7c752329902963b266d8ecf12d7ce1be312d2bb6f9595f2b670482e5713110f82d2a2f865ca301078ffccbd1b588c0c1f26f4500ba867d1fde9951ff463ee5b992cc3f349d0d89b4caa0eb3460a8f1be637f6bc948af3229c57d9f719e0c0f45513e595a66df62e9da096655e355d51cdd32e2b3efd3308c1a2de4424c9e3e5f059bf33fa7a46d57972a8d440a32545d2ffa75a01f81c0af8979df87c4f26acc1d4182e2baf55748e271f618ca61c55df3ebd9f473a3017555f54ce12602f483c695ef5c7f3a9765c6405bb25eb7f5f4a96d9be65c830c784451c8c97e869239b5746673f2ea8b3f3cc7467e2e74e91259924bfca411b4d30a06d71be6859c7bebde9e9349912c90c8805cd3152df3e549be7ffb40fe2fe31ab56a91ae73f890c8a111dbc7c443521f4d7f12992588f0fd41b5fe299bd135ee19f4c196d5c620d5554a3ad785cf3afe7b9724b0ea0dd0d92445e566697a1bea4b0018a626dc364372db46c9af9e5dbcc2948ce471ef093e70ec3fcfbf5aa8ff12e3ecd505ac142b0a82e1e9e0043af9756589b2ee868f361c92108f74f8d6e2995fa35a76dda720b3bfb438f25d214a45f3878e262b6abda60fe07bef03958a389f863164d05c893a5863300bea6a777046af655fb3b366c540935c766bc2b7c4c1d1f6d16662fd1321730bd182da504af842c2c01585322ae8768f750ba584a8e8eb53e4b32ed1afb7ca786c82ebfd2d3ef6ad2c03e749ffdcfdfd5f1c1e94c11ec03e5d959f25b73a9ea7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>一些关于hexo的next主题的适配问题</title>
    <url>/2021/06/25/%E4%B8%80%E4%BA%9Bhexo%E7%9A%84%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里记录一些hexo方面的问题</p>
<p>今天对于next主题的移动端的问题进行了一些研究，发现在mathjax渲染下存在手机屏幕右方预留出大量空白的问题，<br>问题一：latex数学符号编辑 <strong>$$</strong> 中的内容过长，导致公式溢出屏幕。解决方法：1.将符号用 <strong>$$</strong> 包裹，文字不进行包裹，这样<br>文字是markdown的形式，可以实现自动换行，2.对于过长的数学等式，我目前采用的方法是在前面添加-或1.这种<br>形式在移动端的浏览器，比如百度，夸克……可以实现左右滚动处理<br>问题二：mathjax渲染问题，经过筛选，我发现用cases来编写方程组，aligned内部//过多……会造成即使符号未溢出屏幕，<br>也会造成手机页面右方预留出大量空白，解决方法：仍然是添加-或1.让其实现类似于代码块的左右滚动处理。<br>但是对于问题二，目前没有想出为什么会出现这种情况，因为对前端不是很了解，所以这个问题暂且搁置，等以后进行分析，<br>当然目前的这些解决方法并不能从根本上解决问题，但目前在网络上并没又找到类似问题的解决方法，所以暂时只好这样处理这<br>两个问题,更好的解决办法以后再寻找<br>问题三:移动端不同浏览器的适配问题，我发现在不同浏览器中笔记的显示不太一样，目前适配比较好的是夸克，以后慢慢研究</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>曲线曲面积分</title>
    <url>/2021/08/14/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>曲线曲面积分理解起来并不是很难，主要是计算挺复杂，第一类曲线曲面积分，知道弧微分，二重积分求面积时的面积元素，也就是积分区域与投影区域的倍数关系就可以了，而第二类曲线曲面积分就是将有向曲线沿x,y进行分解，然后再进行求解。当然求解第二类曲线曲面有时候需要一些工具，也就是下面所介绍的三个公式，也是我认为曲线曲面积分中最有意思的地方，后面也会引入 $\nabla$ 算子（就是梯度符号），方便书写记忆</p>
<h1 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h1><blockquote>
<p>格林公式描述了第二种曲线积分（向量的形式），和二重积分的一种关系</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><ul>
<li>1<br>$<br>\nabla\times \vec{F} (x,y)·d\vec{s}$<br><br>$=\left(\displaystyle\frac{\partial}{\partial x}\;\vec{i}+\displaystyle\frac{\partial}{\partial y}\;\vec{j}\right)\times[P(x,y)\;\vec{i}+Q(x,y)\;\vec{j}]·d\vec{s}$<br><br>$=(\displaystyle\frac{\partial}{\partial x}\;\vec{i}\times P(x,y)\;\vec{i}+\displaystyle\frac{\partial}{\partial y}\;\vec{j}\times Q(x,y)\;\vec{j}+\displaystyle\frac{\partial}{\partial y}\;\vec{j}\times P(x,y)\;\vec{i}+\displaystyle\frac{\partial}{\partial x}\;\vec{i}\times Q(x,y)\;\vec{j})·d\vec{s}$<br><br>$=\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y} \right)\;\vec{k}·d\vec{s}$<br><br>$=\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y} \right)dxdy<br>$</li>
</ul>
</blockquote>
<script type="math/tex; mode=display">
\therefore\iint\limits_D\nabla\times \vec{F} (x,y)·d\vec{s}=\oint\limits_LPdx+Qdy=\iint\limits_D\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y} \right)dxdy</script><p>2</p>
<p>当然理解的时候可以站在几何的角度，一个 <strong>有向</strong> 闭合曲线内部可以分成无数个小的 <strong>有向</strong> 闭合曲线，并且部分有向边界可以 <strong>相互抵消</strong>（方向相反的线）</p>
<p><img style="transform:scale(0.7)" src="/2021/08/14/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/g1.png"></p>
<p>将这些正方形无限缩小成一个点，也就是曲面内所有“有向点”的积分之和，与这个曲线的积分相等S</p>
<p>那么每一点的关系又是怎么得来的呢？</p>
<p>取一块微分矩形，<br><img style="transform:scale(0.5)" src="/2021/08/14/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/g2.png"></p>
<p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\oint\limits_L
&=\int\limits_{L1}+\int\limits_{L2}+\int\limits_{L3}+\int\limits_{L4}\\
&=\int_{a_1}^{a_2}P(x,b_1)dx+\int_{b_1}^{b_4}Q(a_2,y)dy\\
&\quad+\int_{a_2}^{a_1}P(x,b_3)dx+\int_{b_4}^{b_1}Q(a_1,y)dy\\
&=\int_{a_1}^{a_2}P(x,b_1)-P(x,b_4)dx+\int_{b_1}^{b_4}Q(a_2,y)-Q(a_1,y)dy\\
&=\int_{a_1}^{a_2}\int_{b_4}^{b_1}\displaystyle\frac{\partial P}{\partial y}dxdy+\int_{b_1}^{b_4}\int_{a_1}^{a_2} \displaystyle\frac{\partial Q}{\partial x}dxdy\\
&=\int_{a_1}^{a_2}\int_{b_4}^{b_1}\displaystyle\frac{\partial P}{\partial y}-\displaystyle\frac{\partial Q}{\partial x}dxdy\\
&=\iint\limits_D\displaystyle\frac{\partial P}{\partial y}-\displaystyle\frac{\partial Q}{\partial x}dxdy
\end{aligned}</script><p>这就是一点处的关系，然后进行累加就得到了格林公式</p>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p><strong>1、平面上曲线积分与路径无关的条件</strong><br>设函数$P(x,y)、Q(x,y)$在平面单连通区域$\;D\;$内具有 <strong>连续的一阶偏导数</strong>，则下面四个命题 <strong>等价</strong></p>
<ul>
<li><p>命题一：曲线$\;L\;(\overset{\frown}{AB})$是$D$内由点A到点B的一段有向曲线，则曲线积分</p>
<script type="math/tex; mode=display">\int_L Pdx+Qdx</script><p>与路径无关，只与起点A和中点B有关</p>
</li>
<li><p>命题二：在区域$\;D\;$内任意一条闭曲线 L 的曲线积分有</p>
<script type="math/tex; mode=display">\oint_L Pdx+Qdy=0</script></li>
<li><p>命题三：在区域$\;D\;$内任意一点(x,y)处于</p>
<script type="math/tex; mode=display">\displaystyle\frac{\partial Q}{\partial x}=\displaystyle\frac{\partial P}{\partial y}</script></li>
<li><p>命题四：在$\;D\;$内存在函数 $u(x,y)$，使得 $Pdx+Qdy$是该二元函数 $u(x,y)$ 的全微分，即</p>
<script type="math/tex; mode=display">du=Pdx+Qdy</script></li>
</ul>
<p><strong>2、已知全微分求原函数</strong><br>如果函数$P(x,y)$、$Q(x,y)$在单连通区域$\;D\;$内具有 <strong>连续的一阶偏导数</strong>，<strong>且$\displaystyle\frac{\partial Q}{\partial x}=\displaystyle\frac{\partial P}{\partial y}$</strong>，则 $Pdx+Qdy$ 是某个函数$u(x,y)$的全微分，且有</p>
<script type="math/tex; mode=display">u(x,y)=\int_{(x_0,y_0)}^{(x,y)}Pdx+Qdy</script><p>其中$(x_0,y_0)$是区域 $D$ 内的某一定点，$(x,y)$是 $D$ 内的任一点</p>
<h1 id="高斯公式"><a href="#高斯公式" class="headerlink" title="高斯公式"></a>高斯公式</h1><blockquote>
<p>高斯公式描述了第二种曲面积分（向量的形式），和三重积分的一种关系</p>
</blockquote>
<p>高斯公式就像是格林公式升一维后的产物，所以这里直接给出公式</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">
\iint\limits_{\Sigma}Pdxdy+Qdxydy+Rdxdy=\iiint\limits_{\Omega}\left(\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}\right)dxdydz</script><p>或</p>
<script type="math/tex; mode=display">\iint\limits_{\Sigma}(P\cos\alpha+Q\cos\beta+R\cos\gamma)dS=\iiint\limits_{\Omega}\left(\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}\right)dxdydz</script><p>这里二重积分表示的都是 <strong>闭合曲面</strong>，mathjax似乎不支持闭合二重积分符号</p>
<p>这个证明跟前面证明格林公式基本一致</p>
<h2 id="通量与散度"><a href="#通量与散度" class="headerlink" title="通量与散度"></a>通量与散度</h2><p>设向量场</p>
<script type="math/tex; mode=display">\vec{A}(x,y,z)=P(x,y,z)\;\vec{i}+Q(x,y,z)\;\vec{j}+R(x,y,z)\;\vec{k}</script><p>其中P、Q、R具有连续的一阶偏导数，&sum; 是场内的一个有向曲面，则称</p>
<script type="math/tex; mode=display">\Phi=\iint\limits_{\Sigma}\vec{A}·d\vec{S}=\iint\limits_{\Sigma}Pdydz+Qdzdx+Rdxdy</script><p>为向量场 $\vec{A}$ 通过曲面 &sum;的通量（或流量）</p>
<p>$<br>\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}<br>$<br>称为向量场 $\vec{A}$ 的散度，记作div$\vec{A}$，即</p>
<script type="math/tex; mode=display">\text{div}\vec{A}=\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}</script><p>所以高斯公式也可简写成</p>
<script type="math/tex; mode=display">\iint\limits_{\Sigma}\vec{A} · d\vec{S}=\iiint\limits_{\Omega}\text{div}\vec{A}dV</script><p>这里散度的概念是从物理学中抽象出来的</p>
<h1 id="斯托克斯公式"><a href="#斯托克斯公式" class="headerlink" title="斯托克斯公式"></a>斯托克斯公式</h1><blockquote>
<p>斯托克斯公式就是格林公式的推广，其一般情况是应用在三维空间中的曲线和二重积分的一种关系，当然有时也可以进一步利用高斯公式将二重积分进一步转化为三重积分。</p>
</blockquote>
<h2 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">
\oint_L Pdx+Qdy+Rdz=\iint\limits_{\Sigma}
\begin{vmatrix}
dydz&dzdx&dxdy\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}
=\iint\limits_{\Sigma}
\begin{vmatrix}
\cos\alpha&\cos\beta&\cos\gamma\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}</script><p>这个证明跟前面证明格林公式基本一致</p>
<p>$\nabla\times \vec{F} (x,y,z)·d\vec{s}$，将这个混合积用行列式书写也就是公式中的这玩意</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
dydz&dzdx&dxdy\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}</script><p>当然上面的格林公式其实也可以写成这种行列式的形式</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
0&0&dxdy\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
0\\
\\
P&Q&0
\end{vmatrix}</script><p>所以为什么说斯托克斯公式其实就是格林公式的推广</p>
<h2 id="环流量与旋度"><a href="#环流量与旋度" class="headerlink" title="环流量与旋度"></a>环流量与旋度</h2><p>设向量场</p>
<script type="math/tex; mode=display">\vec{A}(x,y,z)=P(x,y,z)\;\vec{i}+Q(x,y,z)\;\vec{j}+R(x,y,z)\;\vec{k}</script><p>L是场内的一条有向闭曲线，则称</p>
<script type="math/tex; mode=display">\Gamma=\oint_L\vec{A} · d\vec{S}=\oint_L Pdx+Qdy+Rdz</script><p>为向量场 $\vec{A}$ 沿曲线L的环流量，并称向量</p>
<script type="math/tex; mode=display">
\left(\displaystyle\frac{\partial R}{\partial y}-\displaystyle\frac{\partial Q}{\partial z}\right)\vec{i}+\left(\displaystyle\frac{\partial P}{\partial z}-\displaystyle\frac{\partial R}{\partial x}\right)\vec{j}+\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y}\right)\vec{k}</script><p>为向量 $\vec{A}$ 的旋度，记作rot$\vec{A}$，即</p>
<script type="math/tex; mode=display">
\text{rot} \vec{A}=
\begin{vmatrix}
\vec{i}&\vec{j}&\vec{k}\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}
=\left(\displaystyle\frac{\partial R}{\partial y}-\displaystyle\frac{\partial Q}{\partial z}\right)\vec{i}+\left(\displaystyle\frac{\partial P}{\partial z}-\displaystyle\frac{\partial R}{\partial x}\right)\vec{j}+\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y}\right)\vec{k}</script><p>所以斯托克斯公式可简写成</p>
<script type="math/tex; mode=display">
\oint_L \vec{A}·d\vec{r}=\iint\limits_{\Sigma}\text{rot}\vec{A}·d\vec{S}</script><p>其中<br>$d\vec{r}=dx\vec{i}+dy\vec{j}+dz\vec{k}$<br>$d\vec{S}=dydz\vec{i}+dzdx\vec{j}+dxdy\vec{k}$</p>
]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
</search>
