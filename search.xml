<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0.CSS的一些规范和特性</title>
    <url>/2021/07/20/0-CSS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS代码规范"><a href="#CSS代码规范" class="headerlink" title="CSS代码规范"></a>CSS代码规范</h1><h2 id="样式格式书写"><a href="#样式格式书写" class="headerlink" title="样式格式书写"></a>样式格式书写</h2><p>(1) 紧凑格式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">color</span>: red;<span class="attribute">font-size</span>: <span class="number">20px</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>(2) 展开格式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式大小写"><a href="#样式大小写" class="headerlink" title="样式大小写"></a>样式大小写</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">COLOR</span>: PINK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>样式选择器，属性名，属性值关键字虽然大小写都行，但最好使用 <strong>小写字母</strong> ,特殊情况除外。</p>
<h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) 属性值前面，冒号后面，保留一个空格</p>
<p>(2) 选择器（标签）和大括号中间保留空格</p>
<h2 id="CSS-属性书写顺序"><a href="#CSS-属性书写顺序" class="headerlink" title="CSS 属性书写顺序"></a>CSS 属性书写顺序</h2><ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow（建议display第一个写）</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient…</li>
</ol>
<h1 id="CSS-引入方式"><a href="#CSS-引入方式" class="headerlink" title="CSS 引入方式"></a>CSS 引入方式</h1><h2 id="CSS-的三种样式表"><a href="#CSS-的三种样式表" class="headerlink" title="CSS 的三种样式表"></a>CSS 的三种样式表</h2><p>1.行内样式表（行内式）</p>
<p>2.内部样式表（嵌入式）</p>
<p>3.外部样式表（链接式）</p>
<h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>内部样式表就是在html页面内部写样式，但是单独写到style标签内部<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#ff0</span>00;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>&lt;style&gt; 标签里理论上可以放在HTML文档的任何地方，但一般会放在文档的&lt;head&gt; 标签中</li>
<li>通过此种方式可以方便控制当前整个页面元素样式设置</li>
<li>代码结构清晰，但是没有实现结构与样式完全分离</li>
</ul>
<h2 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h2><p>在元素标签内部的sytle属性中设定CSS样式，修改一些简单样式<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red;font-size: 12px;&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>不推荐大量使用</p>
<h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><p>适用于样式比较多的情况下，核心:样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。</p>
<p>引入外部样式表的步骤：<br>1.新建一个后缀名为.css的样式文件,把所有CSS代码都放到此文件中。 </p>
<p>2.在HTML页面中，使用&lt;link&gt;标签引入这个文件。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rel</td>
<td style="text-align:left">定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”,表示被链接文档是一个样式表文件</td>
</tr>
<tr>
<td style="text-align:left">href</td>
<td style="text-align:left">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</td>
</tr>
</tbody>
</table>
</div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">样式表</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">行内样式表</td>
<td style="text-align:left">书写方便，权重高</td>
<td style="text-align:left">控制一个标签</td>
</tr>
<tr>
<td style="text-align:left">内部样式表</td>
<td style="text-align:left">部分结构和样式相分离</td>
<td style="text-align:left">控制一个页面</td>
</tr>
<tr>
<td style="text-align:left">外部样式表</td>
<td style="text-align:left">完全实现结构和样式相分离</td>
<td style="text-align:left">控制多个页面</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS-的三大特性"><a href="#CSS-的三大特性" class="headerlink" title="CSS 的三大特性"></a>CSS 的三大特性</h1><blockquote>
<p>CSS有三个非常重要的特性：层叠性、继承性、优先级。</p>
</blockquote>
<h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><p>相同选择器给设置的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。</p>
<p>层叠性原则：</p>
<ul>
<li>样式冲突：就近原则那个样式离结构近，就执行哪个样式</li>
<li>样式不冲突，不会层叠。</li>
</ul>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>CSS中的继承：<strong>子标签</strong> 会继承 <strong>父标签</strong> 的某些样式，如文本颜色和字号</p>
<ul>
<li>恰当使用继承可以简化代码，降低CSS样式的复杂性</li>
<li>子标签可以继承父标签的样式（text-,font-,line- 以及color属性）</li>
</ul>
<p><strong>行高的继承</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">12px</span>/<span class="number">1.5</span> Microsoft YaHei</span><br><span class="line">    这个<span class="number">1.5</span>就是当前元素文字大小font-size的<span class="number">1.5</span>倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>行高可以跟单位也可以不跟单位</li>
</ul>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当同一个元素指定多个选择器，就会有优先级产生。</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，则根据 <strong>选择器权重</strong> 执行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">选择器权重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">继承或*</td>
<td style="text-align:left">0,0,0,0</td>
</tr>
<tr>
<td style="text-align:left">元素选择器</td>
<td style="text-align:left">0,0,0,1</td>
</tr>
<tr>
<td style="text-align:left">类选择器，伪类选择器</td>
<td style="text-align:left">0,0,1,0</td>
</tr>
<tr>
<td style="text-align:left">ID选择器</td>
<td style="text-align:left">0,1,0,0</td>
</tr>
<tr>
<td style="text-align:left">行内样式style=””</td>
<td style="text-align:left">1,0,0,0</td>
</tr>
<tr>
<td style="text-align:left">!important 重要的</td>
<td style="text-align:left">无穷大</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意点</strong></p>
<ul>
<li>权重是有4组数字组成，但是不会有进位</li>
<li>等级判断从左向右，如果某一位数值相同，则判断下一位数值。</li>
<li><strong>继承的权重是0</strong>,如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是0。</li>
</ul>
<p><strong>权重叠加</strong>：如果是复合选择器，则会有权重叠加，需要计算权重</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>0.数据结构与算法知识储备</title>
    <url>/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/frame.png"></p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><blockquote>
<p>能输入计算机且能被计算机处理的 <strong>各种符号的集合</strong></p>
</blockquote>
<ul>
<li>是信息的载体</li>
<li>是对客观事物符号化的表示</li>
<li>能够被计算机识别，存储和加工</li>
</ul>
<p>包括：</p>
<ul>
<li>数值型数据：整数、实数等</li>
<li>非数值型数据：文字、图像、图形、声音等</li>
</ul>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><ul>
<li>是数据的 <strong>基本单位</strong>,在计算机程序中通常作为一个整体进行考虑和处理。</li>
<li>也简称为元素，或称为记录、结点或顶点。</li>
<li>一个 <strong>数据元素</strong> 可由若干个 <strong>数据项</strong> 组成</li>
</ul>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><ul>
<li>构成数据元素的不可分割的 <strong>最小单位</strong></li>
</ul>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><ul>
<li>是 <strong>性质相同的数据元素的集合</strong>，是数据的一个子集</li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p><strong>数据结构</strong> 是一门研究非数值计算的程序设计中计算机的操作对象以及它们之间的关系和操作的学科</p>
</blockquote>
<p>数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为 <strong>结构</strong></p>
<p>数据结构是指 <strong>相互之间存在一种或多种特定关系</strong> 的数据元素集合</p>
<p>数据结构包括以下三个方面的内容：</p>
<ol>
<li>数据元素之间的逻辑关系，也称为逻辑结构</li>
<li>数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的 <strong>物理结构</strong> 或数据的 <strong>存储结构</strong></li>
<li>数据的 <strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现</li>
</ol>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul>
<li>描述数据元素之间的逻辑关系</li>
<li>与数据的存储无关，独立于计算机</li>
<li>是从具体问题抽象出来的数学模型</li>
</ul>
<p><strong>种类</strong><br><strong>划分方法一</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li>有且仅有一个开始和一个终端结点，并且所有结点最多只有一个直接前驱和一个直接后继。如：线性表、栈、队列、串</li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li>一个节点可能有多个直接前驱和直接后继。如树、图</li>
</ul>
</li>
</ul>
<p><strong>划分方法二</strong><br>(1)<strong>集合结构</strong>：结构中的数据元素之间除了 <strong>同属于一个集合</strong> 的关系外，无其他任何关系</p>
<p>(2)<strong>线性结构</strong>：结构中的数据元素之间存在着 <strong>一对一</strong> 的线性关系</p>
<p>(3)<strong>树形结构</strong>：结构中的数据元素之间存在 <strong>一对多</strong> 的层次关系</p>
<p>(4)<strong>图状结构</strong> 或 <strong>网状结构</strong>：结构中的数据元素之间存在着 <strong>多对多</strong> 的任意关系</p>
<h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><ul>
<li>数据元素及其关系在计算机存储器中的结构（存储方式）</li>
<li>是数据结构在计算机中的表示</li>
</ul>
<p><strong>种类</strong></p>
<ul>
<li>顺序存储结构<ul>
<li>用一组 <strong>连续</strong> 的存储单元 <strong>依次</strong> 存储数据元素，数据元素之间的逻辑关系由元素的 <strong>存储位置</strong> 来表示</li>
<li>C语言中用数组来实现顺序存储结构</li>
</ul>
</li>
<li>链式存储结构<ul>
<li>用一组 <strong>任意</strong> 的存储单元存储数据元素，数据元素之间的逻辑关系用 <strong>指针</strong> 来表示</li>
<li>C语言中用指针来实现链式存储结构</li>
</ul>
</li>
<li>索引存储结构<ul>
<li>在存储节点信息的同时，还建立附加的 <strong>索引表</strong></li>
<li>索引表中的每一项称为一个 <strong>索引项</strong></li>
<li>索引项的 <strong>一般形式</strong> 是：(关键字，地址)</li>
<li>关键字是能 <strong>唯一标识</strong> 一个结点的那些数据项</li>
<li>若每个节点在索引表中都有一个索引项，则该索引表称之为 <strong>稠密索引</strong>。若一组结点在索引表中只对应一个索引项，则该索引表称之为 <strong>稀疏索引</strong></li>
</ul>
</li>
<li>散列存储结构<ul>
<li>根据结点的关键字直接计算出该节点的存储地址</li>
</ul>
</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul>
<li>存储结构是逻辑关系的映像与元素本身的映像</li>
<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li>
</ul>
<h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><h3 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h3><blockquote>
<p>定义：数据类型是一组性质相同的 <strong>值的集合</strong> 以及定义这个集合上的 <strong>一组操作</strong> 的总称</p>
</blockquote>
<p><strong>数据类型 = 值的集合 + 值集合上的一组操作</strong> </p>
<ul>
<li>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的 <strong>数据类型</strong><ul>
<li>例如，C语言中：<ul>
<li>提供int,char,float,double等基本数据类型</li>
<li>数组、结构、共用体、枚举等构造数据类型</li>
<li>还有指针、空(void)类型</li>
<li>用户也可用typedef自己定义数据类型</li>
</ul>
</li>
</ul>
</li>
<li>一些最基本数据结构可以用数据类型来实现，如数组、字符串等；</li>
<li>而另一些常用的数据结构。如栈、队列、树、图等，不能直接用数据类型来表示。</li>
</ul>
<p>数据类型的作用</p>
<ul>
<li>约束变量或常量的取值范围</li>
<li>约束变量或常量的操作</li>
</ul>
<h3 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type,ADT)"></a>抽象数据类型(Abstract Data Type,ADT)</h3><blockquote>
<p>是指一个数学模型以及定义在此数学模型上的一组操作</p>
</blockquote>
<ul>
<li>由用户定义，从问题抽象出 <strong>数据模型</strong>（逻辑结构）</li>
<li>还包括定义在数据模型上的一组 <strong>抽象运算</strong>（相关操作）</li>
<li>不考虑计算机内的具体存储结构与运算的具体实现算法</li>
</ul>
<p>抽象数据类型 = 数据的逻辑结构 + 抽象运算</p>
<p><strong>抽象数据类型的形式定义</strong><br>抽象数据类型可用（D,S,P）<strong>三元组</strong> 表示</p>
<p>其中：D是数据对象；S是D上的关系集；P是对D的基本操作集</p>
<p>一个抽象数据类型的 <strong>定义格式</strong> 如下<br><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">	数据对象：<span class="attribute">&lt;数据对象的定义&gt;</span></span><br><span class="line">	数据关系：<span class="attribute">&lt;数据关系的定义&gt;</span></span><br><span class="line">	基本操作：<span class="attribute">&lt;基本操作的定义&gt;</span></span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><br>其中：</p>
<ul>
<li>数据对象、数据关系的定义用伪代码描述</li>
<li>基本操作的定义格式为：<ul>
<li>基本操作名：（参数表）</li>
<li>初始条件：（初始条件描述）</li>
<li>操作结果：（操作结果描述）</li>
</ul>
</li>
</ul>
<p><strong>基本操作</strong> 定义格式说明</p>
<p>参数表：</p>
<ul>
<li>赋值参数 只为操作提供输入值</li>
<li>引用参数以&amp;打头，除可提供输入值外，还将返回操作结果 </li>
</ul>
<p>初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。</p>
<p>操作结果：说明操作完成之后，数据结构的变化状况和应返回的结果</p>
<p><strong>抽象数据类型如何实现</strong></p>
<ul>
<li>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示和实现<ul>
<li>即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/07/25/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/知识总结.png"></p>
<h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><blockquote>
<p>算法的定义：对特定问题 <strong>求解方法和步骤</strong> 的一种描述，它是 <strong>指令</strong> 的有限 <strong>序列</strong>。其中每个指令表示一个或多个操作 </p>
</blockquote>
<p><strong>算法:</strong></p>
<ul>
<li><p>狭义的算法是与数据的存储方式密切相关</p>
</li>
<li><p>广义的算法是与数据的存储方式无关</p>
</li>
<li><p>泛型：利用某种技术达到的效果就是：不同的存数方式，执行的操作是一样的</p>
<h2 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h2></li>
<li>自然语言：英语、中文</li>
<li>流程图：传统流程图、NS流程图</li>
<li>伪代码：类语言：类C语言</li>
</ul>
<h2 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h2><ul>
<li><strong>算法</strong> 是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法</li>
<li><strong>程序</strong> 是用某种程序设计语言对算法的具体实现。</li>
</ul>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<ul>
<li>数据结构通过算法实现操作</li>
<li>算法根据数据结构设计程序</li>
</ul>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li>有穷性：一个算法必须总是 在执行有穷步之后结束，且每一步都在又穷时间内完成</li>
<li>确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出</li>
<li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li>
<li>输入：一个算法有零个或多个输入</li>
<li>输入：一个算法有一个或多个输出</li>
</ul>
<h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
</ul>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><blockquote>
<p>目的是看算法实际是否可行，并在同一问题存在多的算法时可进行性能上的比较，以便从中挑选出比较优的算法</p>
</blockquote>
<p>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑 <strong>算法的效率</strong>,通过算法的效率高低来评判不同算法的优劣程度</p>
<p>效率从两方面考虑：</p>
<ol>
<li><strong>时间效率</strong>：指的是算法耗费的 <strong>时间</strong></li>
<li><strong>空间效率</strong>：指的是算法执行过程中所耗费的 <strong>存储空间</strong></li>
</ol>
<p><strong>时间效率和空间效率有时候是矛盾的</strong></p>
<h3 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h3><p>算法的时间效率可以依据该算法编制的程序在计算机上执行 <strong>所消耗的时间</strong> 来度量</p>
<p><strong>方法</strong></p>
<ul>
<li>事后统计<ul>
<li>将算法实现，测算其时间和空间开销</li>
<li>缺点：编写程序实现算法将花费较多的时间和精力；所得到实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣</li>
</ul>
</li>
<li>事前分析<ul>
<li>对算法所消耗的资源的一种估算方法</li>
</ul>
</li>
</ul>
<p><strong>事前分析方法</strong></p>
<ul>
<li>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的 <strong>时间</strong> 与算法中进行的简单操作 <strong>次数乘积</strong><br><strong>算法运行时间 = 一个简单操作所需的时间 × 简单操作次数</strong></li>
<li>也即算法中每条语句的时间之和<br>  算法运行时间 = &sum; 每条语句的执行次数 &times; 该语句执行一次所需的时间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++&gt;)<span class="comment">//n+1次</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++&gt;)&#123;<span class="comment">//n(n+1)次</span></span><br><span class="line">		c[i][j]=<span class="number">0</span>;<span class="comment">//n*n次</span></span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//n*n*(n+1)次</span></span><br><span class="line">			c[i][j]=c[i][j]+a[i][k]*b[k][j];<span class="comment">//n*n*n次</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们把算法所耗费的时间定义为该算法中 <strong>每条语句的频度之和</strong>，则上述算法的时间消耗T(n)为：<br>$T(n)=2n^3+3n^2+2n+1$</li>
</ul>
<ul>
<li>为了便于比较不同算法的时间效率，我们仅比较它们的数量级</li>
</ul>
<p>所以用时间复杂度表示,则$T(n)$可记作<br>$T(n)=O(n^3)$</p>
<h3 id="算法空间效率的度量"><a href="#算法空间效率的度量" class="headerlink" title="算法空间效率的度量"></a>算法空间效率的度量</h3><blockquote>
<p><strong>空间复杂度</strong>：算法所需存储空间的度量</p>
</blockquote>
<p>记作：$S(n)=O(f(n))$</p>
<p>其中 <strong>n</strong> 为问题的规模（或大小）</p>
<ul>
<li>算法要占据的空间<ul>
<li>算法本身要占据的空间，输入/输出，指令，常数，变量等 </li>
<li>算法要使用的 <strong>辅助空间</strong></li>
</ul>
</li>
</ul>
<p><strong>算法一</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">	t = a[i];</span><br><span class="line">	a[i] = a[n-i<span class="number">-1</span>];</span><br><span class="line">	a[n-i<span class="number">-1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>空间复杂度$S(n)=O(1)$</p>
<p><strong>算法二</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	b[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	a[i]=b[i];</span><br></pre></td></tr></table></figure><br>空间复杂度$S(n)=O(n)$</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0. 知识储备</title>
    <url>/2021/06/16/0.%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="和号-sum"><a href="#和号-sum" class="headerlink" title="和号$\sum$"></a>和号$\sum$</h1><p>${\large a}_1+{\large a}_2+\cdots+{\large a}_n<br>=\sum\limits_{i=1}^n {\large a}_i$</p>
<p>${\large a}_{11}+{\large a}_{12}+\cdots+{\large a}_{1m}<br>=\sum\limits_{j=1}^n {\large a}_{1j}$</p>
<p>${\large a}_1x_1+{\large a}_2x_2+{\large a}_3x_3<br>=\sum\limits_{i=1}^3 {\large a}_ix_i$</p>
<p>$\sum\limits_{i=1}^3 ({\large a}_i+{\large b}_i)x_i<br>=\sum\limits_{i=1}^3 {\large a}_ix_i+<br>\sum\limits_{i=1}^3 {\large b}_ix_i$</p>
<p>$\sum\limits_{i=1}^n {\large a}_i<br>=\sum\limits_{j=1}^n {\large a}_j$</p>
<p>$\sum\limits_{i=1}^n k{\large a}_i<br>=k\sum\limits_{i=1}^n {\large a}_i$<br><br></p>
<ul>
<li>双和号<br>$<br>\begin{array}{lll}<br>{\large a}_{11} + {\large a}_{12} + \cdots+ {\large a}_{1n}<br>= \sum\limits_{j=1}^n {\large a}_{1j}\\<br>{\large a}_{21} + {\large a}_{22} + \cdots+ {\large a}_{2n}<br>= \sum\limits_{j=1}^n {\large a}_{2j}\\<br>\vdots\qquad\quad\vdots\qquad\quad\;\qquad\vdots\\<br>{\large a}_{m1} + {\large a}_{m2} + \cdots + {\large a}_{mm}<br>= \sum\limits_{j=1}^n {\large a}_{mj}\\<br>\downarrow\qquad\quad\downarrow\qquad\qquad\downarrow\\<br>\sum\limits_{i=1}^m {\large a}_{i1}\,<br>\sum\limits_{i=1}^m {\large a}_{i2}\;\cdots\;<br>\sum\limits_{i=1}^m {\large a}_{in}<br>\end{array}<br>$<br><br>先横着相加再竖着相加：<br>$\sum\limits_{j=1}^n {\large a}_{1j}+\sum\limits_{j=1}^n<br>{\large a}_{2j}+\cdots+\sum\limits_{j=1}^n<br>{\large a}_{mj}=\sum\limits_{i=1}^m\sum\limits_{j=1}^n {\large a}_{ij}$<br><br>按竖着相加再横着相加：<br>$\sum\limits_{i=1}^m {\large a}_{i1}+<br>\sum\limits_{i=1}^m {\large a}_{i2}+\cdots+\sum\limits_{i=1}^m<br>{\large a}_{in}=\sum\limits_{j=1}^n\sum\limits_{i=1}^m {\large a}_{ij}$<br><br>所以$\sum\limits_{i=1}^m\sum\limits_{j=1}^n {\large a}_{ij}<br>=\sum\limits_{j=1}^n\sum\limits_{i=1}^m {\large a}_{ij}$<br><br>未完待续……</li>
</ul>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>1.C语言的一些概念</title>
    <url>/2021/06/27/1-C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol>
<li>整型常量：也就是整数</li>
<li>实型常量：<ol>
<li>十进制小数形式：由数字和小数点组成</li>
<li>指数形式：如$12.34e3$(代表$12.34\times10^3$)<br><br> 规定：字母E或e代表以10为底的指数<br><br> 注意：E或e前必须有数字，且e或E后必须为整数</li>
</ol>
</li>
<li>字符常量：<ol>
<li>普通字符：用单撇号括起来的一个字符</li>
<li>转义字符：以字符”\\”开头的字符</li>
</ol>
</li>
<li>字符串常量：用双撇号把若干字符括起来</li>
<li>符号常量：如#define PI 3.14 (注意末尾没有分号)</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">转义字符</th>
<th style="text-align:left">字符值</th>
<th style="text-align:left">输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\a</td>
<td style="text-align:left">警告(alert)</td>
<td style="text-align:left">产生声音或视觉信号</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">退格(backspace)</td>
<td style="text-align:left">将光标位置后退一个字符</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页(form feed)</td>
<td style="text-align:left">将光标当前位置移到下一页的开头</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行</td>
<td style="text-align:left">将光标当前位置移到下一行的开头</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车(carriage return)</td>
<td style="text-align:left">将该光标当前位置移到本行的开头</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">水平制表符</td>
<td style="text-align:left">将光标当前位置移到下一个Tab位置</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表符</td>
<td style="text-align:left">将光标当前位置移到下一个垂直制表对齐点</td>
</tr>
<tr>
<td style="text-align:left">\o,\oo或\ooo<br>其中o代表一个八进制数字</td>
<td style="text-align:left">与该八进制码对应的$ASCLL$字符</td>
<td style="text-align:left">与该八进制码对应的字符</td>
</tr>
<tr>
<td style="text-align:left">\xh[h$\cdots$]<br>其中h代表一个十六进制数字</td>
<td style="text-align:left">与该十六进制对应的$ASCLL$字符</td>
<td style="text-align:left">与该十六进制码对应的字符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>变量代表一个有名字，具有特定属性的一个存储单元。它用来存放数据，也就是存放变量的值。程序运行期间变量的值可以改变。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;<span class="comment">//a是变量名，3是变量值</span></span><br></pre></td></tr></table></figure></p>
<h2 id="常变量"><a href="#常变量" class="headerlink" title="常变量"></a>常变量</h2><p>$C99$允许使用 <strong>常变量</strong> ,方法是在定义变量时，前面加一个关键字const,<br>如 const int a=3;<br><br>常变量和常量的异同：<br><br>常变量具有变量的基本属性：有类型，占存储单元，只是不允许只改变<br><br>常变量是有名字的不变量，常量是没有名字的不变量<br></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列统称为标识符。</p>
</blockquote>
<p>就是一个对象的名字。变量名c,f……，符号常量名PI……，函数名printf……都是标识符</p>
<p><strong>C语言规定</strong> 标识符只能由字母，数字和下划线3种字符组成，且首字符必须是字母或下划线。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>所谓类型，就是对数据分配存储单元的安排，包括存储单元的长度（占多少字节）<br>以及数据的存储形式。不同的类型分配不同的长度和存储形式。</p>
<ul>
<li>$<br>\text{数据类型}<br>\begin{cases}<br>\text{基本类型}<br>\begin{cases}<br>\text{整型类型}<br>\begin{cases}<br>\text{基本整形(int)}\\<br>\text{短整型(short int)}\\<br>\text{长整型(long int)}\\<br>\text{双长整型(long long int)}\\<br>\text{字符型(char)}\\<br>\text{布尔型(bool)}<br>\end{cases}\\<br>\\<br>\text{浮点类型}<br>\begin{cases}<br>\text{单精度浮点型(float)}\\<br>\text{双精度浮点型(double)}\\<br>\text{复数浮点型(float_complex,double_complex,longlong_complex)}<br>\end{cases}<br>\end{cases}\\<br>\\<br>\text{枚举类型(enum)}\\<br>\\<br>\text{空类型(void)}\\<br>\\<br>\text{派生类型}<br>\begin{cases}<br>\text{指针类型(*)}\\<br>\text{数组类型([ ])}\\<br>\text{结构体类型(struct)}\\<br>\text{共用体类型(union)}\\<br>\text{函数类型}<br>\end{cases}<br>\end{cases}<br>$</li>
</ul>
</blockquote>
<p>其中基本类型和枚举类型的值都是数值，统称为算术类型。</p>
<p>算术类型和指针类型统称为纯量类型，因为其值是整数类型。</p>
<p>枚举类型是程序中用户定义的整数类型。</p>
<p>数组类型和结构体类型统称为组合类型，共用体类型不属于组合类型，<br>因为在同一时间只有一个成员具有值。</p>
<p>函数类型用来定义函数，描述一个函数的接口，包括函数返回值的数据类型和参数的类型</p>
<h2 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h2><p>存储单元的存储方式是：用整数补码形式存放。</p>
<p>一个整数的补码是此数的二进制形式</p>
<p>求负数补码的方法：先将此数的绝对值写成二进制的形式，然后对所有二进制位按位 <strong>取反，再加1</strong></p>
<h3 id="整型数据的分类"><a href="#整型数据的分类" class="headerlink" title="整型数据的分类"></a>整型数据的分类</h3><ol>
<li>基本类型(int 型)<br>编译系统分配给int型数据2个字节或4个字节(由具体的C语言编译系统自行决定)<br></li>
<li>短整型(short int)<br>类型名为short int或short。<br><br>一般分配2个字节，取值范围$-2^{15}\sim (2^{15}-1)$</li>
<li>长整型(long int)<br>类型名为long int或long。<br><br>一般分配4个字节，取值范围$-2^{31}\sim (2^{31}-1)$</li>
<li>双长整型(long long int)<br>类型名为long long int或long long。<br><br>一般分配8个字节，取值范围$-2^{63}\sim (2^{63}-1)$</li>
</ol>
<p>在类型符号前面加上无符号修饰符unsigned，就是只有正值的意思，<br>因为其所占字节数不变，也就是说正值的取值范围比以前大。</p>
<h2 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h2><p>定义字符变量<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;?&#x27;</span>; <span class="comment">//char c=63;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  %c&quot;</span>,c,c);</span><br><span class="line"><span class="comment">//输出结果63 ?</span></span><br></pre></td></tr></table></figure><br>c是字符变量，实质上是一个字节的整型变量，但是它用来存放字符，所以称为字符变量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">signed char(有符号字符型)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$-2^7\sim (2^7-1)$</td>
</tr>
<tr>
<td style="text-align:center">unsigned char(无符号字符型)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$0\sim 2^{8}-1$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="浮点型数据"><a href="#浮点型数据" class="headerlink" title="浮点型数据"></a>浮点型数据</h2><blockquote>
<p>用来表示具有小数点的实数。</p>
</blockquote>
<p>因为小数点位置可以浮动，所以实数的指数形式称为 <strong>浮点数</strong></p>
<p>浮点数类型有三种</p>
<ol>
<li>float型（单精度浮点型）<br>分配4个字节</li>
<li>double型（双精度浮点型）<br>分配8个字节</li>
<li>long double型（长双精度型）<br>8或16个字节<h2 id="确定常量的类型"><a href="#确定常量的类型" class="headerlink" title="确定常量的类型"></a>确定常量的类型</h2></li>
<li>整型常量<br>在一个整数末尾加大写L或小写l表示长整型<br></li>
<li>浮点型常量<blockquote>
<p>以小数或指数形式出现的实数</p>
</blockquote>
</li>
</ol>
<p>在末尾加上F或f表示float类型，<br>加上L或l表示long double类型<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a =<span class="number">3</span> <span class="number">.14159</span>f</span><br><span class="line"><span class="keyword">float</span> dounble a = <span class="number">1.23L</span></span><br></pre></td></tr></table></figure></p>
<p><strong>类型和变量的区别：</strong><br>每个变量都属于一个确定的类型，类型是变量的一个重要属性。</p>
<h1 id="C语句"><a href="#C语句" class="headerlink" title="C语句"></a>C语句</h1><h2 id="C语句的作用和分类"><a href="#C语句的作用和分类" class="headerlink" title="C语句的作用和分类"></a>C语句的作用和分类</h2><p>语句后面有分号</p>
<p>分类：</p>
<ol>
<li>控制语句</li>
<li>函数调用语句</li>
<li>表达式语句</li>
<li>空语句</li>
<li>复合语句</li>
</ol>
<h1 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h1><p>C语言本身不提供输入输出语句</p>
<p>需要使用库函数stdio.h</p>
<h2 id="printf-格式控制，输出表列"><a href="#printf-格式控制，输出表列" class="headerlink" title="printf(格式控制，输出表列)"></a>printf(格式控制，输出表列)</h2><p>%附加字符 格式字符</p>
<p>例%-m.nf</p>
<p>printf函数中用到的格式字符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">d,i</td>
<td style="text-align:left">输出带符号十进制整数</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:left">输出八进制无符号整数(不输出前导符0)</td>
</tr>
<tr>
<td style="text-align:center">x,X</td>
<td style="text-align:left">输出无符号十六进制整数(不输出前导符0x)，用x小写，X大写</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:left">输出无符号十进制整数</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:left">输出一个字符</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:left">输出字符串</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:left">以小数形式输出单、双精度数，隐含输出6位小数</td>
</tr>
<tr>
<td style="text-align:center">e,E</td>
<td style="text-align:left">以指数形式输出实数</td>
</tr>
<tr>
<td style="text-align:center">g,G</td>
<td style="text-align:left">选用%f或%e格式中输出宽度较短的一种形式，不输出无意义的0</td>
</tr>
</tbody>
</table>
</div>
<p>在格式声明中，在%和上述格式字符间可以插入几种附加字符(又称修饰符)</p>
<p>printf函数中用到的修饰符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:left">长整型整数，可加在格式符d、o、x、u前面</td>
</tr>
<tr>
<td style="text-align:center">m(代表一个整数)</td>
<td style="text-align:left">数据的最小宽度</td>
</tr>
<tr>
<td style="text-align:center">n(代表一个实数)</td>
<td style="text-align:left">对实数，表示输出n位小数；对字符串，表示截取的字符个数</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:left">输出的数字或字符在域内想左靠</td>
</tr>
</tbody>
</table>
</div>
<h2 id="scanf-格式控制-地址表列"><a href="#scanf-格式控制-地址表列" class="headerlink" title="scanf(格式控制,地址表列)"></a>scanf(格式控制,地址表列)</h2><p><strong>注意</strong>：scanf函数中是地址表列，传进去的是变量地址</p>
<h1 id="关系运算符和关系表达式"><a href="#关系运算符和关系表达式" class="headerlink" title="关系运算符和关系表达式"></a>关系运算符和关系表达式</h1><blockquote>
<p>C语言中，比较符称为关系运算符<br><br>用关系运算符将两个数值或数值表达式连接起来的式子，称为关系表达式。</p>
</blockquote>
<p>关系运算符：</p>
<p>&lt; ， &lt;= ， &gt; ， &gt;= ， == ， !=</p>
<p>关系表达式：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>&gt;=<span class="number">0</span> <span class="comment">//为真 1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="逻辑运算符和逻辑表达式"><a href="#逻辑运算符和逻辑表达式" class="headerlink" title="逻辑运算符和逻辑表达式"></a>逻辑运算符和逻辑表达式</h1><p>逻辑表达式：</p>
<p>&amp;&amp; 或 ，|| 与 ，! 非</p>
<p>逻辑运算符：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">8</span> &lt; <span class="number">4</span> - !<span class="number">0</span> <span class="comment">//为假 0</span></span><br></pre></td></tr></table></figure></p>
<h1 id="条件运算符和条件表达式"><a href="#条件运算符和条件表达式" class="headerlink" title="条件运算符和条件表达式"></a>条件运算符和条件表达式</h1><p>条件表达式的一般形式：</p>
<p>表达式1 ? 表达式2 : 表达式3<br>例<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max=(a&gt;b)?a:b;</span><br></pre></td></tr></table></figure></p>
<h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grade;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;grade);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your score:&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(grade) <span class="comment">//此括号里的值类型应为整数类型（包括字符型）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;85~100\n&quot;</span>);<span class="keyword">break</span>;<span class="comment">//break;不能省</span></span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;B</span><span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;70~84\n&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>C<span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;60~69\n&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;&lt;60\n&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;enter data error!\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果:</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">Your score:85~100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="静态，动态存储方式"><a href="#静态，动态存储方式" class="headerlink" title="静态，动态存储方式"></a>静态，动态存储方式</h1><p><strong>例</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">0</span>;<span class="comment">//定义了一个静态局部变量，调用后不释放，保留前值</span></span><br><span class="line">	b=b+<span class="number">1</span>;</span><br><span class="line">	c=c+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">2</span>,i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><strong>对比下面的程序</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">	b=b+<span class="number">1</span>;</span><br><span class="line">	c=c+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">2</span>,i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>1.html语法规则</title>
    <url>/2021/07/09/1-html%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h1><p>这两天学习了一下html的基本语法规则，复习一段时间后就会开始CSS的学习，并将其先运用在博客的页面显示上，当然这也是为了以后网站搭建进行一些知识储备。</p>
<h2 id="基本语法概述"><a href="#基本语法概述" class="headerlink" title="基本语法概述"></a>基本语法概述</h2><ol>
<li>HTML标签是由尖括号包围的关键词，例如&lt;html&gt;</li>
<li>HTML标签通常是成对出现的，例如&lt;html&gt;和&lt;/html&gt;，我们称为双标签，第一个是开始标签，第二个是结束标签</li>
<li>有些特殊的标签必须是单个标签（极少情况），例如&lt;br/&gt;,我们称为单标签</li>
</ol>
<h2 id="标签关系"><a href="#标签关系" class="headerlink" title="标签关系"></a>标签关系</h2><p>双标签关系可分为两类：包含关系和并列关系</p>
<p><strong>包含关系</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>并列关系</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="HTML基本结构标签"><a href="#HTML基本结构标签" class="headerlink" title="HTML基本结构标签"></a>HTML基本结构标签</h1><h2 id="第一个HTML网页"><a href="#第一个HTML网页" class="headerlink" title="第一个HTML网页"></a>第一个HTML网页</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		hello,world</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">标签名</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;html&gt;&lt;/html&gt;</td>
<td style="text-align:left">HTML标签</td>
<td style="text-align:left">根标签</td>
</tr>
<tr>
<td style="text-align:left">&lt;head&gt;&lt;/head&gt;</td>
<td style="text-align:left">文档头部</td>
<td style="text-align:left">注意在head标签中我们必须要设置的标签是title</td>
</tr>
<tr>
<td style="text-align:left">&lt;title&gt;&lt;/title&gt;</td>
<td style="text-align:left">文档标题</td>
<td style="text-align:left">让页面拥有一个属于自己的网页标题</td>
</tr>
<tr>
<td style="text-align:left">&lt;body&gt;&lt;/body&gt;</td>
<td style="text-align:left">文档主体</td>
<td style="text-align:left">元素包含文档的所有内容，页面内容基本都是放到body里面的</td>
</tr>
</tbody>
</table>
</div>
<h1 id="网页开发工具"><a href="#网页开发工具" class="headerlink" title="网页开发工具"></a>网页开发工具</h1><h2 id="文档类型声明标签"><a href="#文档类型声明标签" class="headerlink" title="文档类型声明标签"></a>文档类型声明标签</h2><p>&lt;!DOCTYPE&gt;文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这句代码表示采用HTML5</p>
<h2 id="lang语言种类"><a href="#lang语言种类" class="headerlink" title="lang语言种类"></a>lang语言种类</h2><p>用来定义当前文档显示的语言：</p>
<ol>
<li>en定义语言为英文</li>
<li>zh-CN定义语言为中文<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><blockquote>
<p>在&lt;head&gt;标签内，可以通过&lt;meta&gt;标签的charset属性来规定HTML文档应该使用哪种字符编码。</p>
</blockquote>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>charset常用的值由：GB2312、BIG5、GBK和UTF-8，其中UTF-8也被称为万国码，基本包含了全世界所有国家需要用到的字符</p>
<p><strong>注意：</strong> 上面语法是必须要写的代码，否则可能引起乱码情况，一般情况下，统一使用”UTF-8”编码</p>
<h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><h2 id="标题标签-lt-h1-gt-lt-h6-gt"><a href="#标题标签-lt-h1-gt-lt-h6-gt" class="headerlink" title="标题标签&lt;h1&gt;-&lt;h6&gt;"></a>标题标签&lt;h1&gt;-&lt;h6&gt;</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>单词head的缩写</p>
<h2 id="段落标签和换行标签"><a href="#段落标签和换行标签" class="headerlink" title="段落标签和换行标签"></a>段落标签和换行标签</h2><p>在网页中，要把文字有条理地显示出来，需要将这些文字分段显示。在HTML标签中，&lt;p&gt;标签用于定义段落，它可以将整个网页分为若干段落。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br>单词paragraph的缩写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>单词break的缩写</p>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加粗</td>
<td style="text-align:left">&lt;strong&gt;&lt;/strong&gt;或者&lt;b&gt;&lt;/b&gt;</td>
<td style="text-align:left">推荐使用&lt;strong&gt;</td>
</tr>
<tr>
<td style="text-align:left">倾斜</td>
<td style="text-align:left">&lt;em&gt;&lt;/em&gt;或者&lt;i&gt;&lt;/i&gt;</td>
<td style="text-align:left">推荐使用&lt;em&gt;</td>
</tr>
<tr>
<td style="text-align:left">删除线</td>
<td style="text-align:left">&lt;del&gt;&lt;del&gt;或者&lt;s&gt;&lt;/s&gt;</td>
<td style="text-align:left">推荐使用&lt;del&gt;</td>
</tr>
<tr>
<td style="text-align:left">下划线</td>
<td style="text-align:left">&lt;ins&gt;&lt;/ins&gt;或者<u></u></td>
<td style="text-align:left">推荐使用&lt;ins&gt;</td>
</tr>
</tbody>
</table>
</div>
<h2 id="lt-div-gt-和-lt-span-gt-标签"><a href="#lt-div-gt-和-lt-span-gt-标签" class="headerlink" title="&lt;div&gt;和&lt;span&gt;标签"></a>&lt;div&gt;和&lt;span&gt;标签</h2><p>&lt;div&gt;和&lt;span&gt;是没有语义的，它们是一个盒子，用来装内容的。</p>
<p>div是division的缩写，表示分区（大盒子），span是跨度（小盒子）</p>
<h2 id="图像标签和路径"><a href="#图像标签和路径" class="headerlink" title="图像标签和路径"></a>图像标签和路径</h2><ol>
<li>图像标签<br>在HTML标签中，&lt;img&gt;标签用于定义HTML页面中的图像。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
src是&lt;img&gt;的必须属性，而且必须写在img后面</li>
</ol>
<p><strong>图片标签属性:</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">图片路径</td>
<td style="text-align:left">必须属性</td>
</tr>
<tr>
<td style="text-align:left">alt</td>
<td style="text-align:left">文本</td>
<td style="text-align:left">替换文本，图像不能显示的文字</td>
</tr>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">文本</td>
<td style="text-align:left">提示文本，鼠标放到图像上，显示文字</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">像素</td>
<td style="text-align:left">设置图像的宽度</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left">像素</td>
<td style="text-align:left">设置图像的高度</td>
</tr>
<tr>
<td style="text-align:left">border</td>
<td style="text-align:left">像素</td>
<td style="text-align:left">设置图像边框的粗细</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>路径<br>目录文件夹和根目录：</li>
</ol>
<p><strong>目录文件夹</strong>：就是普通文件夹<br><strong>根目录</strong>：打开目录文件夹的第一层就是根目录</p>
<p>路径可以分为：</p>
<p>1.相对路径<br>以引用文件所在的位置为参考基础，建立出的目录路径</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">相对路径分类</th>
<th style="text-align:left">符号</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">同一级路径</td>
<td style="text-align:left"></td>
<td style="text-align:left">图像位于HTML文件同一级，如’baidu.gif’</td>
</tr>
<tr>
<td style="text-align:left">下一级路径</td>
<td style="text-align:left">/</td>
<td style="text-align:left">图像文件位于HTML文件下一级，如’images/baidu.gif’</td>
</tr>
<tr>
<td style="text-align:left">上一级路径</td>
<td style="text-align:left">../</td>
<td style="text-align:left">图像文件位于HTML文件上一级，如’../baidu.gif’</td>
</tr>
</tbody>
</table>
</div>
<p>2.绝对路径<br>是指目录下的绝对位置，直接到达目录位置，通常从盘符开始的路径。</p>
<p>例”D:\web\img\logo.gif”或完整的网络地址”xxx/images/log.gif”</p>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><blockquote>
<p>在HTML 标签中，&lt;a&gt;标签用于定义超链接，作用是从一个页面链接到另一个页面。</p>
</blockquote>
<p>1.语法格式<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">bref</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br>单词anchor的缩写，意为：锚<br><br>两个属性作用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">href</td>
<td style="text-align:left">用于指定来链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left">用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口中打开方式。</td>
</tr>
</tbody>
</table>
</div>
<p>2.链接分类<br>(1) 外部链接：例如<br><code>&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></p>
<p>(2) 内部链接：网站内部页面之间的相互链接，直接链接内部页面名称即可，例如<br><code>&lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;</code></p>
<p>(3)空连接：如果当时没有确定链接目标时<br><code>&lt;a href=&#39;#&#39;&gt;首页&lt;/a&gt;</code></p>
<p>(4)下载链接：如果href里面地址是一个文件或者压缩包，会下载这个文件</p>
<p>(5)网页元素链接：在网页中的各种网页元素，如文本、图像、表格、视频、音频等都可以添加超链接。</p>
<p>(6)锚点链接：点击链接，可以快速定位到页面中的某个位置</p>
<ul>
<li>在链接文本的href属性中，设置属性值为#名字的形式，如<br><code>&lt;a href=&#39;#two&#39;&gt;第二集&lt;/a&gt;</code></li>
<li>找到目标位置的标签，里面添加一个id属性 = 刚才的名字，如<br><code>&lt;h3 id=&quot;two&quot;&gt;第二集介绍&lt;/h3&gt;</code></li>
</ul>
<h1 id="HTML中的注释和特殊字符"><a href="#HTML中的注释和特殊字符" class="headerlink" title="HTML中的注释和特殊字符"></a>HTML中的注释和特殊字符</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>HTML中的注释</p>
<p>&lt;!— 注释 —&gt;</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>在HTML页面中，一些特殊的符号很难或不方便使用的代替方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特殊字符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">字符的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">空格符</td>
<td style="text-align:left">&amp;nbsp;</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">大于号</td>
<td style="text-align:left">&amp;lt;</td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">和号</td>
<td style="text-align:left">&amp;amp;</td>
</tr>
<tr>
<td style="text-align:left">&yen;</td>
<td style="text-align:left">人民币</td>
<td style="text-align:left">&amp;yen;</td>
</tr>
<tr>
<td style="text-align:left">&copy;</td>
<td style="text-align:left">版权</td>
<td style="text-align:left">&amp;copy;</td>
</tr>
<tr>
<td style="text-align:left">&reg;</td>
<td style="text-align:left">注册商标</td>
<td style="text-align:left">&amp;reg;</td>
</tr>
<tr>
<td style="text-align:left">&deg;</td>
<td style="text-align:left">摄氏度</td>
<td style="text-align:left">&amp;deg;</td>
</tr>
<tr>
<td style="text-align:left">&plusmn;</td>
<td style="text-align:left">正负号</td>
<td style="text-align:left">&amp;plusmn;</td>
</tr>
<tr>
<td style="text-align:left">&times;</td>
<td style="text-align:left">乘号</td>
<td style="text-align:left">&amp;times;</td>
</tr>
<tr>
<td style="text-align:left">&divide;</td>
<td style="text-align:left">除号</td>
<td style="text-align:left">&amp;divide;</td>
</tr>
<tr>
<td style="text-align:left">&sup2;</td>
<td style="text-align:left">上标2</td>
<td style="text-align:left">&amp;sup2;</td>
</tr>
<tr>
<td style="text-align:left">&sup3;</td>
<td style="text-align:left">上标3</td>
<td style="text-align:left">&amp;sup3;</td>
</tr>
</tbody>
</table>
</div>
<h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><h2 id="表格的基本语法"><a href="#表格的基本语法" class="headerlink" title="表格的基本语法"></a>表格的基本语法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>&lt;table&gt;&lt;/table&gt;是用于定义表格的标签</li>
<li>&lt;tr&gt;&lt;/tr&gt;标签用于定义表格中的行，必须嵌套在&lt;table&gt;&lt;/table&gt;标签中</li>
<li>&lt;td&gt;&lt;/td&gt;用于定义表格中的单元格，必须嵌套在&lt;td&gt;&lt;td&gt;标签中</li>
<li>字母td指表格数据(table data)，即数据单元格的内容</li>
</ol>
<h2 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h2><blockquote>
<p>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示</p>
</blockquote>
<p>&lt;th&gt;标签显示HTML表格的表头部分(table head的缩写)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">align</td>
<td style="text-align:left">left、center、right</td>
<td style="text-align:left">表格相对周围元素的对齐方式</td>
</tr>
<tr>
<td style="text-align:left">border</td>
<td style="text-align:left">1或””</td>
<td style="text-align:left">表格边框，默认为””,表示没有边框</td>
</tr>
<tr>
<td style="text-align:left">cellpadding</td>
<td style="text-align:left">像素值</td>
<td style="text-align:left">单元格与内容之间的距离，默认1像素</td>
</tr>
<tr>
<td style="text-align:left">cellspacing</td>
<td style="text-align:left">像素值</td>
<td style="text-align:left">单元格和单元格之间的距离，默认2像素</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">像素值或百分比</td>
<td style="text-align:left">表格的宽度</td>
</tr>
</tbody>
</table>
</div>
<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><p>分为无序列表，有序列表和自定义列表</p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>&lt;ul&gt;标签表示HTML页面中项目的无序列表，列表项使用&lt;li&gt;标签定义。</p>
<p>基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> &lt;ul&gt;里面只能放&lt;li&gt;,&lt;li&gt;里面可以放任何的标签</p>
<p>无序列表会带有自己的样式属性，在实际使用时，会用CSS来设置。</p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>&lt;ol&gt;标签用于定义有序列表，列表排序艺术字来显示，并且使用&lt;li&gt;标签来定义列表项</p>
<p>基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> &lt;ol&gt;里面只能放&lt;li&gt;,&lt;li&gt;里面可以放任何的标签</p>
<p>有序列表会带有自己的样式属性，在实际使用时，会用CSS来设置。</p>
<h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><p>列表前没有任何的项目符号</p>
<p>&lt;dl&gt;标签用于自定义列表，该标签会与&lt;dt&gt;（定义项目/名字）和&lt;dd&gt;（描述每一个项目/名字）一起使用。</p>
<p>基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>&lt;dl&gt;&lt;/dl&gt;里面只能包含&lt;dt&gt;和&lt;dd&gt;,&lt;dt&gt;和&lt;dd&gt;个数没有限制，但经常是一个&lt;dt&gt;对应多个&lt;dd&gt;</p>
<h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><p>通过表单收集用户信息</p>
<p>一个完整的表单通常是由表单域、表单元素和提示信息3个部分组成。</p>
<h2 id="表单域-lt-form-gt"><a href="#表单域-lt-form-gt" class="headerlink" title="表单域 &lt;form&gt;"></a>表单域 &lt;form&gt;</h2><p>一个包含所有表单元素的区域</p>
<p>&lt;form&gt;标签用于定义表单域</p>
<p>&lt;form&gt; 会把它范围内的表单元素信息提交给服务器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">	各种表单元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常用属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">action</td>
<td style="text-align:left">url地址</td>
<td style="text-align:left">指定接收并处理表单数据的服务器程序的url地址</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:left">get/post</td>
<td style="text-align:left">设置表单数据的提交方式</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">名称</td>
<td style="text-align:left">指定表单的名称，以区分同一页面中的的多个表单域</td>
</tr>
</tbody>
</table>
</div>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><h3 id="lt-input-gt-输入表单元素"><a href="#lt-input-gt-输入表单元素" class="headerlink" title="&lt;input&gt;输入表单元素"></a>&lt;input&gt;输入表单元素</h3><p>在&lt;input&gt;标签中，包含一个type属性，根据不同的type属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;input&gt;标签为单标签</li>
<li>type属性设置不同的属性值用来指定不同的控件类型</li>
</ul>
<p><strong>type属性值：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">button</td>
<td style="text-align:left">可点击按钮（多数情况下，用于通过javaScript启动脚本）</td>
</tr>
<tr>
<td style="text-align:left">checkbox</td>
<td style="text-align:left">复选框</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">输入字段和”浏览”按钮，供文件上传</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">隐藏输入字段</td>
</tr>
<tr>
<td style="text-align:left">image</td>
<td style="text-align:left">图像形式的提交按钮</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">密码字段，该字段中的字符被掩码</td>
</tr>
<tr>
<td style="text-align:left">radio</td>
<td style="text-align:left">单选按钮</td>
</tr>
<tr>
<td style="text-align:left">reset</td>
<td style="text-align:left">重置按钮，清除表单中的所有数据</td>
</tr>
<tr>
<td style="text-align:left">submit</td>
<td style="text-align:left">提交按钮，把表单数据发送到服务器</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">单行的输入字段，用户可在其中输入文本，默认宽度为20个字符</td>
</tr>
</tbody>
</table>
</div>
<p>除type属性，还有其他常用属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">由用户自定义</td>
<td style="text-align:left">input元素的名称</td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">由用户自定义</td>
<td style="text-align:left">规定input元素的值</td>
</tr>
<tr>
<td style="text-align:left">checked</td>
<td style="text-align:left">checked</td>
<td style="text-align:left">规定此Input元素首次加载对应当被选中</td>
</tr>
<tr>
<td style="text-align:left">maxlength</td>
<td style="text-align:left">正整数</td>
<td style="text-align:left">规定输入字段中的字符最大的长度</td>
</tr>
<tr>
<td style="text-align:left">form</td>
<td style="text-align:left">关联表单的id属性</td>
<td style="text-align:left">通过这个属性可以将控件放置在页面的任何位置，否则只能放在表单内部</td>
</tr>
<tr>
<td style="text-align:left">required</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">是否为必填</td>
</tr>
</tbody>
</table>
</div>
<h2 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt;标签"></a>&lt;label&gt;标签</h2><p>&lt;label&gt;标签为input元素定义标注（标签）</p>
<p>&lt;label&gt;标签用于绑定一个表单元素，当点击&lt;lable&gt;标签内的文本时，浏览器会自动将光标转到或者选择对应的表单元素上，用来增加用户体验。</p>
<p>语法:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br><strong>核心:</strong>&lt;label&gt;标签的 <strong>for属性</strong> 应当与相关元素的 <strong>id属性</strong> 相同</p>
<h2 id="lt-select-gt-表单元素"><a href="#lt-select-gt-表单元素" class="headerlink" title="&lt;select&gt;表单元素"></a>&lt;select&gt;表单元素</h2><p>使用&lt;select&gt;标签控件定义下拉列表</p>
<p>语法：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">	地址：</span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在&lt;option&gt;中定义selected=”selected”时，当前项即为默认选中项。</p>
<h2 id="lt-textarea-gt-表单元素"><a href="#lt-textarea-gt-表单元素" class="headerlink" title="&lt;textarea&gt;表单元素"></a>&lt;textarea&gt;表单元素</h2><p>文本域</p>
<p>语法：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">row</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">	文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在实际开发中不会使用cols和rows,都是用CSS来改变大小</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.CSS选择器</title>
    <url>/2021/07/20/1-CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>分类</strong>： <strong>基础选择器</strong> 和 <strong>复合选择器</strong> </p>
<p><strong>作用</strong>：选择标签</p>
<h1 id="CSS-基础选择器"><a href="#CSS-基础选择器" class="headerlink" title="CSS 基础选择器"></a>CSS 基础选择器</h1><blockquote>
<p> 基础选择器是由 <strong>单个</strong> 选择器组成的</p>
</blockquote>
<p>基础选择器包括：标签选择器、类选择器、id选择器和通配符选择器</p>
<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>标签选择器是用 <strong>HTML标签名</strong> 作为选择器，按标签名称分类，为页面中的某一类标签指定统一的CSS样式。</p>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类标签</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，将所有拥有red类的HTML元素均为红色。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结构需要 <strong>class</strong> 属性来调用class类<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&#x27;red&#x27;&gt;红色&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><br><strong>注意:</strong><br>(1) 类选择器使用”.”进行标识，后面紧跟类名(自定义)</p>
<p>(2) 长名称或词组可以使用 <strong>中横线</strong> 来为选择器命名</p>
<p>(3) 不要使用纯数字、中文等命名，尽量使用英文字母</p>
<p>(4) 命名要有意义</p>
<p>(5) <strong>类命名规则:</strong> 查web文档</p>
<h2 id="类选择器-多类名"><a href="#类选择器-多类名" class="headerlink" title="类选择器-多类名"></a>类选择器-多类名</h2><p>一个标签可以指定多个类名，从而达到更多的选择目的<br>1.使用多类名的方法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;red font20&quot;&gt;hh&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><br>(1) 在标签class属性中写多个类名<br>(2) 多个类名中间必须用空格分开<br>(3) 每个标签就可以分别具有这些类名的样式</p>
<h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>用”#”定义<br>基本语法<br> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>选择器名称 &#123;</span><br><span class="line">    CSS属性:属性值</span><br><span class="line">    CSS属性:属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意:</p>
<p>1.id是唯一性元素，一个页面上 <strong>不允许两个元素具有相同的id</strong>。一个HTML元素，也只允许使用一个id，<strong>不允许以空格分隔的id列表</strong></p>
<p>2.当不确定时，有多个html元素来使用该样式时，使用类选择器</p>
<p>3.id选择器的优先级高于class选择器的优先级。</p>
<h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><p>用”*”定义，表示选取页面中的所有元素（标签）<br>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>注意:</strong></p>
<ul>
<li>通配符选择器不需要调用，自动就给所有元素使用样式</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">基础选择器</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标签选择器</td>
<td style="text-align:left">可以选出所有相同元素</td>
<td style="text-align:left">p{color: red;}</td>
</tr>
<tr>
<td style="text-align:left">类选择器</td>
<td style="text-align:left">可以选出1个或者多个标签</td>
<td style="text-align:left">.nav{color: red;}</td>
</tr>
<tr>
<td style="text-align:left">id选择器</td>
<td style="text-align:left">一次只能选择一个标签</td>
<td style="text-align:left">#nav{color: red;}</td>
</tr>
<tr>
<td style="text-align:left">通配符选择器</td>
<td style="text-align:left">选择所有标签</td>
<td style="text-align:left">*{color: red;}</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS-复合选择器"><a href="#CSS-复合选择器" class="headerlink" title="CSS 复合选择器"></a>CSS 复合选择器</h1><blockquote>
<p>复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的</p>
</blockquote>
<p>常用复合选择器包括：后代选择器，子选择器，并集选择器，伪类选择器等</p>
<h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>可以选择 <strong>父类元素里面的子元素</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素<span class="number">1</span> 元素<span class="number">2</span> &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h2><p>只能选择作为某元素最近一级子元素<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素<span class="number">1</span>&gt;元素<span class="number">2</span> &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>可以选择多组标签，同时为他们定义相同样式</p>
<p>通过逗号，（和的意思）连接而成</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素<span class="number">1</span>,</span><br><span class="line">元素<span class="number">2</span> &#123; </span><br><span class="line">	样式声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>用于某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素</p>
<p>伪类选择器书写用冒号:表示</p>
<h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器元素</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a:link</td>
<td style="text-align:left">选择所有未被访问的链接</td>
</tr>
<tr>
<td style="text-align:left">a:visited</td>
<td style="text-align:left">选择所有已被访问的链接</td>
</tr>
<tr>
<td style="text-align:left">a:hover</td>
<td style="text-align:left">选择鼠标指针位于其上的链接</td>
</tr>
<tr>
<td style="text-align:left">a:active</td>
<td style="text-align:left">选择活动链接（鼠标按下未弹起的链接）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意:</strong></p>
<ul>
<li>必须按照顺序LVHA，要不然会不起作用</li>
<li>因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</li>
</ul>
<h3 id="focus-伪类选择器"><a href="#focus-伪类选择器" class="headerlink" title=":focus 伪类选择器"></a>:focus 伪类选择器</h3><p>:focus 伪类选择器用于选取获得焦点的表单元素。<br>焦点是光标，一般情况&lt;input&gt;类表单元素才能获取，因此这个选择器也主要针对于表单元素来说</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">后代选择器</td>
<td style="text-align:left">选择父类里面的子元素</td>
<td style="text-align:left">空格</td>
</tr>
<tr>
<td style="text-align:left">子代选择器</td>
<td style="text-align:left">选择父类里面 <strong>最近一级的子元素元素</strong></td>
<td style="text-align:left">大于&gt;</td>
</tr>
<tr>
<td style="text-align:left">并集选择器</td>
<td style="text-align:left">选择某些样式相同的元素</td>
<td style="text-align:left">逗号,</td>
</tr>
<tr>
<td style="text-align:left">链接伪类选择器</td>
<td style="text-align:left">选择不同状态的链接</td>
<td style="text-align:left">冒号，重点记住a{}和a:hover</td>
</tr>
<tr>
<td style="text-align:left">:focus伪类选择器</td>
<td style="text-align:left">选择获得光标的表单</td>
<td style="text-align:left">input:focus</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.numpy入门</title>
    <url>/2021/06/30/1-numpy%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为在matplotlib和pandas中都需要用到pandas，所以我想先将numpy文档中的基本代码都实现一遍，也算作是numpy的入门，后面先将matplotlib和pandas暂时放一放，对numpy进行深入学习，当然因为numpy是对数组进行处理，所以也会将其和线性代数结合在一块儿进行学习，基本掌握之后，在花几天时间进行巩固，然后将其运用到matplotlib和pandas的学习中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="array创建"><a href="#array创建" class="headerlink" title="array创建"></a>array创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 一维数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) <span class="comment"># 二维数组，2行3列</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [4, 5, 6]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]],dtype=<span class="built_in">complex</span>) <span class="comment">#创建时指定数组类型</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1.+0.j, 2.+0.j, 3.+0.j],
       [1.+0.j, 2.+0.j, 3.+0.j]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-0.21304205, -0.6656218 ,  0.33403836])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0., 0., 0.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.empty(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0., 0., 0.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1., 1., 1.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full(<span class="number">3</span>,<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.5, 0.5, 0.5])
</code></pre><h2 id="arange函数"><a href="#arange函数" class="headerlink" title="arange函数"></a>arange函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">6</span>) <span class="comment">#类似等差数列，缺点是浮点精度有限，不可能预测所获得元素的数量 </span></span><br></pre></td></tr></table></figure>
<pre><code>array([10, 16, 22, 28])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">6</span>)</span><br><span class="line">b=np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#2行3列</span></span><br><span class="line">c=np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
--------------
[[0 1 2]
 [3 4 5]]
--------------
[[0 1 2]
 [3 4 5]
 [6 7 8]]
</code></pre><h2 id="linspace函数"><a href="#linspace函数" class="headerlink" title="linspace函数"></a>linspace函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>)<span class="comment">#接受所要元素的数量而不是步长(arrang函数)</span></span><br></pre></td></tr></table></figure>
<pre><code>array([1.  , 1.25, 1.5 , 1.75, 2.  , 2.25, 2.5 , 2.75, 3.  ])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.indices((<span class="number">3</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[[0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]],

       [[0, 1, 2],
        [0, 1, 2],
        [0, 1, 2]]])
</code></pre><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">b = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = b-a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = a&lt;<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">e = np.sin(b)<span class="comment">#都是对应元素进行计算</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<pre><code>[ 1.    3.25  5.5   7.75 10.  ]
---------------
[0 1 2 3 4]
---------------
[-1.   -2.25 -3.5  -4.75 -6.  ]
---------------
[ True False False False False]
---------------
[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025 ]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array( [[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">               [<span class="number">0</span>,<span class="number">1</span>]] )</span><br><span class="line">B = np.array( [[<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">               [<span class="number">3</span>,<span class="number">4</span>]] )</span><br><span class="line">a=A * B    <span class="comment"># 对应元素相乘</span></span><br><span class="line">b=A @ B    <span class="comment"># 矩阵相乘                 </span></span><br><span class="line">c=A.dot(B)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dot&quot;</span>,c)</span><br></pre></td></tr></table></figure>
<pre><code>* [[2 0]
 [0 4]]
---------------
@ [[5 4]
 [3 4]]
---------------
dot [[5 4]
 [3 4]]
</code></pre><h2 id="求和，求最值···"><a href="#求和，求最值···" class="headerlink" title="求和，求最值···"></a>求和，求最值···</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))<span class="comment">#2行3列随机数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure>
<pre><code>[[0.70271427 0.13052157 0.78775386]
 [0.57059958 0.22503932 0.35158542]]
---------------
2.768214031975299
---------------
0.13052157065742465
---------------
0.7877538595802818
</code></pre><h2 id="axis参数"><a href="#axis参数" class="headerlink" title="axis参数"></a>axis参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum&quot;</span>,a.<span class="built_in">sum</span>(axis=<span class="number">1</span>))<span class="comment"># 打印出每一列的和</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min&quot;</span>,a.<span class="built_in">min</span>(axis=<span class="number">1</span>))<span class="comment"># 打印出每一行的最小值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cumsum&quot;</span>,a.cumsum(axis=<span class="number">1</span>))<span class="comment">#每一行累积求和</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
---------------
sum [ 6 22 38 54]
---------------
min [ 0  4  8 12]
---------------
cumsum [[ 0  1  3  6]
 [ 4  9 15 22]
 [ 8 17 27 38]
 [12 25 39 54]]
</code></pre><h2 id="索引，切片，迭代"><a href="#索引，切片，迭代" class="headerlink" title="索引，切片，迭代"></a>索引，切片，迭代</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>])<span class="comment">#索引,打印出第三个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:<span class="number">5</span>])<span class="comment">#切片,从第三个数到第五个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[::-<span class="number">1</span>])<span class="comment">#步长为-1，也就是逆序</span></span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
---------------
2
---------------
[2 3 4]
---------------
[9 8 7 6 5 4 3 2 1 0]
</code></pre><h3 id="多维"><a href="#多维" class="headerlink" title="多维"></a>多维</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">25</span>).reshape(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 索引,第3行第4列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>]) <span class="comment"># 第2行到第5行的第3个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[:,<span class="number">2</span>]) <span class="comment"># 每行第3个数 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">5</span>,:]) <span class="comment"># 第2行到第5行的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">1</span>]) <span class="comment"># 表示最后一行所有元素,eq：a[-1,:]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">2</span>]) <span class="comment"># 表示的是第3列的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
---------------
13
---------------
[ 7 12 17 22]
---------------
[ 2  7 12 17 22]
---------------
[[ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
---------------
[20 21 22 23 24]
---------------
[ 2  7 12 17 22]
[15 16 17 18 19]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">24</span>).reshape(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...]) <span class="comment"># 表示第2个里面的所有元素 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...,<span class="number">1</span>,:])<span class="comment"># 表示第2个里面第2行元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">2</span>])<span class="comment"># 表示每个里面第3列元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>])<span class="comment"># 表示第3个里面的第一个元素</span></span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3]
  [ 4  5  6  7]]

 [[ 8  9 10 11]
  [12 13 14 15]]

 [[16 17 18 19]
  [20 21 22 23]]]
---------------
[[ 8  9 10 11]
 [12 13 14 15]]
---------------
[12 13 14 15]
---------------
[[ 2  6]
 [10 14]
 [18 22]]
---------------
16
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a =np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a: <span class="comment"># 循环遍历打印每行元素</span></span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.flat: <span class="comment"># 循环打印每个元素</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
---------------
[0 1 2 3]
[4 5 6 7]
[ 8  9 10 11]
---------------
0
1
2
3
4
5
6
7
8
9
10
11
</code></pre><h1 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h1><p>一个数组的形状是由每个轴的元素数量决定的</p>
<h2 id="改变数组形状"><a href="#改变数组形状" class="headerlink" title="改变数组形状"></a>改变数组形状</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.reshape(<span class="number">3</span>,<span class="number">4</span>))<span class="comment"># 返回一个改变后的数组，但不改变a中元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T)<span class="comment"># a的转置，但不改变a中元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
------------------------
[[6. 6. 1. 4.]
 [4. 5. 7. 3.]
 [7. 0. 4. 7.]]
------------------------
[[6. 4. 7.]
 [6. 5. 0.]
 [1. 7. 4.]
 [4. 3. 7.]]
------------------------
(4, 3)
------------------------
(3, 4)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.resize((<span class="number">2</span>,<span class="number">6</span>)))<span class="comment">#resize函数可以改变a中的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
------------------------
None
------------------------
[[0 1 2 3 4 5]
 [6 7 8 9 0 0]]
</code></pre><h2 id="将不同数组堆叠在一起"><a href="#将不同数组堆叠在一起" class="headerlink" title="将不同数组堆叠在一起"></a>将不同数组堆叠在一起</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.linspace(<span class="number">2</span>,<span class="number">20</span>,<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a,b)))<span class="comment">#垂直拼在一块</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a,b)))<span class="comment">#水平拼在一块</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 2.  8.]
 [14. 20.]]
------------------------
[[8. 4.]
 [0. 7.]]
------------------------
[[ 2.  8.]
 [14. 20.]
 [ 8.  4.]
 [ 0.  7.]]
------------------------
[[ 2.  8.  8.  4.]
 [14. 20.  0.  7.]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.column_stack((a,b))<span class="comment">#此时效果感觉跟hstack差不多</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2.,  8.,  8.,  4.],
       [14., 20.,  0.,  7.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">b=np.array([<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.column_stack((a,b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a,b)))<span class="comment">#这样子的话hstack和column_stack的区别就体现出来了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.row_stack((a,b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a,b)))<span class="comment">#vtack和row_stack的没有区别</span></span><br></pre></td></tr></table></figure>
<pre><code>a [1 2]
------------------------
b [3 4]
------------------------
[[1 3]
 [2 4]]
------------------------
[1 2 3 4]
------------------------
[[1 2]
 [3 4]]
------------------------
[[1 2]
 [3 4]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a[:,np.newaxis]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">d = b[:,np.newaxis]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d&quot;</span>,d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((c,d)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.row_stack((c,d))) <span class="comment"># 结果还是一样，</span></span><br><span class="line"><span class="comment"># hstack和column_stack在一维数组的堆叠中是有区别的</span></span><br><span class="line"><span class="comment"># 但是没有发现vstack和row_stack数组堆叠的区别</span></span><br></pre></td></tr></table></figure>
<pre><code>c [[1]
 [2]]
------------------------
d [[3]
 [4]]
------------------------
[[1]
 [2]
 [3]
 [4]]
------------------------
[[1]
 [2]
 [3]
 [4]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a[:,np.newaxis]<span class="comment"># newaxis可以将行向量转化成列向量</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1],
       [2],
       [3],
       [4]])
</code></pre><p><strong>r_</strong>  和 <strong>c_</strong> 的堆叠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment"># 允许使用范围操作符 :堆叠方式感觉跟vstack类似</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">b = np.c_[<span class="number">1</span>:<span class="number">4</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]] <span class="comment"># 堆叠方式感觉跟hstack类似</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3 4 5]
------------------------
[[1 4]
 [2 5]
 [3 6]]
</code></pre><h2 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hsplit(a,<span class="number">3</span>))<span class="comment"># 沿数组水平轴拆分数组,返回的数组形状相同</span></span><br><span class="line"><span class="built_in">print</span>(np.hsplit(a,(<span class="number">1</span>,<span class="number">4</span>)))<span class="comment"># 表示第1列和第4列后面切一刀分成三个数组</span></span><br></pre></td></tr></table></figure>
<pre><code>a [[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]
------------------------
[array([[0, 1],
       [6, 7]]), array([[2, 3],
       [8, 9]]), array([[ 4,  5],
       [10, 11]])]
[array([[0],
       [6]]), array([[1, 2, 3],
       [7, 8, 9]]), array([[ 4,  5],
       [10, 11]])]
</code></pre><p>当然同理vsplit就是按垂直轴分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.vsplit(a,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[array([[0, 1, 2, 3, 4, 5]]), array([[ 6,  7,  8,  9, 10, 11]])]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.array_split(a,<span class="number">2</span>)) <span class="comment"># array_split将可以数组拆分成大小相等的多个子数组</span></span><br></pre></td></tr></table></figure>
<pre><code>[array([[0, 1, 2, 3, 4, 5]]), array([[ 6,  7,  8,  9, 10, 11]])]
</code></pre><h1 id="拷贝和视图"><a href="#拷贝和视图" class="headerlink" title="拷贝和视图"></a>拷贝和视图</h1><h2 id="完全不复制"><a href="#完全不复制" class="headerlink" title="完全不复制"></a>完全不复制</h2><blockquote>
<p>简单分配不会复制数组对象或其数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a) <span class="comment"># 由此可以看出a,b是名字不同的相同数组，</span></span><br><span class="line"><span class="comment"># 这也就是python引用传递的特性，跟C语言的赋值操作不大一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------&quot;</span>)</span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">4</span> <span class="comment"># 通过改变b，改变a的形状</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>True
-------------------
(3, 4)
</code></pre><h2 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h2><blockquote>
<p>拷贝后<strong>内存地址没发生变化</strong></p>
</blockquote>
<p>用view方法可以创建一个查看相同数据的新数组对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a.view()</span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c.base <span class="keyword">is</span> a)<span class="comment"># 可以看出两者不一样，但是所存储的内容一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------&quot;</span>)</span><br><span class="line">c.shape=<span class="number">2</span>,<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)<span class="comment"># a 的形状也没发生变化</span></span><br><span class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># 神奇的事情发生了a中对应的数组元素也发生了改变</span></span><br></pre></td></tr></table></figure>
<pre><code>False
---------------------
True
---------------------
(3, 4)
[[   0    1    2    3]
 [1234    5    6    7]
 [   8    9   10   11]]
</code></pre><p><strong>原因：切片数组会返回一个视图</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = a[:,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">s[:]=<span class="number">10</span> <span class="comment"># 这里s[:]是s的一个视图</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># a的值发生了变化</span></span><br></pre></td></tr></table></figure>
<pre><code>[[   0   10   10    3]
 [1234   10   10    7]
 [   8   10   10   11]]
</code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><blockquote>
<p><strong>内存地址已经发生了变化</strong></p>
</blockquote>
<p>用copy方法可以<strong>生成数组及其数据的完整副本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = a.copy()</span><br><span class="line"><span class="built_in">print</span>(d <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d.base <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line">d[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#也就是说用了copy方法后d和a是两个值相等，但完全不同的数组</span></span><br></pre></td></tr></table></figure>
<pre><code>False
-------------
False
-------------
[[   0   10   10    3]
 [1234   10   10    7]
 [   8   10   10   11]]
</code></pre><p>有时，如果不再需要原始数组，则应在切片后调用 copy。例如，假设a是一个巨大的中间结果，最终结果b只包含a的一小部分，那么在用切片构造b时应该做一个深拷贝,这样就可以只保留部分的a，将a的所占内存释放掉</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>1.第一章-概述</title>
    <url>/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>学了很多前端的知识，但万丈高楼平地起，基础知识很重要，随着前端学习的深入，也发现系统学习计网知识的必要，理论虽然很枯燥，但为了能够提升自己，还是加油吧！</p>
</blockquote>
<h1 id="1、计算机网络概述"><a href="#1、计算机网络概述" class="headerlink" title="1、计算机网络概述"></a>1、计算机网络概述</h1><blockquote>
<p>就是把一个个计算机系统，用 <strong>通信设备</strong> 与 <strong>线路</strong> 连接起来，由软件实现 <strong>资源共享</strong> 和 <strong>信息传递</strong> 的系统</p>
</blockquote>
<h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h2><p>计算机网络是 <strong>互连</strong> 、<strong>自治</strong> 的计算机集合</p>
<p><strong>互连</strong>：互联互通&nbsp;通信链路：一些传输介质，比如光纤、卫星、无线电波这类东西</p>
<p><strong>自治</strong>：无主从关系，也就是彼此独立，不能相互控制</p>
<h2 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2. 功能"></a>1.2. 功能</h2><h3 id="⭐1-2-1-数据通信"><a href="#⭐1-2-1-数据通信" class="headerlink" title="⭐1.2.1. 数据通信"></a>⭐1.2.1. 数据通信</h3><p>保证了不同主机之间的<strong>连通性</strong></p>
<h3 id="1-2-2-资源共享"><a href="#1-2-2-资源共享" class="headerlink" title="1.2.2. 资源共享"></a>1.2.2. 资源共享</h3><p>硬件：比如打印机，我们不一定私自占有这台打印机，可以同时使用它</p>
<p>软件：不需要下载到主机上来，就可以一起使用这个软件</p>
<p>数据：很常见，比如现在的知乎文章，百度文库等等</p>
<h3 id="1-2-3-分布式处理"><a href="#1-2-3-分布式处理" class="headerlink" title="1.2.3. 分布式处理"></a>1.2.3. 分布式处理</h3><p>多台计算机各自承担同一工作任务的不同部分 </p>
<p>常见的平台：Hadoop 平台</p>
<h3 id="1-2-4-提高可靠性"><a href="#1-2-4-提高可靠性" class="headerlink" title="1.2.4. 提高可靠性"></a>1.2.4. 提高可靠性</h3><p>如果一台工作机宕机了，那么另外一条链路上的主机（替代机）就可以替代它进行工作，从而保证网络的可靠性</p>
<span id="more"></span>
<h3 id="1-2-5-负载均衡"><a href="#1-2-5-负载均衡" class="headerlink" title="1.2.5. 负载均衡"></a>1.2.5. 负载均衡</h3><p>就是多台计算机之间工作量基本保持均衡</p>
<h2 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3. 组成"></a>1.3. 组成</h2><h3 id="1-3-1-组成部分"><a href="#1-3-1-组成部分" class="headerlink" title="1.3.1. 组成部分"></a>1.3.1. 组成部分</h3><p>由硬件、软件、协议组成</p>
<p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/Snipaste_2021-11-15_13-38-14.png"></p>
<p>通过协议让资源安全可靠的进行传输</p>
<h3 id="⭐1-3-2-工作方式"><a href="#⭐1-3-2-工作方式" class="headerlink" title="⭐1.3.2. 工作方式"></a>⭐1.3.2. 工作方式</h3><pre class="mermaid">graph LR
a(工作方式)--->a1("<b>边缘部分</b><br>(主机存在的部分)")
a1---a11("<b>用户直接使用</b><br>(可以进行通信<br>和资源的共享)")
a11--->a111(C/SF方式)
a11--->a112(P2P方式)
a--->a2(<b>核心部分</b>)
a2---a21("<b>为边缘部分服务</b><br>（包括一些服务器<br>还有大量的网络）")</pre>



<h3 id="⭐1-3-3-功能组成"><a href="#⭐1-3-3-功能组成" class="headerlink" title="⭐1.3.3. 功能组成"></a>⭐1.3.3. 功能组成</h3><script type="math/tex; mode=display">
\text{功能组成}
\begin{cases}
\;\text{通信子网：}\text{实现}{\color{green}{\text{数据通信} } }\\
\\
\;\text{资源子网：}\text{实现}{\color{green}{\text{资源共享} } } / \text{数据处理}
\end{cases}</script><p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/Snipaste_2021-11-15_14-06-09.png" style="zoom: 33%;"></p>
<h2 id="1-4-分类"><a href="#1-4-分类" class="headerlink" title="1.4.分类"></a>1.4.分类</h2><ul>
<li><p>按 <strong>分布范围</strong> 分：<code>广域网(WAN)</code> <code>城域网(MAN)</code> <code>局域网(LAN)</code> <code>个人区域(PAN)网</code></p>
<ul>
<li>局域网：<strong>广播技术</strong>，广域网：<strong>交换技术</strong></li>
</ul>
</li>
<li><p>按 <strong>使用者</strong> ：</p>
<script type="math/tex; mode=display">
\begin{cases}
\;\text{公用网：交钱就可以使用的网络，比如电信、联通等提供的网络}\\ \\ \;\text{专用网：只有相应的权限才能进入的网络，比如军队网络}
\end{cases}</script></li>
<li><p>按 <strong>交换技术</strong> ：电路交换&nbsp;&nbsp;报文交换&nbsp;&nbsp;分组交换</p>
</li>
<li><p>按 <strong>拓扑结构</strong> ：总线型&nbsp;&nbsp;星型&nbsp;&nbsp;环型&nbsp;&nbsp;网状型</p>
<p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/3.png" style="zoom: 50%;"></p>
</li>
<li><p>按 <strong>传输技术</strong> ：</p>
<script type="math/tex; mode=display">
\begin{cases}
\;\color{green}\text{广播式网络}\\ \\ 
\;\color{red}\text{点对点网络}
\end{cases}</script></li>
</ul>
<h1 id="二、标准化工作"><a href="#二、标准化工作" class="headerlink" title="二、标准化工作"></a>二、标准化工作</h1><blockquote>
<p><strong>要实现不同厂商的软、硬件之间相互连通，必须遵从统一的标准</strong></p>
</blockquote>
<h2 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1. 分类"></a>2.1. 分类</h2><script type="math/tex; mode=display">
\begin{cases}
\;\large\text{法定标准} : \text{权威机构指定的标准}\quad OSI\\ \\
\;\large\text{事实标准} : \text{某些占市场主流公司指定的标准}\quad TCP/IP
\end{cases}</script><h2 id="2-2-RFC——因特网标准的形式"><a href="#2-2-RFC——因特网标准的形式" class="headerlink" title="2.2. RFC——因特网标准的形式"></a>2.2. RFC——因特网标准的形式</h2><p>RFC要上升为因特网正式标准的<strong>四个阶段</strong>：</p>
<ol>
<li><strong>因特网草案</strong>(Internet Draft)：这个阶段还不是RFC文档，先拟定草案发给 rfc-editor @rfc-editor.org，如果通过就进入下一个阶段</li>
<li><strong>建议标准</strong>(Proposed Standard)：从这个阶段开始成为RFC文档，放到因特网上面让他人修改，提意见……</li>
<li><s><strong>草案标准</strong>(Draft Standard)：拿到IETF、IAB进行审核</s></li>
<li><strong>因特网标准</strong>(Internet Standard)</li>
</ol>
<h2 id="2-3-标准化工作的相关组织"><a href="#2-3-标准化工作的相关组织" class="headerlink" title="2.3. 标准化工作的相关组织"></a>2.3. 标准化工作的相关组织</h2><p><strong>国际标准化组织 ISO</strong>：OSI参考模型、HDLC协议</p>
<p><strong>国际电信联盟 ITU</strong>：制定通信规则</p>
<p><strong>国际电气电子工程师协会 IEEE</strong>：学术机构、IEEE802系列标准、5G</p>
<p><strong>Internet工程任务组 IETF</strong>：负责因特网相关标准的制定 RFC xxxx</p>
<h1 id="三、性能指标"><a href="#三、性能指标" class="headerlink" title="三、性能指标"></a>三、性能指标</h1><h2 id="3-1-速率"><a href="#3-1-速率" class="headerlink" title="3.1. 速率"></a>3.1. 速率</h2><p>速率即 <strong>数据率</strong> 或称 <strong>数据传输率</strong> 或 <strong>比特率</strong></p>
<p>数据传输的单位就是<strong>比特</strong>，也就是说数据传输时是一个比特一个比特的进入信道</p>
<ul>
<li>比特的 <strong>表现形式</strong>有两种：1/0，<strong>单位</strong>：位</li>
</ul>
<p>这里的速率就是连接在计算机网络上的 <strong>主机</strong> 在数字信道上传送数据 <strong>位数的速率</strong></p>
<ul>
<li>单位是b/s，kb/s，Mb/s，Gb/s，Tb/s</li>
</ul>
<p><strong>速率单位换算</strong>：</p>
<ul>
<li>千：1 kb/s = $10^3$ b/s</li>
<li>兆：1 Mb/s = $10^6$ b/s</li>
<li>吉：1 Gb/s = $10^9$ b/s</li>
<li>太：1 Tb/s = $10^{12}$ b/s</li>
</ul>
<p><strong>注意：</strong>这里是速率的换算单位，所以是 $10^3$ 倍，要与存储容量进行区分</p>
<p><strong>存储容量：1Byte（字节）=8 bit（比特）</strong></p>
<ul>
<li>1 KB = $2^{10}$ B = 1024*8 b</li>
<li>1 MB = $2^{10}$ KB = 1024 KB</li>
<li>1 GB = $2^{10}$ MB = 1024 MB</li>
<li>1 TB = $2^{10}$ GB = 1024 GB </li>
</ul>
<p><strong>这里也要注意 B 和 b 是有区别</strong></p>
<h2 id="3-2-带宽"><a href="#3-2-带宽" class="headerlink" title="3.2. 带宽"></a>3.2. 带宽</h2><ol>
<li>“<strong>带宽</strong>” 原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</li>
<li>计算机网络中，<strong>带宽</strong> 用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。</li>
</ol>
<p>带宽其实就是网络设备所支持的最高速度</p>
<p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/4.png" style="zoom: 50%;"></p>
<h2 id="3-3-吞吐量"><a href="#3-3-吞吐量" class="headerlink" title="3.3. 吞吐量"></a>3.3. 吞吐量</h2><p>表示在 <strong>单位时间</strong> 内通过 <strong>某个网络（或信道、接口）</strong> 的数据量</p>
<p>吞吐量受网络的带宽或网络的额定速率的限制</p>
<h2 id="3-4-时延"><a href="#3-4-时延" class="headerlink" title="3.4. 时延"></a>3.4. 时延</h2><p>指数据（报文、分组、比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫 <strong>延迟</strong> 或 <strong>迟延</strong> 。单位是 s</p>
<ul>
<li><strong>发送时延</strong>（传输时延）：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间</li>
</ul>
<script type="math/tex; mode=display">
\text{发送时延}=\frac{\text{数据长度} }{\text{信道带宽(发送速率)}}</script><ul>
<li><p><strong>传播时延</strong>：取决于电磁波传播速度和链路长度</p>
<script type="math/tex; mode=display">
\text{传播时延}=\frac{\text{信道长度} }{\text{电磁波在信道上的传播速率} }</script></li>
<li><p><strong>排队时延</strong>：等待输出/入链路可用</p>
</li>
<li><strong>处理时延</strong>：检错，找出口</li>
</ul>
<p>高速链路只是<strong>提高了带宽</strong>，也就是<strong>减少了发送时延</strong>，其他都是不变的</p>
<h3 id="3-4-1-时延带宽积"><a href="#3-4-1-时延带宽积" class="headerlink" title="3.4.1. 时延带宽积"></a>3.4.1. 时延带宽积</h3><script type="math/tex; mode=display">
\text{时延带宽积} = \text{传播时延}\times\text{带宽}</script><p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/5.png" style="zoom: 33%;"></p>
<p>时延带宽积又称为以 <strong>比特为单位的链路长度</strong></p>
<h3 id="3-4-2-往返时延-RTT"><a href="#3-4-2-往返时延-RTT" class="headerlink" title="3.4.2. 往返时延 RTT"></a>3.4.2. 往返时延 RTT</h3><p>从发送方发送数据开始，到发送方收到接受方的确认（接收方收到数据后立即发送确认），总共经历的时延。</p>
<script type="math/tex; mode=display">
\text{RTT越大，在收到确认之前，可以发送的数据越多}\\
\\
\text{RTT 包括}\;
\begin{cases}
\;\text{往返传播时延=传播时延 * 2}\\ \\
\;\text{末端处理时间}
\end{cases}</script><h2 id="3-5-利用率"><a href="#3-5-利用率" class="headerlink" title="3.5. 利用率"></a>3.5. 利用率</h2><script type="math/tex; mode=display">
{\large\color{skyblue}\text{利用率} }
\begin{cases}
\;\text{信道利用率}:\;\dfrac{\text{有数据通过时间} }{\text{（有+无）数据通过时间} }\\ \\
\;\text{网络利用率}:\;信道利用率加权平均值
\end{cases}</script><p>其实这里可以类比交通车道，数据越多，利用率越高，但会越拥挤。</p>
<p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/6.png" style="zoom: 67%;"></p>
<h1 id="四、分层结构"><a href="#四、分层结构" class="headerlink" title="四、分层结构"></a>四、分层结构</h1><h2 id="4-1-分层的原因"><a href="#4-1-分层的原因" class="headerlink" title="4.1. 分层的原因"></a>4.1. 分层的原因</h2><p>发送文件前要完成的工作非常多：</p>
<ul>
<li>发起通信的计算机必须将数据通信的通路进行激活。</li>
<li>要告诉网络如何识别目的主机</li>
<li>发起通信的计算机要查明目的主机是否开机，并且网络连接正常</li>
<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作</li>
<li>确保差错和意外可以解决</li>
<li>……</li>
</ul>
<h2 id="4-2-如何分层"><a href="#4-2-如何分层" class="headerlink" title="4.2. 如何分层"></a>4.2. 如何分层</h2><ul>
<li>各层之间相互<strong>独立</strong>，每层只实现一种相对独立的功能</li>
<li>每层之间<strong>界面自然清晰</strong>，易于理解，相互交流极可能少</li>
<li>结构上可分割开。每层都采用最合适的技术来实现</li>
<li>保持下层对上层的独立性，<strong>上层单向使用下层提供的服务</strong></li>
<li>整个分层结构应该能促进标准化工作</li>
</ul>
<h2 id="4-3-正式的分层结构"><a href="#4-3-正式的分层结构" class="headerlink" title="4.3. 正式的分层结构"></a>4.3. 正式的分层结构</h2><ol>
<li><strong>实体：</strong>第n层中的活动元素称为<strong>n层实体</strong>。同一层的实体叫<strong>对等实体</strong></li>
<li><strong>协议：</strong>为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议【水平】<ul>
<li>语法：规定传输数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：规定各种操作的顺序</li>
</ul>
</li>
<li><strong>接口（访问服务点SAP）：</strong> 上层使用下层服务的入口</li>
<li><strong>服务：</strong> 下层为相邻上层提供的功能调用。【垂直】</li>
</ol>
<p>SDU （service database unit）服务数据单元：为完成用户所要求的功能而应传送的数据。</p>
<p>PCI （protocal control information）协议控制信息：控制协议操作的信息。</p>
<p>PDU （protocal database unit）协议数据单元：对等层次之间传送的数据单位。</p>
<script type="math/tex; mode=display">
\text{PCI}+\text{SDU}=\text{PDU}</script><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4. 总结"></a>4.4. 总结</h2><p>网络体系结构是从<strong>功能</strong>上描述计算机网络结构</p>
<p>计算机网络体系结构（简称网络体系结构）是<strong>分层结构</strong></p>
<p>每层遵循某个/些<strong>网络协议</strong>以完成本层功能</p>
<p><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合</p>
<p>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能</p>
<p>仅仅在<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上层完全屏蔽</p>
<p>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</p>
<h1 id="五、OSI参考模型"><a href="#五、OSI参考模型" class="headerlink" title="五、OSI参考模型"></a>五、OSI参考模型</h1><script type="math/tex; mode=display">
\text{计算机网络分层结构}
\begin{cases}
{\color{red}\text{7层}}\;\text{OSI 参考模型}\;{\small\text{法定标准}  }\\
\\
\\
{\color{red}\text{4层}}\;\text{TCP/IP 参考模型}\;{\small\text{事实标准} }
\end{cases}</script><p>根据这两个模型，我们就可以总结它们的优点和缺点，得到了5层的体系结构，主要的目的就是为了我们学习更方便</p>
<h2 id="5-1-ISO-OSI参考模型"><a href="#5-1-ISO-OSI参考模型" class="headerlink" title="5.1. ISO/OSI参考模型"></a>5.1. ISO/OSI参考模型</h2><blockquote>
<p>OSI 理论成功，市场失败</p>
</blockquote>
<p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/7.png" style="zoom: 33%;"></p>
<h2 id="5-2-ISO-OSI参考模型解释通信过程"><a href="#5-2-ISO-OSI参考模型解释通信过程" class="headerlink" title="5.2. ISO/OSI参考模型解释通信过程"></a>5.2. ISO/OSI参考模型解释通信过程</h2><p><img src="/2021/08/22/1-%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/8.png" style="zoom: 50%;"></p>
<h2 id="5-3-应用层"><a href="#5-3-应用层" class="headerlink" title="5.3. 应用层"></a>5.3. 应用层</h2><blockquote>
<p>所有能和用户交互产生网络流量的程序</p>
</blockquote>
<p>典型应用层服务：</p>
<ul>
<li>文件传输（FTP）</li>
<li>电子邮件（SMTP）</li>
<li>万维网（HTTP）</li>
<li>……</li>
</ul>
<h2 id="5-4-表示层"><a href="#5-4-表示层" class="headerlink" title="5.4. 表示层"></a>5.4. 表示层</h2><blockquote>
<p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
</blockquote>
<ul>
<li><p><strong>功能一：数据格式变换</strong> （翻译官）</p>
</li>
<li><p><strong>功能二：数据加密解密</strong> </p>
</li>
<li><p><strong>功能三：数据压缩和恢复</strong></p>
</li>
</ul>
<h2 id="5-5-会话层"><a href="#5-5-会话层" class="headerlink" title="5.5. 会话层"></a>5.5. 会话层</h2><blockquote>
<p>向表示层实体/用户进程提供 <strong>建立连接</strong> 并在连接上 <strong>有序</strong> 地 <strong>传输</strong> 数据</p>
</blockquote>
<p>这就是会话，也是<strong>建立同步</strong>（SYN）</p>
<ul>
<li><p><strong>功能一：</strong>建立、管理、终止会话</p>
</li>
<li><p><strong>功能二：</strong>使用校验点可使会话在通信失效时从 <strong>校验点/同步点</strong> 继续恢复通信，实现数据同步</p>
</li>
</ul>
<p>适用于传输大文件。</p>
<p>主要协议：ADSP、ASP</p>
<h2 id="5-6-传输层"><a href="#5-6-传输层" class="headerlink" title="5.6. 传输层"></a>5.6. 传输层</h2><blockquote>
<p>负责主机中 <strong>两个进程</strong> 的通信，即 <strong>端到端</strong> 的通信。传输单位是报文段或用户数据报</p>
</blockquote>
<ul>
<li><p><strong>功能一：</strong>可靠传输、不可靠传输</p>
</li>
<li><p><strong>功能二：</strong>差错控制</p>
</li>
<li><p><strong>功能三：</strong>流量控制</p>
</li>
<li><p><strong>功能四：</strong>复用分用</p>
</li>
</ul>
<p>复用：多个应用层进程可同时使用下面运输层的服务</p>
<p>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</p>
<blockquote>
<p>ps: 有人愿意把运输层称为传输层，理由是这一层用的TCP协议就叫做传输控制协议。但OSI定义的第四层使用的是Transport，而不是Transmission，所以使用运输层比较准确</p>
</blockquote>
<p>主要协议：TCP、UDP</p>
<h2 id="5-7-网络层"><a href="#5-7-网络层" class="headerlink" title="5.7. 网络层"></a>5.7. 网络层</h2><blockquote>
<p>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位<strong>数据报</strong></p>
</blockquote>
<ul>
<li><strong>功能一：</strong>路由选择（<strong>最佳路径</strong>）</li>
<li><strong>功能二：</strong>流量控制</li>
<li><strong>功能三：</strong>差错控制</li>
<li><strong>功能四：</strong>拥塞控制<ul>
<li>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施，缓解这种拥塞。</li>
</ul>
</li>
</ul>
<p>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p>
<h2 id="5-8-数据链路层"><a href="#5-8-数据链路层" class="headerlink" title="5.8. 数据链路层"></a>5.8. 数据链路层</h2><blockquote>
<p>主要任务是把网络层传下来的数据报 <strong>组装成帧</strong></p>
<p>数据链路层/链路层的传输单位是 <strong>帧</strong></p>
</blockquote>
<ul>
<li><strong>功能一：</strong>成帧（定义帧的开始和结束）</li>
<li><strong>功能二：</strong>差错控制（<strong>帧错+位错</strong>）</li>
<li><strong>功能三：</strong>流量控制</li>
<li><strong>功能四：</strong>访问（接入）控制（<strong>控制对信道的访问</strong>）</li>
</ul>
<h2 id="5-9-物理层"><a href="#5-9-物理层" class="headerlink" title="5.9. 物理层"></a>5.9. 物理层</h2><blockquote>
<p>主要任务是在 <strong>物理媒体</strong> 上实现比特流的 <strong>透明传输</strong></p>
<p>物理层传输单位是 <strong>比特</strong></p>
</blockquote>
<p><strong>透明传播：</strong>指不管所传数据是什么样的比特组合，都应当能够在链路上传送</p>
<ul>
<li><strong>功能一：</strong>定义接口特性</li>
<li><strong>功能二：</strong>定义传输模式（<strong>单工、半双工、双工</strong>）</li>
<li><strong>功能三：</strong>定义传输速率</li>
<li><strong>功能四：</strong>比特同步</li>
<li><strong>功能五：</strong>比特编码</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>1.线性表</title>
    <url>/2021/07/26/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>就是指把所有的结点用一根 <strong>直线</strong>  串起来</p>
<h1 id="连续存储-数组"><a href="#连续存储-数组" class="headerlink" title="连续存储[数组]"></a>连续存储[数组]</h1><p>1.数组是元素类型相同，大小相等的一组数</p>
<p><strong>优缺点</strong><br>优点：存取速度很快</p>
<p>缺点：</p>
<ul>
<li>事先必须知道数组的长度</li>
<li>插入删除元素很慢</li>
<li>空间通常有限制</li>
<li>需要大块连续的内存块<span id="more"></span>
<h1 id="离散存储-链表"><a href="#离散存储-链表" class="headerlink" title="离散存储[链表]"></a>离散存储[链表]</h1></li>
</ul>
<pre class="mermaid">flowchart LR

subgraph "链表"
a["NULL | next"]-->b["a1  |  next"]-->c["· · ·"]-->d["a_n-1 | next"]-->e["a_n | NULL"]
end
b1((首元结点)).->b

a1((头指针))-.->a
a2((头结点))-.->a
e-.->e1((尾结点))</pre>

<h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul>
<li>结点：数据元素的映像。由数据域和指针域两部分组成</li>
<li>首元结点：第一个有效结点</li>
<li>尾结点：最后一个有效结点</li>
<li>头结点：<ul>
<li>头结点的数据类型和首结点类型一样</li>
<li>第一个有效结点之前的那个结点</li>
<li>不存放有效数据</li>
<li>加头结点的目的是 <strong>方便对链表的操作</strong></li>
</ul>
</li>
<li>头指针：指向头结点的指针变量</li>
<li>尾指针：指向尾结点的指针变量</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>n个结点离散分配，彼此通过指针相连，每个结点只有一个<strong>前驱结点</strong>，每个结点只有一个<strong>后续结点</strong>，首结点没有前驱结点，尾结点没有后续结点</p>
</blockquote>
<p>大白话就是每个结点前后都有结点，当然除了首结点和尾节点外</p>
<pre class="mermaid">flowchart LR
a[首结点]-->b[普通结点]-->c[尾结点]</pre>



<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>空间没有限制 </li>
<li>插入删除元素很快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>存储密度小，毕竟 <strong>指针域</strong> 这玩意需要占空间</p>
<script type="math/tex; mode=display">
\text{ 存储密度 } = \frac{\text{该结点数据所占空间} }{ \text{该结点所占总空间} }</script></li>
<li><p>链式存储结构是 <strong>非随机存取</strong> 结构，对任一结点的操作都要从头指针链查找到该结点，这增加了算法的复杂度</p>
</li>
</ul>
<p><strong>如果希望通过一个函数来对链表进行处理我们至少需要接受哪些参数？</strong><br>只需要一个参数：头指针</p>
<p>因为我们可以通过头指针推算出链表的其他所有参数</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p><strong>创建链表,并完成一些功能</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125; NODE,*PNODE; <span class="comment">//NODE等价于struct Node,  PNODE等价于struct Node *</span></span><br><span class="line"></span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//输出链表的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE)</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//判断链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE pHead)</span></span>;<span class="comment">//链表排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;<span class="comment">//向链表中插入一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span>,<span class="keyword">int</span>*)</span></span>;<span class="comment">//删除链表中的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;<span class="comment">//等价于struct Node*pHead = NULL;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">	pHead = create_list();<span class="comment">//create_list()功能：创建一个非循环单链表</span></span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	<span class="comment">//int len = length_list(pHead);</span></span><br><span class="line">	<span class="comment">//printf(&quot;链表长度为%d\n&quot;,len);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//insert_list(pHead,4,33);//插入结点</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	<span class="keyword">if</span>(delete_list(pHead,<span class="number">4</span>,&amp;val)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除成功，你删除的元素是：%d\n&quot;</span>,val);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败，删除的元素不存在\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	<span class="comment">//sort_list(pHead);</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	<span class="keyword">if</span>(is_empty(pHead))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表为空\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表不空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//用来存放有效结点的个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> val;<span class="comment">//用来临时存放用户输入的结点的值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入结点个数：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="comment">//分配了一个不存放有效数字的头结点</span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配失败，程序终止/n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    <span class="comment">//规定pTail永远指向尾结点，这里也就是指向头结点</span></span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d结点的值：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;分配失败，程序终止\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pTail-&gt;pNext = pNew;<span class="comment">//这里是让Ptail指针域存放临时结点</span></span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;<span class="comment">//清空临时结点的指针域</span></span><br><span class="line">        pTail = pNew;<span class="comment">//这里是pTail指针指向了pNew</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE pHead)</span> </span>&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pHead-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE pHead)</span> </span>&#123;</span><br><span class="line">	PNODE p = pHead-&gt;pNext;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		len++;</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE pHead)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,t;</span><br><span class="line">	<span class="keyword">int</span> len = length_list(pHead);</span><br><span class="line">	PNODE p,q;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++,p=p-&gt;pNext) &#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>,q=p-&gt;pNext;j&lt;len;j++,q=q-&gt;pNext) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data) &#123; <span class="comment">//类似于数组中的：a[i]&gt;a[j]</span></span><br><span class="line">				t=p-&gt;data;</span><br><span class="line">				p-&gt;data=q-&gt;data;</span><br><span class="line">				q-&gt;data=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pHead所指向的链表的第pos个结点的前面插入一个新的结点，</span></span><br><span class="line"><span class="comment">//该结点的值是val,并且pos的值是从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	PNODE p =pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i&lt;pos<span class="number">-1</span>) &#123;</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span>(pNew == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态分配内存失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;data=val;</span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	p-&gt;pNext=pNew;</span><br><span class="line">	pNew-&gt;pNext=q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> *pVal)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i&lt;pos<span class="number">-1</span>) &#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	*pVal = q-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除p结点后面的结点</span></span><br><span class="line">	p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	q = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分类：</strong></p>
<ul>
<li><p>单链表</p>
</li>
<li><p>双向链表：每一个结点有两个 <strong>指针域</strong></p>
</li>
<li>循环单链表:能通过任何一个结点找到其他所有的结点</li>
<li>循环双向链表</li>
<li>非循环链表</li>
</ul>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><blockquote>
<p>尾指针指向头结点</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>如果表的操作常常是在表的首尾位置进行，用循环链表可以方便寻找，降低时间复杂度</li>
</ul>
<p><strong>循环链表的合并</strong></p>
<ul>
<li>p存表头结点</li>
<li>Tb表头连接到Ta表尾</li>
<li>释放Tb表头结点</li>
<li>修改指针</li>
</ul>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表的每个结点再增加一个指向其直接前驱的指针域prior。</p>
<p><strong>优点:</strong><br>容易查找前驱结点和后续结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span> &#123;</span></span><br><span class="line">	Elemtype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125; DuNode,*DuPNode;</span><br></pre></td></tr></table></figure>
<h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><ul>
<li>建立单链表<ul>
<li>头插法—元素插在链表头部<ul>
<li>1.从一个空表开始</li>
<li>2.生成新结点，将读入数据存放到新结点的数据域中</li>
<li>3.最后一个结点开始依次将各结点插入到链表的前端</li>
</ul>
</li>
<li>尾插法—元素插入在链表尾部</li>
</ul>
</li>
<li>遍历</li>
<li>查找</li>
<li>清空</li>
<li>销毁</li>
<li>求长度</li>
<li>排序</li>
<li>删除结点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>错误案例</span><br><span class="line">p-&gt;pNext=p-&gt;pNext-&gt;pNext;<span class="comment">//因为没有free所删除的结点，所以这样会让内存泄漏</span></span><br><span class="line"><span class="number">2.</span>正确写法</span><br><span class="line">r=p-&gt;pNext;<span class="comment">//r指向p后面的那个结点</span></span><br><span class="line">p-&gt;pNext=r-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);<span class="comment">//必须</span></span><br></pre></td></tr></table></figure></li>
<li>插入结点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">r=p-&gt;pNext;<span class="comment">//先用r来存放p的指针域</span></span><br><span class="line">p-&gt;pNext=q;<span class="comment">//使p的指针域指向插入的q结点</span></span><br><span class="line">q-&gt;pNext=r;<span class="comment">//q的指针域就是原来p的指针域</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">q-&gt;pNext=p-&gt;pNext;<span class="comment">//插入的q的指针域替换成p的指针域</span></span><br><span class="line">p-&gt;pNext=q;<span class="comment">//p的指针域指向q</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1.matplotlib入门</title>
    <url>/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h2 id="常见API介绍"><a href="#常见API介绍" class="headerlink" title="常见API介绍"></a>常见API介绍</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>plt.title()</strong><br>(图的标题)</td>
<td style="text-align:center">plt.title(“Matplotlib demo”)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.xlabel()</strong><br>(X轴描述)</td>
<td style="text-align:center">plt.xlabel(“x axis caption”)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.ylabel()</strong><br>(Y轴描述)</td>
<td style="text-align:center">plt.ylabel(“y axis caption”)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.plot()</strong><br> (画图)</td>
<td style="text-align:center">plt.plot(x,y)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.show()</strong><br> (显示)</td>
<td style="text-align:center">plt.show()</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.subplot()</strong><br>(子图绘制)</td>
<td style="text-align:center">plt.subplot(2, 1, 1) 21<br>(第一个图)<br>plt.subplot(2, 1, 2) 21<br>(第二个图)</td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.bar(x, y, align = ‘center’)</strong><br>(条状图)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>plt.figure()</strong><br>存放实例代码生成的图片</td>
<td style="text-align:center">figure(figsize=(8,6),dpi=80)<br>创建一个 8 * 6 点（point）的图，并设置分辨率为 80</td>
</tr>
<tr>
<td style="text-align:center"><strong>xlim()</strong><br>(x轴的上下限)</td>
<td style="text-align:center">xlim(-4.0,4.0)</td>
</tr>
<tr>
<td style="text-align:center"><strong>ylim()</strong><br>(y轴的上下限)</td>
<td style="text-align:center">ylim(-1.0,1.0)</td>
</tr>
<tr>
<td style="text-align:center"><strong>legend()</strong><br>(图例位置)</td>
<td style="text-align:center">legend(loc=‘upper left’)</td>
</tr>
<tr>
<td style="text-align:center"><strong>scatter()</strong><br>(散点图)</td>
<td style="text-align:center">scatter(X,Y)</td>
</tr>
<tr>
<td style="text-align:center"><strong>contourf()</strong><br>(等高线)</td>
<td style="text-align:center">contourf(X, Y, f(X,Y), 8, alpha=.75, cmap=‘jet’)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="rcRarams的属性"><a href="#rcRarams的属性" class="headerlink" title="rcRarams的属性"></a>rcRarams的属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span>   <span class="comment">#这两行需要手动设置</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">‘font.family’</td>
<td style="text-align:left">用于显示字体的名字</td>
</tr>
<tr>
<td style="text-align:left">‘font.style’</td>
<td style="text-align:left">字体风格，正常’normal或斜体’italic’</td>
</tr>
<tr>
<td style="text-align:left">‘font.size’</td>
<td style="text-align:left">字体大小，整数字号或者’large’,’x-small’  </td>
</tr>
</tbody>
</table>
</div>
<p><strong>中文字体的样式</strong><br>(这些必须在matplotlib的font里进行添加，matplotlib里并没有这些,而且matplotlib很多font都不支持中文，虽然有一些支持中文显示，但是个人认为效果不是很好，中文配置也比较麻烦，后续会进行这方面的整理……)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">中文字体</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">‘SimHei’</td>
<td style="text-align:left"><font face="黑体">中文黑体</font></td>
</tr>
<tr>
<td style="text-align:left">‘Kaiti’</td>
<td style="text-align:left"><font face="楷体">中文楷体</font></td>
</tr>
<tr>
<td style="text-align:left">‘LiSu’</td>
<td style="text-align:left"><font face="隶书">中文隶书</font></td>
</tr>
<tr>
<td style="text-align:left">‘FangSong’</td>
<td style="text-align:left"><font face="仿宋">中文仿宋</font></td>
</tr>
<tr>
<td style="text-align:left">‘YouYuan’</td>
<td style="text-align:left"><font face="幼圆">中文幼圆</font></td>
</tr>
<tr>
<td style="text-align:left">‘STSong’</td>
<td style="text-align:left"><font face="华文宋体">华文宋体</font></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">颜色字符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">颜色字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘b’</td>
<td style="text-align:center">蓝色</td>
<td style="text-align:center">‘m’</td>
<td style="text-align:center">洋红色(magenta)</td>
</tr>
<tr>
<td style="text-align:center">‘g’</td>
<td style="text-align:center">绿色</td>
<td style="text-align:center">‘y’</td>
<td style="text-align:center">黄色</td>
</tr>
<tr>
<td style="text-align:center">‘r’</td>
<td style="text-align:center">红色</td>
<td style="text-align:center">‘k’</td>
<td style="text-align:center">黑色</td>
</tr>
<tr>
<td style="text-align:center">‘c’</td>
<td style="text-align:center">青绿色(cyan)</td>
<td style="text-align:center">‘w’</td>
<td style="text-align:center">白色</td>
</tr>
<tr>
<td style="text-align:center">‘#008000’</td>
<td style="text-align:center">RNG某颜色</td>
<td style="text-align:center">‘0.8’</td>
<td style="text-align:center">灰度值字符串</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">风格字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘-‘</td>
<td style="text-align:center">实线</td>
</tr>
<tr>
<td style="text-align:center">‘—‘</td>
<td style="text-align:center">破折线</td>
</tr>
<tr>
<td style="text-align:center">‘-.’</td>
<td style="text-align:center">点划线</td>
</tr>
<tr>
<td style="text-align:center">‘:’</td>
<td style="text-align:center">虚线</td>
</tr>
<tr>
<td style="text-align:center">‘’’’</td>
<td style="text-align:center">无线条</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘.’</td>
<td style="text-align:center">点标记</td>
</tr>
<tr>
<td style="text-align:center">‘,’</td>
<td style="text-align:center">像素标记</td>
</tr>
<tr>
<td style="text-align:center">‘o’</td>
<td style="text-align:center">实心圈标记</td>
</tr>
<tr>
<td style="text-align:center">‘v’</td>
<td style="text-align:center">倒三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘^’</td>
<td style="text-align:center">上三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘&gt;’</td>
<td style="text-align:center">右三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘&lt;’</td>
<td style="text-align:center">左三角标记</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘1’</td>
<td style="text-align:center">下花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘2’</td>
<td style="text-align:center">上花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘3’</td>
<td style="text-align:center">左花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘4’</td>
<td style="text-align:center">右花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘s’</td>
<td style="text-align:center">实心方形标记</td>
</tr>
<tr>
<td style="text-align:center">‘p’</td>
<td style="text-align:center">实心五角标记</td>
</tr>
<tr>
<td style="text-align:center">‘*’</td>
<td style="text-align:center">星形标记</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘h’</td>
<td style="text-align:center">竖六边形标记</td>
</tr>
<tr>
<td style="text-align:center">‘H’</td>
<td style="text-align:center">横六边形标记</td>
</tr>
<tr>
<td style="text-align:center">‘+’</td>
<td style="text-align:center">十字标记</td>
</tr>
<tr>
<td style="text-align:center">‘x’</td>
<td style="text-align:center">x标记</td>
</tr>
<tr>
<td style="text-align:center">‘D’</td>
<td style="text-align:center">菱形标记</td>
</tr>
<tr>
<td style="text-align:center">‘d’</td>
<td style="text-align:center">瘦菱形标记</td>
</tr>
<tr>
<td style="text-align:center">‘\\’</td>
<td style="text-align:center">垂直线标记</td>
</tr>
</tbody>
</table>
</div>
<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h2><p><strong>plot(x,y,formatstring)</strong></p>
<hr>
<ul>
<li><strong>x</strong>: x轴数据，列表或数组，可选参数，当我们在这个函数里，只展示一组数据时，x可省略。</li>
<li><strong>y</strong>： y轴数据，必须有。</li>
<li><strong>format_string</strong>：主要来控制我们画的曲线的格式：颜色，风格,标记，<br>可取三者的组合如：“g-o”,”r-.D”,如果不用组合，则用color,marker,linestyle,三个参数分别指定。</li>
<li><strong>label</strong>： 添加图例的类标。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span>   <span class="comment">#这两行需要手动设置</span></span><br><span class="line">x= np.linspace(-<span class="number">3</span>,<span class="number">3</span>,<span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line">plt.figure() <span class="comment"># 创建显示的窗口</span></span><br><span class="line">plt.plot(x,y1)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(x,y1,<span class="string">&#x27;r-.d&#x27;</span>,linewidth=<span class="number">1.0</span>,) <span class="comment"># r-.d三个参数分别代表color,linestyle,marker</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">plt.ylim((-<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x轴&#x27;</span>,fontdict=&#123;<span class="string">&quot;size&quot;</span>:<span class="number">20</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&quot;weight&quot;</span>:<span class="string">&quot;black&quot;</span>&#125;) <span class="comment"># 设置样式第一种fontdict</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y轴&#x27;</span>,fontsize=<span class="number">20</span>,color=<span class="string">&quot;r&quot;</span>,fontweight=<span class="string">&quot;light&quot;</span>) <span class="comment"># 第二种直接传入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(num=<span class="number">3</span>,figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">new_ticks = np.linspace(-<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(new_ticks)</span><br><span class="line">plt.xticks(new_ticks)</span><br><span class="line">plt.yticks([-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="string">r&#x27;$\alpha$&#x27;</span>,<span class="string">r&#x27;$\beta$&#x27;</span>,<span class="string">r&#x27;$\gamma$&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="comment"># gca = &#x27;get current axis&#x27;</span></span><br><span class="line">plt.tick_params(direction=<span class="string">&#x27;in&#x27;</span>,color=<span class="string">&quot;r&quot;</span>,width=<span class="number">2</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>) <span class="comment"># spines指的是边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment">#ax.xaxis.set_ticks_position(&#x27;bottom&#x27;) # 设置坐标上的数字显示的位置，default，可以不用</span></span><br><span class="line"><span class="comment">#ax.yaxis.set_ticks_position(&#x27;left&#x27;) # default</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>)) <span class="comment"># 将下面的坐标轴移动到0</span></span><br><span class="line">                                             <span class="comment"># &#x27;data&#x27;,&#x27;axes&#x27;,&#x27;outward&#x27;</span></span><br><span class="line">                                             <span class="comment"># &#x27;axes&#x27;:</span></span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>)) <span class="comment"># 将左面的坐标轴移动到0</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>[-1.   -0.25  0.5   1.25  2.  ]
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_1.png" alt="png"></p>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_2.png" alt="png"></p>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_3.png" alt="png"></p>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_17_4.png" alt="png"></p>
<h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">l1, = plt.plot(x,y1,color=<span class="string">&#x27;red&#x27;</span>,linewidth=<span class="number">1.0</span>,linestyle=<span class="string">&#x27;--&#x27;</span>,label=<span class="string">&#x27;Down&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意如果想传入handles，名称后面必须加一个逗号</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">plt.ylim((-<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">l2, = plt.plot(x,y2,label=<span class="string">&#x27;up&#x27;</span>) <span class="comment"># label，这个图像名称</span></span><br><span class="line">plt.legend(handles=[l1,l2,],labels=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],loc=<span class="string">&#x27;best&#x27;</span>) <span class="comment"># legend图例,handle传递两个对象[ , , ,]</span></span><br><span class="line">                                        <span class="comment"># loc指的是位置</span></span><br><span class="line">                                        <span class="comment"># rebel中表示图例中各个线的名称</span></span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_19_0.png" alt="png"></p>
<h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><p><strong><font size="5">annotate()</font></strong></p>
<hr>
<ul>
<li><p><strong>s</strong>: 添加标注的内容，字符串形式。</p>
</li>
<li><p><strong>xy</strong>: 箭头指向的位置，就是我们想添加标注的对象，元组类型输入方式。</p>
</li>
<li><p><strong>xytext</strong>：添加标注的实际位置，标注实际所在位置，可看做箭头输出端。</p>
</li>
<li><p><strong>arrowprops</strong>: 此参数中提供箭头属性字典来绘制从文本到注释点的箭头。</p>
</li>
<li><p><strong>width</strong> : 箭把宽度，整数或浮点数。</p>
</li>
<li><p><strong>frac</strong>：箭头头部所占的比例，小于1。</p>
</li>
<li><p><strong>headwidth</strong>：箭头头部宽度，整数或浮点数。</p>
</li>
<li><p><strong>headlength</strong>: 箭头长度，整数或浮点数。</p>
</li>
<li><p><strong>facecolor</strong>: 填充色。</p>
</li>
<li><p><strong>shrink</strong>：移动提示，并使其离注释点和文本一些距离。 <kbd>就是别让箭头两端里标注点和文本太近。</kbd></p>
</li>
<li><strong>fontsize</strong>：设置字体大小</li>
</ul>
<p><font size="5"><strong>ax.text()</strong></font></p>
<hr>
<ul>
<li><strong>x,y</strong>： 放置text的位置，横纵坐标<br>   </li>
<li><strong>s</strong>： str，text内容。<br>  </li>
<li><strong>fontsize</strong>： 设置字体大小，默认12，可选参数 [‘xx-small’, ‘x-small’, ‘small’, ‘medium’, ‘large’,‘x-large’, ‘xx-large’]<br>  </li>
<li><strong>fontweight</strong>：设置字体粗细，可选参数 [‘light’, ‘normal’, ‘medium’, ‘semibold’, ‘bold’, ‘heavy’, ‘black’] <br> </li>
<li><strong>alpha</strong>： 透明度，参数值0至1之间。<br>  </li>
<li><strong>rotation</strong>： (旋转角度)可选参数为:vertical,horizontal 也可以为数字。<br>  </li>
<li><strong>backgroundcolor</strong>：背景颜色。<br>  </li>
<li><strong>color</strong>： 字体颜色</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">ax=plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">2</span>*x0+<span class="number">1</span></span><br><span class="line">plt.scatter(x0,y0,s=<span class="number">50</span>,color=<span class="string">&#x27;red&#x27;</span>) <span class="comment"># s表示点的大小,color表示点的颜色</span></span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot([x0,x0],[y0,<span class="number">0</span>],<span class="string">&#x27;k--&#x27;</span>,lw=<span class="number">2.5</span>)<span class="comment"># k表示虚线的颜色为黑色，lw表示线的宽度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 1</span></span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">r&#x27;$2x+1=%s$&#x27;</span>% y0,xy=(x0,y0),xycoords=<span class="string">&#x27;data&#x27;</span>,xytext=(+<span class="number">30</span>,-<span class="number">30</span>),textcoords=<span class="string">&#x27;offset points&#x27;</span>,</span><br><span class="line">             fontsize=<span class="number">16</span>,arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;-&gt;&#x27;</span>,connectionstyle=<span class="string">&#x27;arc3,rad=.2&#x27;</span>))</span><br><span class="line">                             <span class="comment">#xy表示箭头所在的点，xycoords表示标注点的坐标系</span></span><br><span class="line">                             <span class="comment">#xytext()标记的左下角点的位置</span></span><br><span class="line">                             <span class="comment">#(+30,-30)表示xytext的位置基于箭头指向点横坐标加30，纵坐标减30</span></span><br><span class="line">                             <span class="comment">#offset points坐标系(这里是相对坐标系)</span></span><br><span class="line">                             <span class="comment">#arrowstyle描述标注只想标注点的方式</span></span><br><span class="line">                             <span class="comment">#fontsize字体大小</span></span><br><span class="line">                             <span class="comment">#connectionstyle</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line">plt.text(-<span class="number">3.7</span>,<span class="number">3</span>,<span class="string">r&#x27;$This\ is\ the\ some\ text.\ \mu\ \sigma_i\ \alpha_t$&#x27;</span>,fontdict=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">12</span>,<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;r&#x27;</span>&#125;)</span><br><span class="line">                                                                        <span class="comment">#fontdict&#123;&#125;表示字体,传入字典size,color……</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_23_0.png" alt="png"></p>
<h1 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h1><h2 id="tick-params"><a href="#tick-params" class="headerlink" title="tick_params()"></a>tick_params()</h2><ul>
<li><strong>axis</strong>: 可选”x”,”y”,”both”,defalut:”both”，分别代表，对x轴操作，对y轴操作，对两个轴都操作。</li>
<li><strong>direction</strong>: 可选 “in”,”out”,”inout”代表，刻度线显示在坐标轴里面，坐标轴外边，双边</li>
<li><strong>length</strong>: 刻度线长度</li>
<li><strong>color</strong>: 刻度线颜色</li>
<li><strong>width</strong>: 刻度线宽度</li>
<li><strong>pad</strong>：:刻度线与刻度标签之间的间隔</li>
<li><strong>bottom, top, left, right</strong>四个参数对应四个边框，取值为布尔类型，True 表示显示对应边框上的刻度线，False不显示，default:True</li>
<li><strong>labelbottom, labeltop, labelleft, labelright</strong>  与上面四个对应，代表的是四个边框上的类标的设置，取值为布尔类型，True代表显示对应边框上的类标，False不显示。</li>
<li><strong>labelsize</strong>：类标大小的设置参数，可取浮点型数值，也可去”medium”,”large”,”small”</li>
<li><strong>labelrotation</strong>：旋转类标一定的角度，与在set_xticklabels()中的参数rotation作用相同。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = <span class="number">0.1</span>*x</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y,label=<span class="string">&#x27;up&#x27;</span>,color=<span class="string">&#x27;grey&#x27;</span>,lw=<span class="number">10</span>,alpha=<span class="number">0.6</span>) <span class="comment"># lw=linewidth</span></span><br><span class="line">plt.ylim(-<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xticklabels()+ax.get_yticklabels():</span><br><span class="line">    label.set_fontsize(<span class="number">12</span>)</span><br><span class="line">    label.set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;white&#x27;</span>,edgecolor=<span class="string">&#x27;None&#x27;</span>,alpha=<span class="number">0.7</span>))</span><br><span class="line">                                                        <span class="comment"># alpha表示透明度</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_27_0.png" alt="png"></p>
<h1 id="scatter散点图"><a href="#scatter散点图" class="headerlink" title="scatter散点图"></a>scatter散点图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">1024</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,n)</span><br><span class="line">Y = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,n)</span><br><span class="line">T = np.arctan2(Y,X) <span class="comment"># for color value</span></span><br><span class="line"><span class="comment"># plt.scatter(X,Y,s=75,c=T,alpha=0.5) #s=size,c=color,</span></span><br><span class="line">plt.scatter(np.arange(<span class="number">5</span>),np.arange(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># plt.xlim((-1.5,1.5))</span></span><br><span class="line"><span class="comment"># plt.ylim((-1.5,1.5))</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.collections.PathCollection at 0x1e5aa843580&gt;
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_29_1.png" alt="png"></p>
<h1 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n =  <span class="number">12</span></span><br><span class="line">X = np.arange(n)</span><br><span class="line">Y1 = (<span class="number">1</span>-X/<span class="built_in">float</span>(n))*np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)</span><br><span class="line">Y2 = (<span class="number">1</span>-X/<span class="built_in">float</span>(n))*np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)</span><br><span class="line">plt.bar(X,+Y1,facecolor=<span class="string">&#x27;#9999ff&#x27;</span>,edgecolor=<span class="string">&#x27;white&#x27;</span>,align=<span class="string">&#x27;edge&#x27;</span>,width=-<span class="number">1</span>)</span><br><span class="line">plt.bar(X,-Y2,facecolor=<span class="string">&#x27;#ff9999&#x27;</span>,edgecolor=<span class="string">&#x27;white&#x27;</span>,align=<span class="string">&#x27;edge&#x27;</span>,width=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y1):</span><br><span class="line">    plt.text(x,y+<span class="number">0.05</span>,<span class="string">&#x27;%.2f&#x27;</span> % y,ha=<span class="string">&#x27;right&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,fontsize=<span class="number">8</span>) <span class="comment"># ha对齐方式</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(X,-Y2):</span><br><span class="line">    plt.text(x,y-<span class="number">0.05</span>,<span class="string">&#x27;-%.2f&#x27;</span> % y,ha=<span class="string">&#x27;right&#x27;</span>,va=<span class="string">&#x27;top&#x27;</span>,fontsize=<span class="number">8</span>)</span><br><span class="line">plt.xlim(-<span class="number">5</span>,n)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.ylim(-<span class="number">1.25</span>,<span class="number">1.25</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_31_0.png" alt="png"></p>
<h1 id="生成等高线"><a href="#生成等高线" class="headerlink" title="生成等高线"></a>生成等高线</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">1</span>-x/<span class="number">2</span>+x**<span class="number">5</span>+y**<span class="number">3</span>)*np.exp(-x**<span class="number">2</span>-y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line">x = np.linspace(-<span class="number">3</span>,<span class="number">3</span>,n)</span><br><span class="line">y = np.linspace(-<span class="number">3</span>,<span class="number">3</span>,n)</span><br><span class="line">X,Y = np.meshgrid(x,y)</span><br><span class="line">plt.contourf(X,Y,f(X,Y),<span class="number">8</span>,alpha=<span class="number">0.75</span>,cmap=plt.cm.hot) <span class="comment"># cm=colormap</span></span><br><span class="line">C = plt.contour(X,Y,f(X,Y),<span class="number">8</span>,colors=<span class="string">&#x27;black&#x27;</span>,linewidths=<span class="number">.5</span>)</span><br><span class="line">                                        <span class="comment"># 8是指八条等高线</span></span><br><span class="line">                                        <span class="comment"># 注意：</span></span><br><span class="line">                                        <span class="comment"># colors,linewidths后面都有s</span></span><br><span class="line">plt.clabel(C,inline=<span class="literal">True</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>([], [])
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_33_1.png" alt="png"></p>
<h1 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"><span class="comment"># X,Y value</span></span><br><span class="line">X = np.arange(-<span class="number">4</span>,<span class="number">4</span>,<span class="number">0.25</span>)</span><br><span class="line">Y = np.arange(-<span class="number">4</span>,<span class="number">4</span>,<span class="number">0.25</span>)</span><br><span class="line">X,Y = np.meshgrid(X,Y)</span><br><span class="line">R = np.sqrt(X**<span class="number">2</span>+Y**<span class="number">2</span>)</span><br><span class="line"><span class="comment"># height value</span></span><br><span class="line">Z = np.sin(R)</span><br><span class="line">ax.plot_surface(X,Y,Z,rstride=<span class="number">1</span>,cstride=<span class="number">1</span>,cmap=plt.get_cmap(<span class="string">&#x27;rainbow&#x27;</span>),edgecolor=<span class="string">&#x27;black&#x27;</span>,linewidths=<span class="number">0.5</span>)</span><br><span class="line">ax.contourf(X,Y,Z,zdir=<span class="string">&#x27;x&#x27;</span>,offset=-<span class="number">4</span>,cmap=<span class="string">&#x27;rainbow&#x27;</span>) <span class="comment"># zdir=&#x27;z&#x27;对应从z轴压下去</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.contour.QuadContourSet at 0x1e5ab98dd30&gt;
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_35_1.png" alt="png"></p>
<h1 id="Subplot-多合一显示"><a href="#Subplot-多合一显示" class="headerlink" title="Subplot 多合一显示"></a>Subplot 多合一显示</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 表示将figure分成两行一列</span></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>])<span class="comment"># x,y分别从0-1</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># 表示分成两行三列</span></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x1e5aa547850&gt;]
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_37_1.png" alt="png"></p>
<h1 id="Subplot-分隔显示"><a href="#Subplot-分隔显示" class="headerlink" title="Subplot 分隔显示"></a>Subplot 分隔显示</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"></span><br><span class="line"><span class="comment"># method 1:subplot2grid</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">0</span>),colspan=<span class="number">3</span>,rowspan=<span class="number">1</span>) </span><br><span class="line">                            <span class="comment"># (3,3)表示整个grid有三行三列</span></span><br><span class="line">                            <span class="comment"># (0,0)表示从第1行第1列开始开始plot</span></span><br><span class="line">                            <span class="comment"># colspan列跨度 rowspan行跨度</span></span><br><span class="line">ax1.plot([<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">ax1.set_title(<span class="string">&#x27;ax1&#x27;</span>)</span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),colspan=<span class="number">2</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),colspan=<span class="number">1</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">ax4 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">0</span>),colspan=<span class="number">1</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">ax5 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">1</span>),colspan=<span class="number">1</span>,rowspan=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_39_0.png" alt="png"></p>
<h1 id="图中图"><a href="#图中图" class="headerlink" title="图中图"></a>图中图</h1><p><strong><font size="5">set_title()</font></strong></p>
<hr>
<ul>
<li><p><strong>loc</strong>:可取”best”,1或”upper right”,2”upper left”,3”lower<br>left”,4”lower right”,代表放不同位置</p>
</li>
<li><p><strong>fontsize</strong>:int或float或{‘xx-small’,’x-small’,’small’, ‘medium’,’large’,’x-large’, ‘xx-large’}，字体大小</p>
</li>
<li><p><strong>shadow</strong>: 是否为图例边框添加阴影T，传入布尔类型</p>
</li>
<li><p><strong>labelspacing</strong>: 图例中条目之间的距离</p>
</li>
<li><p><strong>handlelength</strong>: 图例句柄的长度</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">left,bottom,width,height = <span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span> <span class="comment"># 这些值都是百分比</span></span><br><span class="line">ax1 = fig.add_axes([left,bottom,width,height]) </span><br><span class="line">ax1.plot(x,y,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">left,bottom,width,height = <span class="number">0.2</span>,<span class="number">0.6</span>,<span class="number">0.25</span>,<span class="number">0.25</span></span><br><span class="line">ax2 = fig.add_axes([left,bottom,width,height]) </span><br><span class="line">ax2.plot(y,x,<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax2.set_title(<span class="string">&#x27;title inside 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.axes([<span class="number">.6</span>,<span class="number">.2</span>,<span class="number">.25</span>,<span class="number">.25</span>])</span><br><span class="line">plt.plot(y[::-<span class="number">1</span>],x,<span class="string">&#x27;green&#x27;</span>) <span class="comment"># ::-1表示从后往前，间隔为-1</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;标题2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5, 1.0, &#39;标题2&#39;)
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_42_1.png" alt="png"></p>
<h1 id="次坐标轴"><a href="#次坐标轴" class="headerlink" title="次坐标轴"></a>次坐标轴</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">y1 = <span class="number">0.05</span>*x**<span class="number">2</span></span><br><span class="line">y2 = -<span class="number">10</span>*y1</span><br><span class="line">fig,ax1 = plt.subplots() <span class="comment"># ?</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax1.plot(x,y1,<span class="string">&#x27;g:&#x27;</span>)</span><br><span class="line">ax2.plot(x,y2,<span class="string">&#x27;m--&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;X data&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;Y1&#x27;</span>,color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;Y2&#x27;</span>,color=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0, 0.5, &#39;Y2&#39;)
</code></pre><p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_44_1.png" alt="png"></p>
<h1 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line">fig,ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">0.01</span>)</span><br><span class="line">line, = ax.plot(x,np.sin(x))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span>(<span class="params">i</span>):</span></span><br><span class="line">    line.set_ydata(np.sin(x+i/<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    line.set_ydata(np.sin(x))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line">ani = animation.FuncAnimation(fig=fig,func=animate,frames=<span class="number">100</span>,init_func=init,interval=<span class="number">20</span>,blit=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/24/1.matplotlib%E5%85%A5%E9%97%A8/output_46_0.png" alt="png"></p>
<p>当然内容并不完整，只是初步的对matplotlib库中的工具进行介绍，后续会根据matplotlib所给的官方文件进行扩充……</p>
]]></content>
      <categories>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>1.行列式</title>
    <url>/2021/06/18/1.%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>$<br>\begin{cases}<br>{\large a}_1x + {\large b}_1y = {\large c}_1&amp;&amp;(1)\\<br>{\large a}_2x + {\large b}_2y = {\large c}_2&amp;&amp;(2)<br>\end{cases}<br>$</p>
<p>方程组有唯一解:<br>$<br>x=\displaystyle<br>{<br>\frac{\left|\begin{array}{}<br>    {\large c}_1&amp;{\large b}_1\\<br>    {\large c}_2&amp;{\large b}_2<br>\end{array}\right|}<br>{\left|\begin{array}{}<br>    {\large a}_1&amp;{\large b}_1\\<br>    {\large a}_2&amp;{\large b}_2<br>\end{array}\right|}<br>}<br>$</p>
<p>$<br>y=\displaystyle<br>{<br>\frac{\left|\begin{array}{}<br>    {\large a}_1&amp;{\large c}_1\\<br>    {\large a}_2&amp;{\large c}_2<br>\end{array}\right|}<br>{\left|\begin{array}{}<br>    {\large a}_1&amp;{\large b}_1\\<br>    {\large a}_2&amp;{\large b}_2<br>\end{array}\right|}<br>}<br>$</p>
<p><strong>例</strong><br></p>
<p>$<br>\begin{cases}<br>3x + 2y = 5\\<br>5x - 7y = 29<br>\end{cases}<br>$</p>
<p>解：由于系数行列式<br></p>
<p>$<br>D=\left|\begin{array}{ccc}<br>   3 &amp;2\\<br>    5 &amp;-7<br>\end{array}\right|=-31\neq0<br>$</p>
<p>方程组有唯一解,又<br>$<br>D_1=\left|\begin{array}{ccc}<br>        5&amp;2\\<br>        29&amp;-7<br>    \end{array}\right|=-93<br>$</p>
<p>$<br>D_2=\left|\begin{array}{ccc}<br>        3&amp;5\\<br>        5&amp;29<br>    \end{array}\right|=62\\<br>$</p>
<p>故方程组的解为：</p>
<p>$<br>\begin{cases}<br>    x=\displaystyle{\frac{D_1}{D}=3}\\<br>    \\<br>    y=\displaystyle{\frac{D_2}{D}=-2}<br>\end{cases}<br>$</p>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>$\tau(3\;2\;1)=2+1=3$</p>
<ul>
<li><strong>行列式的定义计算</strong>:每一行元素错开相乘<br>$\qquad\qquad\qquad\tau(3\;2\;1)：$表示行列式3$\;$2$\;$1列逆序数值<br><br>$\qquad\qquad\qquad\tau$为偶时，正数<br><br>$\qquad\qquad\qquad\tau$为奇时，负数  </li>
</ul>
<h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><p>行列式互换(<strong>转置</strong>)，行列式的值不变   </p>
<ul>
<li><strong>即</strong><br>$<br>\left|\begin{array}{ccc}<br>{\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1n}\\<br>{\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2n}\\<br>\vdots&amp;\vdots&amp;     &amp;\vdots\\<br>{\large a}_{n1}&amp;{\large a}_{n2}&amp;\cdots&amp;{\large a}_{nn}\\<br>\end{array}\right|=<br>\left|\begin{array}{ccc}<br>{\large a}_{11}&amp;{\large a}_{21}&amp;\cdots&amp;{\large a}_{n1}\\<br>{\large a}_{12}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{n2}\\<br>\vdots&amp;\vdots&amp;     &amp;\vdots\\<br>{\large a}_{1n}&amp;{\large a}_{2n}&amp;\cdots&amp;{\large a}_{nn}\\<br>\end{array}\right|<br>$<br><br><br>一般项：<br>$<br>{\large a}_{1j_1}\quad{\large a}_{2j_2}\;\cdots\;\;{\large a}_{nj_n}\qquad<br>{\large a}_{j_{_1}1}\quad{\large a}_{j_{_2}2}\;\cdots\;\;{\large a}_{j_{_n}n}<br>$<br><br><br>某行所有元素都是两个数的和，<br>则可把行列式写成两个行列式值和，<br>字母行列式的求解要想到拆行或列<br><br>$\quad<br>\left|\begin{array}{ccc}<br>  \vdots     &amp;     \vdots  &amp;     &amp; \vdots\\<br>  {\large a}_{i1}+{\large b}_{i1} &amp; {\large a}_{i2}+{\large b}_{i2} &amp; \cdots&amp; {\large a}_{in}+{\large b}_{in}\\<br>  \vdots     &amp;      \vdots &amp;     &amp; \vdots\\<br>\end{array}\right|<br>$<br><br><br>$=<br>\left|\begin{array}{ccc}<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>   {\large a}_{i1} &amp; {\large a}_{i2} &amp; \cdots&amp; {\large a}_{in}\\<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>\end{array}\right|+<br>\left|\begin{array}{ccc}<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>   {\large b}_{i1} &amp; {\large b}_{i2} &amp; \cdots&amp; {\large b}_{in}\\<br>  \vdots  &amp; \vdots &amp;     &amp; \vdots\\<br>\end{array}\right|<br>$<br><br><br><br><strong>证：</strong><br>$<br>\begin{aligned}<br>左<br>&amp;= \sum (-1)^{\tau(j_1\;j_2\cdots j_n)}\;{\large a}_{1j_1}\cdots({\large a}_{ij_i}+{\large b}_{ij_i})\cdots {\large a}_{nj_n}\\<br>\\<br>&amp;= \sum(-1)^{\tau(j_1\;j_2\cdots j_n)} \; {\large a}_{1j_1}\cdots{\large a}_{ij_i}\cdots {\large a}_{nj_n}\\<br>\\<br>&amp;\quad+ \sum(-1)^{\tau(j_1\;j_2\cdots j_n)} \; {\large a}_{1j_1}\cdots{\large b}_{ij_i}\cdots {\large a}_{nj_n}<br>\end{aligned}<br>$</li>
</ul>
<p><strong>其他的性质:</strong></p>
<ul>
<li><p>如果行列式的值为0，则矩阵是<u><strong>奇异矩阵</strong></u>，也就是矩阵没有逆矩阵。</p>
</li>
<li><p>$|A|\not=0\Leftrightarrow r(A)=n\Leftrightarrow$矩阵可逆$\Leftrightarrow A\;$的行(列)向量线性组无关$\Leftrightarrow A\;$的特征值$\lambda\not=0$</p>
</li>
<li><p>（方阵）$|AB|=|A||B|$</p>
</li>
<li><p>$|A^{-1}|=\displaystyle\frac{1}{|A|}$</p>
</li>
<li><p>$|2A|=2^n|A|$</p>
</li>
</ul>
<h2 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h2><p><strong>注意：代数余子式${\large a}_{ij}$需要带正负号，而代数余子式不需要，这里注意区分</strong></p>
<ul>
<li>$D={\large a}_{11}{\large a}_{11}+{\large a}_{12}{\large a}_{12}+\cdots+{\large a}_{1n}{\large a}_{1n}=\sum\limits_{j=1}^n{\large a}_{1j}{\large a}_{1j}$<br><br>$D={\large a}_{11}{\large a}_{11}+{\large a}_{21}{\large a}_{21}+\cdots+{\large a}_{n1}{\large a}_{n1}=\sum\limits_{i=1}^n{\large a}_{i1}{\large a}_{i1}$<br><br>$D=\sum\limits_{j=1}^n {\large a}_{ij}{\large a}_{ij}\quad(i=1,2,\cdots,n)\quad i行$<br><br>$D=\sum\limits_{j=1}^n {\large a}_{ij}{\large a}_{ij}\quad(j=1,2,\cdots,n)\quad j列$</li>
</ul>
<h2 id="特殊的行列式"><a href="#特殊的行列式" class="headerlink" title="特殊的行列式"></a>特殊的行列式</h2><h3 id="三角行列式"><a href="#三角行列式" class="headerlink" title="三角行列式"></a>三角行列式</h3><p>上三角：</p>
<p>$<br>\left|\begin{array}{ccc}<br>    {\large a}_{11} &amp; {\large a}_{12} &amp;\cdots&amp; {\large a}_{1n}\\<br>    0   &amp; {\large a}_{22} &amp;\cdots&amp; {\large a}_{2n}\\<br>    \vdots&amp;\vdots&amp;   &amp;\vdots\\<br>    0   &amp; 0   &amp;\cdots&amp; {\large a}_{nn}\\<br>\end{array}\right|<br>$</p>
<p>下三角：</p>
<p>$<br>\left|\begin{array}{ccc}<br>    {\large a}_{11} &amp; 0    &amp;\cdots&amp; 0\\<br>    {\large a}_{21} &amp; {\large a}_{22}&amp;\cdots&amp; 0\\<br>    \vdots&amp;\vdots &amp;    &amp;\vdots\\<br>    {\large a}_{n1} &amp; {\large a}_{n2}&amp;\cdots&amp;{\large a}_{nn}\\<br>\end{array}\right|<br>$<br><br><br>$Det={\large a}_{11}{\large a}_{22}{\large a}_{33}\cdots {\large a}_{nn}$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个可以通过逆序数理解</span></span><br></pre></td></tr></table></figure>
<h3 id="范德蒙行列式"><a href="#范德蒙行列式" class="headerlink" title="范德蒙行列式"></a>范德蒙行列式</h3><p>$<br>\qquad\left|\begin{array}{ccc}<br>    1  &amp;  1  &amp;  1  &amp; \cdots &amp; 1\\<br>    {\large a}_1 &amp; {\large a}_2 &amp; {\large a}_3 &amp; \cdots &amp; {\large a}_n\\<br>    {\large a}_1^2&amp;{\large a}_2^2&amp;{\large a}_3^2&amp; \cdots&amp; {\large a}_n^2\\<br>    \vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>    {\large a}_1^{n-1}&amp;{\large a}_2^{n-1}&amp;{\large a}_3^{n-1}&amp;\cdots&amp;{\large a}_n^{n-1}<br>\end{array}\right|$</p>
<p>$\;{\large=}\prod\limits_{1\leqslant j&lt;i\leqslant n}({\large a}_i-{\large a}_j)<br>$</p>
<p><strong>应用</strong>  </p>
<p>$D=<br>\left|\begin{array}{ccc}1&amp;1&amp;1\\{\large a}&amp;{\large b}&amp;{\large c}\\{\large a}^3&amp;{\large b}^3&amp;{\large c}^3\end{array}\right|的值$</p>
<ul>
<li>首先构造(注意积累)<br><br>$<br>\begin{aligned}<br>D_4&amp;=\left|\begin{array}{ccc}<br>1&amp;1&amp;1&amp;1\\<br>{\large a}&amp;{\large b}&amp;{\large c}&amp;{\large x}\\<br>{\large a}^2&amp;{\large b}^2&amp;{\large c}^2&amp;{\large x}^2\\<br>{\large a}^3&amp;{\large b}^3&amp;{\large c}^3&amp;{\large x}^3\\<br>\end{array}\right|\\<br>&amp;=1\cdot {\large a}_{14}+{\large x}\cdot {\large a}_{24}+{\large x}^2\cdot(-D)+{\large x}^3 \cdot {\large a}_{44}\\<br>&amp;=({\large x}-{\large c})({\large x}-{\large b})({\large x}-{\large a})({\large c}-{\large b})({\large c}-{\large a})({\large b}-{\large a})<br>\end{aligned}$<br>$\longrightarrow D\;$的值就是${\large x}_2$系数的负数</li>
</ul>
<h3 id="拉普拉斯展开式"><a href="#拉普拉斯展开式" class="headerlink" title="拉普拉斯展开式"></a>拉普拉斯展开式</h3><ul>
<li>有一块全是零的行列式</li>
</ul>
<hr>
<ul>
<li>主对角线<br><br>$\quad<br>\left|\begin{array}{cccc:cccc}<br>  {\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1m}&amp;0&amp;0&amp;\cdots&amp;0\\<br>  {\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2m}&amp;0&amp;0&amp;\cdots&amp;0\\<br>   \vdots&amp; \vdots  &amp; &amp; \vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>  {\large a}_{m1}&amp;{\large c}_{m2}&amp;\cdots&amp;{\large a}_{mm}&amp;0&amp;0&amp;\cdots&amp;0\\<br>  \hdashline<br>  {\large c}_{11}&amp;{\large c}_{12}&amp;\cdots&amp;{\large c}_{1m}&amp;{\large b}_{11}&amp;{\large b}_{12}&amp;\cdots&amp;{\large b}_{1n}\\<br>  {\large c}_{21}&amp;{\large c}_{22}&amp;\cdots&amp;{\large c}_{2m}&amp;{\large b}_{21}&amp;{\large b}_{22}&amp;\cdots&amp;{\large b}_{2n}\\<br>  \vdots&amp;\vdots&amp;    &amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>  {\large c}_{m1}&amp;{\large c}_{m2}&amp;\cdots&amp;{\large c}_{mm}&amp;{\large b}_{n1}&amp;{\large b}_{n2}&amp;\cdots&amp;{\large b}_{nn}\\<br>\end{array}\right|<br>$<br><br><br>${\large=}<br>\left|\begin{array}{ccc}<br>  {\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1m}\\<br>  {\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2m}\\<br>  \vdots&amp;\vdots&amp;    &amp;\vdots\\<br>  {\large a}_{m1}&amp;{\large c}_{m2}&amp;\cdots&amp;{\large a}_{mm}\\<br>\end{array}\right|<br>$ $\cdot<br>\left|\begin{array}{ccc}<br>  {\large b}_{11}&amp;{\large b}_{12}&amp;\cdots&amp;{\large b}_{1n}\\<br>  {\large b}_{21}&amp;{\large b}_{22}&amp;\cdots&amp;{\large b}_{2n}\\<br>  \vdots&amp;\vdots&amp;&amp;\vdots\\<br>  {\large b}_{n1}&amp;{\large b}_{n2}&amp;\cdots&amp;{\large b}_{nn}\\<br>\end{array}\right|<br>$<br><br></li>
<li>副对角线<br><br>例<br><br>$\quad<br>\left|\begin{array}{cc:ccc}<br>  0&amp;0&amp;{\large a}_{11}&amp;{\large a}_{12}&amp;{\large a}_{13}\\<br>  0&amp;0&amp;{\large a}_{21}&amp;{\large a}_{22}&amp;{\large a}_{23}\\<br>  0&amp;0&amp;{\large a}_{31}&amp;{\large a}_{31}&amp;{\large a}_{33}\\<br>  \hdashline<br>  {\large b}_{11}&amp;{\large b}_{12}&amp;{\large c}_{11}&amp;{\large c}_{12}&amp;{\large c}_{13}\\<br>  {\large b}_{21}&amp;{\large b}_{22}&amp;{\large c}_{21}&amp;{\large c}_{22}&amp;{\large c}_{23}<br>\end{array}\right|<br>$<br><br>$=(-1)^{3\times2}<br>\left|\begin{array}{ccc}<br>  {\large a}_{11}&amp;{\large a}_{12}&amp;{\large a}_{13}\\<br>  {\large a}_{21}&amp;{\large a}_{22}&amp;{\large a}_{23}\\<br>  {\large a}_{31}&amp;{\large a}_{31}&amp;{\large a}_{33}<br>\end{array}\right|<br>\cdot<br>\left|\begin{array}{cc}<br>  {\large b}_{11}&amp;{\large b}_{12}\\<br>  {\large b}_{21}&amp;{\large b}_{22}<br>\end{array}\right|<br>$<br><br>$\qquad\uparrow$<br><br>$3\times2\;表示:\;A\;的阶数\times B\;的阶数$<br><br>$\qquad \qquad\quad\; ps:$当然也可以交换列，转化成主对角线的拉普拉斯展开<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分块求解行列式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>目前对于行列式的笔记就到这儿，后面会继续深入研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>2.CSS字体与文本属性</title>
    <url>/2021/07/20/2-CSS%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS-字体属性"><a href="#CSS-字体属性" class="headerlink" title="CSS 字体属性"></a>CSS 字体属性</h1><h2 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h2><p>CSS 使用 <strong>font-famliy</strong> 属性定义 <strong>字体</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-family</span>: <span class="string">&quot;微软雅黑&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font</span>-famliy: Arial,<span class="string">&quot;Microsoft YaHei&quot;</span>,<span class="string">&quot;微软雅黑&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p>CSS使用 <strong>font-size</strong> 属性定义字体 <strong>大小</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>px（像素）大小是页面最常用的单位</li>
<li>由于不同浏览器默认显示的字号可能不一致，所以尽量给一个明确值大小，不要默认大小</li>
</ul>
<h2 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h2><p>用 <strong>font-weight</strong> 定义字体 <strong>粗细</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">normal</td>
<td style="text-align:left">默认值（不加粗）</td>
</tr>
<tr>
<td style="text-align:left">bold</td>
<td style="text-align:left">定义粗体</td>
</tr>
<tr>
<td style="text-align:left">100-900</td>
<td style="text-align:left">400=normal,700=bold  <strong>（后面不跟单位）</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><p><strong>font-style</strong> 属性定义文字风格<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">normal</td>
<td style="text-align:left">默认值</td>
</tr>
<tr>
<td style="text-align:left">italic</td>
<td style="text-align:left">斜体</td>
</tr>
</tbody>
</table>
</div>
<h2 id="字体符复合属性"><a href="#字体符复合属性" class="headerlink" title="字体符复合属性"></a>字体符复合属性</h2><p>也就是字体属性的简洁书写形式</p>
<p>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: font-style font-weight font-size/line-height font-famliy;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">16px</span>/<span class="number">20px</span> <span class="string">&#x27;Microsoft yahei&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font</span>: <span class="number">16px</span> <span class="string">&#x27;Microsoft yahei&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>注意</strong></p>
<ul>
<li><strong>不能更换顺序书写</strong></li>
<li><strong>必须保留font-size和font-family属性</strong>，否则font属性不起作用,其他的可以省略</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">字号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">font-size</td>
<td style="text-align:left">字号</td>
</tr>
<tr>
<td style="text-align:left">font-family</td>
<td style="text-align:left">字体</td>
</tr>
<tr>
<td style="text-align:left">font-weight</td>
<td style="text-align:left">字体粗细</td>
</tr>
<tr>
<td style="text-align:left">font-style</td>
<td style="text-align:left">字体样式</td>
</tr>
<tr>
<td style="text-align:left">font</td>
<td style="text-align:left">字体连写</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS-文本属性"><a href="#CSS-文本属性" class="headerlink" title="CSS 文本属性"></a>CSS 文本属性</h1><h2 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h2><p>color属性定义文本的颜色<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表示</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">预定义的颜色值</td>
<td style="text-align:left">red,green,blue,pink</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">#ff000,#ff6600···</td>
</tr>
<tr>
<td style="text-align:left">RGB代码</td>
<td style="text-align:left">rgb(255,0,0)或rgb(100%,0%,0%)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h2><p><strong>text-align</strong> 属性用于设置元素内文本内容的水平对齐方式<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">左对齐（默认）</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">右对齐</td>
</tr>
<tr>
<td style="text-align:left">center</td>
<td style="text-align:left">居中对齐</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h2><p><strong>text-decoration</strong> 属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left">默认，可以用来取消链接的下划线</td>
</tr>
<tr>
<td style="text-align:left">underline</td>
<td style="text-align:left">下划线</td>
</tr>
<tr>
<td style="text-align:left">overline</td>
<td style="text-align:left">上划线</td>
</tr>
<tr>
<td style="text-align:left">line-through</td>
<td style="text-align:left">删除线</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h2><p><strong>text-indent</strong> 属性用来指定文本的第一行的缩进，通常是将段落 <strong>首行缩进</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>em</strong> 单位表示相对单位，就是当前1个文字的大小</p>
<h2 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h2><p><strong>line-height</strong> 属性用于设置行间的距离（行高），可以控制文字行与行之间的距离<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><div style="width: 100px;height: 20px;text-align: center;line-height: 20px;border:1px solid;border-bottom:0;">
上方距离
</div></p>
<p><div style="width: 100px;height: 40px;text-align: center;line-height: 40px;border:1px solid;border-bottom:0;">文字大小</div></p>
<p><div style="width: 100px;height: 20px;text-align: center;line-height: 20px;border:1px solid">下方距离</div><br></p>
<p><strong>line-height</strong> 是文字上下方距离和文字大小之和</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">文本颜色</td>
</tr>
<tr>
<td style="text-align:left">text-align</td>
<td style="text-align:left">文本对齐</td>
</tr>
<tr>
<td style="text-align:left">text-indent</td>
<td style="text-align:left">文本缩进</td>
</tr>
<tr>
<td style="text-align:left">text-decoration</td>
<td style="text-align:left">文本修饰</td>
</tr>
<tr>
<td style="text-align:left">line-height</td>
<td style="text-align:left">行高</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>10.CSS3新增特性</title>
    <url>/2021/07/21/10-CSS3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="新增选择器"><a href="#新增选择器" class="headerlink" title="新增选择器"></a>新增选择器</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器可以根据元素特定属性来选择元素，这样就可以不用借助于类或者id选择器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[att]</td>
<td>选择具有att属性的 E 元素</td>
</tr>
<tr>
<td>E[att=”val”]</td>
<td>选择具有att 属性且属性值等于val 的E 元素</td>
</tr>
<tr>
<td>E[att^=”val”]</td>
<td>匹配具有att 属性且值以val 开头的E 元素</td>
</tr>
<tr>
<td>E[att$=”val”]</td>
<td>匹配具有att 属性且值以val 结尾的E 元素 </td>
</tr>
<tr>
<td>E[att*=”val”]</td>
<td>匹配具有att属性且值中含有val 的E 元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><p>结构伪类选择器主要根据文档结构来选择，常用于父级选择器里面的子元素</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择符</th>
<th style="text-align:left">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E:first-child</td>
<td style="text-align:left">匹配父元素中的第一个子元素E</td>
</tr>
<tr>
<td style="text-align:left">E:last-child</td>
<td style="text-align:left">匹配父元素中最后一个E 元素</td>
</tr>
<tr>
<td style="text-align:left">E:nth-child(n)</td>
<td style="text-align:left">匹配父元素中的第n个子元素E</td>
</tr>
<tr>
<td style="text-align:left">E:first-of-type</td>
<td style="text-align:left">指定类型E 的第一个</td>
</tr>
<tr>
<td style="text-align:left">E:last-of-type</td>
<td style="text-align:left">指定类型E 的最后一个</td>
</tr>
<tr>
<td style="text-align:left">E:nth-of-type(n)</td>
<td style="text-align:left">指定类型E的第n个</td>
</tr>
</tbody>
</table>
</div>
<p><strong>nth-child(n)</strong> 选择某个父元素的一个或多个特定的子元素</p>
<ul>
<li><strong>n可以是数字，关键字和公式</strong></li>
<li>n如果是数字，就是选择第n个子元素，里面数字从1开始</li>
<li>n可以是关键字:even偶数，odd奇数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">公式</th>
<th style="text-align:left">取值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2n</td>
<td style="text-align:left">偶数</td>
</tr>
<tr>
<td style="text-align:left">2n+1</td>
<td style="text-align:left">奇数</td>
</tr>
<tr>
<td style="text-align:left">5n</td>
<td style="text-align:left">5 10 15…</td>
</tr>
<tr>
<td style="text-align:left">n+5</td>
<td style="text-align:left">从第5个开始（包含第五个）到最后</td>
</tr>
<tr>
<td style="text-align:left">-n+5</td>
<td style="text-align:left">前五个（包含第5个）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>nth-child(n)</strong> 和 <strong>nth-of-type(n)</strong> 的区别<br>nth-child 会把所有的子元素排列序号</p>
<p>nth-child 只会把指定的子元素排序号</p>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>伪元素选择器可以帮助我们利用CSS 创建新标签元素，而不需要HTML标签，从而简化HTML结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择符</th>
<th style="text-align:left">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">::before</td>
<td style="text-align:left">在元素内部的前面插入内容</td>
</tr>
<tr>
<td style="text-align:left">::after</td>
<td style="text-align:left">在元素内部的后面插入内容</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong></p>
<ul>
<li><strong>before</strong> 和 <strong>after</strong> 创建一个元素，但是<strong>属于行内元素</strong></li>
<li>新创建的这个元素在文档树中是找不到的，所以我们称之为伪元素</li>
<li><strong>语法：element::before{}</strong></li>
<li>before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素</li>
<li>伪元素选择器和标签选择器一样，权重为1</li>
</ul>
<h2 id="CSS3-盒子模型"><a href="#CSS3-盒子模型" class="headerlink" title="CSS3 盒子模型"></a>CSS3 盒子模型</h2><p>CSS3中可以通过 <strong>box-sizing</strong> 来指定盒子模型，有两个值：即可指定为 <strong>content-box</strong>、<strong>border-box</strong>，这样我们计算盒子大小的方式就发生了改变</p>
<p>1.box-sizing: content-box 盒子大小为width + padding + border （默认）</p>
<p>2.box-sizing: border-box 就不会撑大盒子（前提padding和border不会超过width宽度）</p>
<h1 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h1><p>过渡（transition）让我们可以在不适用flash动画或javascript的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<p>过渡动画：是从一个状态渐渐的过渡到另外一个状态</p>
<p><strong>经常和:hover一起搭配使用</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">tansition: 要过渡的属性 花费时间 曲线运动 何时开始;</span><br></pre></td></tr></table></figure>
<p><strong>1.属性</strong>：想要变化的CSS属性，宽度高度 背景颜色 内外边距都可以。如果想要所有的属性都变化过渡，写一个 <strong>all</strong> 就可以</p>
<p><strong>2.花费时间</strong>：单位 s（必须）</p>
<p><strong>3.曲线运动</strong>：默认是ease（可省略）</p>
<p><strong>4.何时开始</strong>：单位 s（必须）可以设置延迟出发时间 默认是0s（可省略）</p>
<h1 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h1><blockquote>
<p><strong>转换（transform）</strong> 可以实现元素的位移、旋转、缩放等效果，转换可以简单理解为变形</p>
<h2 id="二维坐标系"><a href="#二维坐标系" class="headerlink" title="二维坐标系"></a>二维坐标系</h2><p>2D转换是改变标签在二维平面上的位置和形状的一种技术</p>
<h2 id="2D-转换之移动-translate"><a href="#2D-转换之移动-translate" class="headerlink" title="2D 转换之移动 translate"></a>2D 转换之移动 translate</h2><p>2D移动是2D转换里面的一种功能，可以改变元素在页面中的位置，类似 <strong>定位</strong></p>
</blockquote>
<p>1.语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(x,y)或者分开写</span><br><span class="line">transform: <span class="built_in">translateX</span>(n)</span><br><span class="line">transform: <span class="built_in">translateY</span>(n)</span><br></pre></td></tr></table></figure></p>
<p><strong>2.重点</strong></p>
<ul>
<li>定义2D转换中的移动，沿着X和Y轴移动元素</li>
<li>translate最大的优点：不会影响到其他元素的位置</li>
<li>translate中的百分比单位是相对于自身元素的translate:(50%,50%);</li>
<li>对行内元素没有效果</li>
</ul>
<h2 id="2D-转换之旋转-rotate"><a href="#2D-转换之旋转-rotate" class="headerlink" title="2D 转换之旋转 rotate"></a>2D 转换之旋转 rotate</h2><blockquote>
<p>2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转</p>
</blockquote>
<p>1.语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate</span>(度数)</span><br></pre></td></tr></table></figure></p>
<p><strong>2.重点</strong></p>
<ul>
<li>rotate里面跟度数，单位是deg 比如 rotate(45deg)</li>
<li>角度为正时，顺时针，负时，为逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ul>
<h2 id="2D-转换中心点-transform-origin"><a href="#2D-转换中心点-transform-origin" class="headerlink" title="2D 转换中心点 transform-origin"></a>2D 转换中心点 transform-origin</h2><p>1.语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: x y;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.重点</strong></p>
<ul>
<li>注意后面参数x和y用空格隔开</li>
<li>x y默认转换的中心点是元素元素的中心点(50% 50%)</li>
<li>还可以给x y 设置 像素 或者 方位名词 (top bottom left right cneter)</li>
</ul>
<h2 id="2D转换之缩放-scale"><a href="#2D转换之缩放-scale" class="headerlink" title="2D转换之缩放 scale"></a>2D转换之缩放 scale</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">scale</span>(x,y);</span><br></pre></td></tr></table></figure>
<p><strong>2.注意</strong></p>
<ul>
<li>注意其中的x和y用逗号分隔</li>
<li><strong>transform:scale(1,1)</strong>：宽和高都放大一倍，相当于没放大</li>
<li><strong>transform:scale(2,2)</strong>：宽和高都放大2倍</li>
<li><strong>transform:scale(2)</strong>：只写一个参数，第二个参数则和第一个参数一样，相当于scale(2,2)</li>
<li>transform缩放最大的优势：可以设置转换 <strong>中心点</strong> 缩放，默认为中心点缩放的，而且 <strong>不影响其他盒子</strong></li>
</ul>
<h2 id="2D转换的综合写法"><a href="#2D转换的综合写法" class="headerlink" title="2D转换的综合写法"></a>2D转换的综合写法</h2><p><strong>注意:</strong><br>1.同时使用多个转换，其格式为：<strong>transform:translate() rotate() scale()…</strong>，</p>
<p>2.其顺序会影响转换的效果。(先旋转会改变坐标轴方向)</p>
<p><strong>3.当我们同时有位移和其他属性的时候，记得要将位移放到最前</strong></p>
<h1 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h1><blockquote>
<p><strong>动画</strong> 可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
</blockquote>
<p>相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果</p>
<h2 id="动画的基本使用"><a href="#动画的基本使用" class="headerlink" title="动画的基本使用"></a>动画的基本使用</h2><p>制作动画分为两步：</p>
<p>1.先定义动画</p>
<p>2.再使用（调用）动画</p>
<p><strong>1.用keyframes定义动画（类似定义类选择器）</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>动画序列</strong></p>
<ul>
<li>0%是动画的 <strong>开始</strong>,100%是动画的 <strong>完成</strong></li>
<li>在 <strong>@keyframes</strong> 中规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果</li>
<li>动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的 <strong>次数</strong></li>
<li>使用百分比来规定变化发生的时间，或用关键词”<strong>from</strong>“和”<strong>to</strong>“，等同于 <strong>0%</strong> 和 <strong>100%</strong></li>
</ul>
<p><strong>2.元素使用动画</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="comment">/* 调用动画 */</span></span><br><span class="line">    <span class="attribute">animation-name</span>: 动画名称;</span><br><span class="line">    <span class="comment">/* 持续时间 */</span></span><br><span class="line">    <span class="attribute">animation-duration</span>: 持续时间;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="动画常用属性"><a href="#动画常用属性" class="headerlink" title="动画常用属性"></a>动画常用属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@keyframes</td>
<td style="text-align:left">规定动画</td>
</tr>
<tr>
<td style="text-align:left">animation</td>
<td style="text-align:left">所有动画属性的简写属性，除了animathion-play-state属性</td>
</tr>
<tr>
<td style="text-align:left">animation-name</td>
<td style="text-align:left">规定@keyframes动画的名称<strong>（必须）</strong></td>
</tr>
<tr>
<td style="text-align:left">animation-duration</td>
<td style="text-align:left">规定动画完成一个周期所花费的秒或毫秒，默认是0。<strong>（必须）</strong></td>
</tr>
<tr>
<td style="text-align:left">animation-timing-funciton</td>
<td style="text-align:left">规定动画的速度曲线，默认”ease”</td>
</tr>
<tr>
<td style="text-align:left">animation-delay</td>
<td style="text-align:left">规定动画何时开始，默认是0</td>
</tr>
<tr>
<td style="text-align:left">animation-iteration-count</td>
<td style="text-align:left">规定动画被播放的次数，默认是1，还有infinite</td>
</tr>
<tr>
<td style="text-align:left">animation-direction</td>
<td style="text-align:left">规定动画是否在下一个周期逆向播放，默认是”normal”,alternate逆播放</td>
</tr>
<tr>
<td style="text-align:left">animation-play-state</td>
<td style="text-align:left">规定动画是否正在运行或暂停，默认是”running”,还有”pause”</td>
</tr>
<tr>
<td style="text-align:left">animation-fill-mode</td>
<td style="text-align:left">规定动画结束后状态，保持forwards回到起始backwards</td>
</tr>
</tbody>
</table>
</div>
<h2 id="动画简写属性"><a href="#动画简写属性" class="headerlink" title="动画简写属性"></a>动画简写属性</h2><p><strong>格式：</strong></p>
<p><strong>animation: 动画名称 持续时间 曲线运动 何时开始 播放次数 是否反方向 动画起始或者结束的状态</strong></p>
<p><strong>例：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br></pre></td></tr></table></figure>
<ul>
<li>简写属性里面不包含 <strong>animation-play-state</strong></li>
<li>暂停动画:<strong>animation-play-state:paused;</strong> 经常和鼠标经过等其他搭配使用</li>
<li>想要动画走回来，而不是直接跳回来：<strong>animation-diraction:alternate</strong></li>
<li>盒子动画结束后，停在结束位置： <strong>animation-fill-mode: forwards</strong></li>
</ul>
<h2 id="速度曲线细节"><a href="#速度曲线细节" class="headerlink" title="速度曲线细节"></a>速度曲线细节</h2><p><strong>animation-timing-function:规定动画的速度曲线</strong>，默认是”ease”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">linear</td>
<td style="text-align:left">动画从头到尾的速度是相同的。匀速</td>
</tr>
<tr>
<td style="text-align:left">ease</td>
<td style="text-align:left">默认。动画以低速开始，然后加快，在结束前变慢</td>
</tr>
<tr>
<td style="text-align:left">ease-in</td>
<td style="text-align:left">动画以低速开始</td>
</tr>
<tr>
<td style="text-align:left">ease-out</td>
<td style="text-align:left">动画以低速结束</td>
</tr>
<tr>
<td style="text-align:left">ease-in-out</td>
<td style="text-align:left">动画以低速开始和结束</td>
</tr>
<tr>
<td style="text-align:left">steps()</td>
<td style="text-align:left">指定了时间函数中的间隔数量（步长）</td>
</tr>
</tbody>
</table>
</div>
<h1 id="CSS3-3D转换"><a href="#CSS3-3D转换" class="headerlink" title="CSS3 3D转换"></a>CSS3 3D转换</h1><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><ul>
<li>x轴：向右为正</li>
<li>y轴：向下为正</li>
<li>z轴：向外为正</li>
</ul>
<h2 id="3D位移-translate3d"><a href="#3D位移-translate3d" class="headerlink" title="3D位移 translate3d"></a>3D位移 translate3d</h2><ul>
<li>transform:translate3dX(100px):仅在X轴上移动</li>
<li>transform:translate3dY(100px):仅在y轴上移动</li>
<li>transform:translate3dZ(100px):仅在z轴上移动<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(x,y,z)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>xyz是不能有省略的，如果没有就写0</strong></p>
<h2 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视 perspective"></a>透视 perspective</h2><ul>
<li>如果想要在网页中产生3D效果需要透视</li>
<li>模拟人的视觉位置，可认为安排一只眼去看</li>
<li>透视我们也称为视距：视距就是人的眼睛到屏幕的距离</li>
<li>距离视觉点越近的在电脑平面成像越大，越远成像越小</li>
<li>透视的单位是像素</li>
</ul>
<p><strong>透视写在被观察元素的父盒子上面的</strong></p>
<p><strong>d</strong>:就是视距，视距就是一个距离人的眼睛到屏幕的距离</p>
<p><strong>z</strong>:就是z轴，物体距离屏幕的距离，z轴越大（正值）我们看到的物体越大。</p>
<h2 id="3D旋转-rotate3d"><a href="#3D旋转-rotate3d" class="headerlink" title="3D旋转 rotate3d"></a>3D旋转 rotate3d</h2><ul>
<li>transform:rotateX(45deg):沿 <strong>x轴正方向</strong> 旋转45°</li>
<li>transform:rotateY(45deg):沿 <strong>y轴正方向</strong> 旋转45°</li>
<li>transform:rotateZ(45deg):沿 <strong>z轴正方向</strong> 旋转45°</li>
<li>transform:rotate3d(x,y,z,deg):（了解）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate3d</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">45deg</span>)</span><br><span class="line">这个是按照矢量叠加，也就是沿(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)旋转</span><br></pre></td></tr></table></figure>
<p><strong>左手准则</strong></p>
<ul>
<li>左手的手拇指指向x轴的正方向</li>
<li>其余手指的弯曲方向就是该元素沿x轴旋转的方向</li>
</ul>
<h2 id="3D呈现-transform-style"><a href="#3D呈现-transform-style" class="headerlink" title="3D呈现 transform-style"></a>3D呈现 transform-style</h2><ul>
<li>子元素是否开启三维立体环境</li>
<li><strong>transform-style:flat</strong> 子元素不开启3d立体空间， 默认</li>
<li><strong>transform-style:preserve-3d;</strong> 子元素开启立体空间</li>
<li>代码写给<strong>父级</strong>，但是<strong>影响的是子盒子</strong></li>
</ul>
<h1 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h1><p>浏览器私有前缀是为了兼容老版本的写法，比较新版本的浏览器无需添加</p>
<p><strong>1.私有前缀</strong></p>
<ul>
<li>-moz-:代表firefox浏览器私有属性</li>
<li>-ms-:代表ie浏览器私有属性</li>
<li>-webkit-:代表safari、chrome私有属性</li>
<li>-o-:代表Opera私有属性</li>
</ul>
<p><strong>2.提倡写法</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">-webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">-o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><h2 id="传统布局与flex布局"><a href="#传统布局与flex布局" class="headerlink" title="传统布局与flex布局"></a>传统布局与flex布局</h2><p><strong>传统布局</strong></p>
<ul>
<li>兼容性好</li>
<li>布局繁琐</li>
<li>局限性，不能在移动端很好的布局</li>
</ul>
<p><strong>flex 弹性布局</strong></p>
<ul>
<li>操作方便</li>
<li>PC端浏览器支持情况较差</li>
</ul>
<h2 id="flex-布局父项常见属性"><a href="#flex-布局父项常见属性" class="headerlink" title="flex 布局父项常见属性"></a>flex 布局父项常见属性</h2><h3 id="常见父项属性"><a href="#常见父项属性" class="headerlink" title="常见父项属性"></a>常见父项属性</h3><p>以下有6个属性是对父元素设置的</p>
<ul>
<li>flex-direction：设置主轴的方向</li>
<li>justify-content：设置主轴上的子元素排列方式</li>
<li>flex-wrap：设置子元素是否换行</li>
<li>align-content：设置侧轴上的子元素排列方式（多行）</li>
<li>align-items：设置侧轴上的子元素排列方式（单行）</li>
<li>flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap</li>
</ul>
<h3 id="flex-direction-设置主轴的方向"><a href="#flex-direction-设置主轴的方向" class="headerlink" title="flex-direction 设置主轴的方向"></a>flex-direction 设置主轴的方向</h3><p><strong>1、主轴与侧轴</strong></p>
<p>在flex布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x轴和y轴</p>
<ul>
<li>默认主轴方向就是 x 轴方向，水平向右</li>
<li>默认侧轴方向就是 y 轴方向，水平向下</li>
</ul>
<p><strong>2、属性值</strong></p>
<p>flex-direction 属性决定主轴的方向（即项目的排列方向）</p>
<p>注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>row</strong></td>
<td><strong>从左到右</strong></td>
</tr>
<tr>
<td>row-reverse</td>
<td>从右到左</td>
</tr>
<tr>
<td><strong>column</strong></td>
<td><strong>从上到下</strong></td>
</tr>
<tr>
<td>column-reverse</td>
<td>从下到上</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2.html5新增特性</title>
    <url>/2021/07/21/2-html5%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTML5的新增特性"><a href="#HTML5的新增特性" class="headerlink" title="HTML5的新增特性"></a>HTML5的新增特性</h1><h2 id="HTML5-新增的带有语义化的标签"><a href="#HTML5-新增的带有语义化的标签" class="headerlink" title="HTML5 新增的带有语义化的标签"></a>HTML5 新增的带有语义化的标签</h2><ul>
<li>&lt;header&gt;：头部标签</li>
<li>&lt;nav&gt;：导航标签</li>
<li>&lt;article&gt;：内容标签</li>
<li>&lt;section&gt;：定义文档的某个区域</li>
<li>&lt;aside&gt;：侧边栏标签</li>
<li>&lt;footer&gt;：尾部标签</li>
</ul>
<h2 id="HTML5-新增的多媒体标签"><a href="#HTML5-新增的多媒体标签" class="headerlink" title="HTML5 新增的多媒体标签"></a>HTML5 新增的多媒体标签</h2><p>新增的多媒体标签主要包含两个：</p>
<p>1.音频：&lt;audio&gt;</p>
<p>2.视频：&lt;video&gt;</p>
<p>使用它们可以很方便的在页面中嵌入音频和视频，而不再去使用flash和其他浏览器插件</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>&lt;video&gt;元素支持三种视频格式：MP4、WebM、Ogg</p>
<p><strong>1.视频：&lt;video&gt;————常见属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">视频就绪自动播放（谷歌浏览器需要添加muted来解决自动播放问题）</td>
</tr>
<tr>
<td style="text-align:left">control</td>
<td style="text-align:left">controls</td>
<td style="text-align:left">向用户显示播放控件</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">pixels（像素）</td>
<td style="text-align:left">设置播放器宽度</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left">pixels（像素）</td>
<td style="text-align:left">设置值播放器高度</td>
</tr>
<tr>
<td style="text-align:left">loop</td>
<td style="text-align:left">loop</td>
<td style="text-align:left">播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td style="text-align:left">preioad</td>
<td style="text-align:left">auto（预加载视频）<br>none（不应加载视频）</td>
<td style="text-align:left">规定是否预加载视频（如果有了autoplay，就忽略该属性）</td>
</tr>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">url</td>
<td style="text-align:left">视频url地址</td>
</tr>
<tr>
<td style="text-align:left">poster</td>
<td style="text-align:left">imgurl</td>
<td style="text-align:left">视频等待的画面图片</td>
</tr>
<tr>
<td style="text-align:left">muted</td>
<td style="text-align:left">muted</td>
<td style="text-align:left">静音播放</td>
</tr>
</tbody>
</table>
</div>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>常见属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">音频在就绪后马上播放</td>
</tr>
<tr>
<td style="text-align:left">controls</td>
<td style="text-align:left">controls</td>
<td style="text-align:left">向用户显示控件</td>
</tr>
<tr>
<td style="text-align:left">loop</td>
<td style="text-align:left">loop</td>
<td style="text-align:left">循环播放</td>
</tr>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">url</td>
<td style="text-align:left">要播放的音频URL</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>谷歌浏览器把音频和视频自动播放都禁止了</li>
</ul>
<h2 id="HTML5-新增的-input-表单"><a href="#HTML5-新增的-input-表单" class="headerlink" title="HTML5 新增的 input 表单"></a>HTML5 新增的 input 表单</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type=”email”</td>
<td style="text-align:left">限制用户输入必须为Email类型</td>
</tr>
<tr>
<td style="text-align:left">type=”url”</td>
<td style="text-align:left">限制用户输入必须为URL类型</td>
</tr>
<tr>
<td style="text-align:left">type=”date”</td>
<td style="text-align:left">限制用户输入必须为日期类型</td>
</tr>
<tr>
<td style="text-align:left">type=”time”</td>
<td style="text-align:left">限制用户输入必须为时间类型</td>
</tr>
<tr>
<td style="text-align:left">type=”month”</td>
<td style="text-align:left">限制用户输入必须为月类型</td>
</tr>
<tr>
<td style="text-align:left">type=”week”</td>
<td style="text-align:left">限制用户输入必须为周类型</td>
</tr>
<tr>
<td style="text-align:left">type=”number”</td>
<td style="text-align:left">限制用户输入必须为数字类型</td>
</tr>
<tr>
<td style="text-align:left">type=”tel”</td>
<td style="text-align:left">手机号码</td>
</tr>
<tr>
<td style="text-align:left">type=”search”</td>
<td style="text-align:left">搜索框</td>
</tr>
<tr>
<td style="text-align:left">type=”color”</td>
<td style="text-align:left">生成一个颜色选择表单</td>
</tr>
</tbody>
</table>
</div>
<h2 id="HTML5-新增的表单属性"><a href="#HTML5-新增的表单属性" class="headerlink" title="HTML5 新增的表单属性"></a>HTML5 新增的表单属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">required</td>
<td style="text-align:left">required</td>
<td style="text-align:left">表单拥有该属性表示其内容不能为空，必填</td>
</tr>
<tr>
<td style="text-align:left"><strong>placeholder</strong></td>
<td style="text-align:left">提示文本</td>
<td style="text-align:left">表单的提示信息，存在默认值将不显示</td>
</tr>
<tr>
<td style="text-align:left">autofocus</td>
<td style="text-align:left">autofocus</td>
<td style="text-align:left">自动聚焦属性，页面加载完成自动聚焦到指定表单</td>
</tr>
<tr>
<td style="text-align:left">autocomplete</td>
<td style="text-align:left">off / on</td>
<td style="text-align:left">当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项<br>默认已经打开，如autocomplete=”on”，关闭autocomplete=”off”<br>需要放在表单内同时加上 name 属性,同时成功提交</td>
</tr>
<tr>
<td style="text-align:left">multiple</td>
<td style="text-align:left">multiple</td>
<td style="text-align:left">可以多选文件提交</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2.n维数组</title>
    <url>/2021/07/02/2-n%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="N维数组（ndarray）"><a href="#N维数组（ndarray）" class="headerlink" title="N维数组（ndarray）"></a>N维数组（ndarray）</h1><blockquote>
<p>ndarray是numpy的数组类，别名array</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="np-ndarray"><a href="#np-ndarray" class="headerlink" title="np.ndarray()"></a>np.ndarray()</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">用处</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shape(tuple)</td>
<td style="text-align:left">所创建数组的形状</td>
</tr>
<tr>
<td style="text-align:left">dtype(data-type)</td>
<td style="text-align:left">numpy数据的类型</td>
</tr>
<tr>
<td style="text-align:left">buffer</td>
<td style="text-align:left">初始化数据</td>
</tr>
<tr>
<td style="text-align:left">offset(int)</td>
<td style="text-align:left">初始化数据的首个数据的偏移量</td>
</tr>
<tr>
<td style="text-align:left">strides(int型tuple)</td>
<td style="text-align:left">每个轴的下标增加一时,数据指针在内存中增加的字节数</td>
</tr>
<tr>
<td style="text-align:left">order{‘C’,’F’}</td>
<td style="text-align:left">行优先(C-style)或列优先(Fortran-style)</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例</span></span><br><span class="line">np.ndarray(shape=(<span class="number">3</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>,buffer=np.arange(<span class="number">12</span>),offset=<span class="number">0</span>,order=<span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ndarray(shape=(<span class="number">3</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>,buffer=np.arange(<span class="number">12</span>),offset=<span class="number">0</span>,order=<span class="string">&quot;F&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  3,  6,  9],
       [ 1,  4,  7, 10],
       [ 2,  5,  8, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ndarray(shape=(<span class="number">3</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>,buffer=np.arange(<span class="number">20</span>),offset=<span class="number">20</span>,order=<span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])
</code></pre><h2 id="ndarray对象的常用属性"><a href="#ndarray对象的常用属性" class="headerlink" title="ndarray对象的常用属性"></a>ndarray对象的常用属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:left">转置</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:left">数列中元素个数</td>
</tr>
<tr>
<td style="text-align:center">itemsize</td>
<td style="text-align:left">数组中单个元素的字节长度</td>
</tr>
<tr>
<td style="text-align:center">dtype</td>
<td style="text-align:left">数组元素的数据类型对象</td>
</tr>
<tr>
<td style="text-align:center">ndim</td>
<td style="text-align:left">数组的维度</td>
</tr>
<tr>
<td style="text-align:center">shape</td>
<td style="text-align:left">数组的形状</td>
</tr>
<tr>
<td style="text-align:center">data</td>
<td style="text-align:left">指向存放数组数据的python buffer对象</td>
</tr>
<tr>
<td style="text-align:center">flat</td>
<td style="text-align:left">返回数组的一维迭代器</td>
</tr>
<tr>
<td style="text-align:center">imag</td>
<td style="text-align:left">返回数组的虚部</td>
</tr>
<tr>
<td style="text-align:center">real</td>
<td style="text-align:left">返回数组的实部</td>
</tr>
<tr>
<td style="text-align:center">nbytes</td>
<td style="text-align:left">数组中所有元素的字节长度</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.T</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  4,  8],
       [ 1,  5,  9],
       [ 2,  6, 10],
       [ 3,  7, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.size:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.itemsize&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.itemsize)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.dtype&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.ndim&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.flat&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.flat)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.nbytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.nbytes)</span><br></pre></td></tr></table></figure>
<pre><code>a.size:
12
-------------------------
a.itemsize
4
-------------------------
a.dtype
int32
-------------------------
a.ndim
2
-------------------------
a.flat
&lt;numpy.flatiter object at 0x0000023A25BBA040&gt;
-------------------------
a.nbytes
48
</code></pre><h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><ol>
<li>array</li>
<li>noes</li>
<li>zeros</li>
<li>eye：二维单位矩阵</li>
<li>identity：单位矩阵</li>
<li>full：生成由固定值填充的数组</li>
<li>full_like</li>
<li>arange：指定初始值、终值、步长</li>
<li>linspace：指定初始值、终值、元素个数</li>
<li>logspace：与linspaceleisi,但是创建的是等比数列</li>
<li>fromstring:从字符串中读取数据并创建数组</li>
<li>fromfunction：由第一个参数作为计算每个数组元素的函数（函数对象或者lambda表达式均可），第二个参数为数组的形状</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>,k = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0., 1., 0.],
       [0., 0., 1.],
       [0., 0., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full(shape=(<span class="number">2</span>,<span class="number">3</span>),fill_value= <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[2, 2, 2],
       [2, 2, 2]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
       1.e+09, 1.e+10])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="string">&quot;1,2,3,4,5&quot;</span>)</span><br><span class="line">np.fromstring(s1,dtype=<span class="built_in">int</span>,sep=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 4, 5])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s2 = (<span class="string">&quot;1 2 3 4 5&quot;</span>)</span><br><span class="line">np.fromstring(s2,dtype=<span class="built_in">int</span>,sep=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 4, 5])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.fromfunction(<span class="keyword">lambda</span> i,j:i+j,(<span class="number">3</span>,<span class="number">3</span>),dtype =<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">i,j</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i+j</span><br><span class="line"></span><br><span class="line">np.fromfunction(func,(<span class="number">3</span>,<span class="number">3</span>),dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
</code></pre><h2 id="创建特殊的二维数组"><a href="#创建特殊的二维数组" class="headerlink" title="创建特殊的二维数组"></a>创建特殊的二维数组</h2><ol>
<li>diag，返回数组的对角元素，或创建对角阵，对角线由参数k控制</li>
<li>diagflat，以输入作为对角元素，创建一个矩阵，对角线由k控制</li>
<li>tri，生成一个矩阵，在某对角线下元素全为1，其余为0，对角线由k控制</li>
<li>tril，输入一个矩阵，返回一个下三角阵，对角线由k控制</li>
<li>triu，类似tril,但返回矩阵的上三角矩阵</li>
<li>vander，输入一个一维数组，返回一个范德蒙行列式</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(a,k=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([4, 9])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(np.diag(a))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  0,  0],
       [ 0,  5,  0],
       [ 0,  0, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diagflat([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],k=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 0, 0, 0],
       [0, 0, 2, 0, 0],
       [0, 0, 0, 3, 0],
       [0, 0, 0, 0, 4],
       [0, 0, 0, 0, 0]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.tri(<span class="number">3</span>,<span class="number">4</span>,k=<span class="number">1</span>,dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 1, 0, 0],
       [1, 1, 1, 0],
       [1, 1, 1, 1]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.tri(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1., 0., 0., 0.],
       [1., 1., 0., 0.],
       [1., 1., 1., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line">np.tril(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
----------------------





array([[ 0,  0,  0,  0],
       [ 4,  5,  0,  0],
       [ 8,  9, 10,  0]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.triu(a)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 0,  5,  6,  7],
       [ 0,  0, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.vander([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<pre><code>array([[  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [ 64,  16,   4,   1],
       [125,  25,   5,   1]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.vander([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],N=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  2,  1],
       [ 9,  3,  1],
       [16,  4,  1],
       [25,  5,  1]])
</code></pre><h2 id="轴"><a href="#轴" class="headerlink" title="轴"></a>轴</h2><p>多维ndarray中，每一维都叫一个轴axis。有很多对于ndarray对象的运算都是基于axis进行，在入门的时候也接触了一些轴方面的应用，比如下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:,<span class="number">2</span>] <span class="comment"># 第3列所有元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 2,  6, 10])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>] <span class="comment"># 这个也等价于a[1,2]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([6])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">3</span>,:] <span class="comment"># 2到3行所有列 </span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>2.栈和队列</title>
    <url>/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>栈和队列是线性表的子集（是插入和删除位置受限的线性表）</strong></p>
<h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><blockquote>
<p>限定只能在表的一端进行插入和删除运算的线性表</p>
</blockquote>
<p>又称为<strong>后进先出</strong>(Last In First Out)的线性表，简称 <strong>LIFO</strong> 结构</p>
<span id="more"></span>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>栈是进行插入、删除操作的线性表。</p>
<p>表尾称为 <strong>栈顶</strong> Top；表头称为 <strong>栈底</strong> Base</p>
<p>插入元素到 <strong>栈顶</strong> 的操作称为 <strong>入栈</strong> PUSH</p>
<p>从 <strong>栈顶</strong> 删除最后一个元素的操作，称为 <strong>出栈</strong> POP</p>
<p>逻辑结构：一对一</p>
<p>存储结构：用 <strong>顺序栈</strong> 或 <strong>链栈</strong> 均可，顺序栈更常见</p>
<p>运算规则：只能在栈顶运算，且访问结点时依照LIFO原则</p>
<p>分类：</p>
<ul>
<li>静态栈</li>
<li>动态栈</li>
</ul>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li><strong>top 指针</strong>指示栈顶元素</li>
<li><strong>base 指针</strong>指示栈底元素<br>为了方便操作，top指示在栈顶元素之上</li>
<li>用 <strong>stacksize</strong> 表示栈可使用的最大容量</li>
<li>空栈：base==top</li>
<li>栈满：top-base==stacksize</li>
</ul>
<h2 id="C语言实现链栈的相关操作"><a href="#C语言实现链栈的相关操作" class="headerlink" title="C语言实现链栈的相关操作"></a>C语言实现链栈的相关操作</h2><p>顺序栈也类似<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125; NODE,* PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">	PNODE pTop;</span><br><span class="line">	PNODE pBottom;</span><br><span class="line">&#125; STACK,* PSTACK;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK,<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	STACK S;<span class="comment">// 内存里面有了两个变量pTop,pBottom</span></span><br><span class="line"></span><br><span class="line">	init(&amp;S);<span class="comment">// 造出一个空栈</span></span><br><span class="line">	push(&amp;S,<span class="number">1</span>);<span class="comment">// 压栈</span></span><br><span class="line">	push(&amp;S,<span class="number">2</span>);</span><br><span class="line">	traverse(&amp;S);</span><br><span class="line">	clear(&amp;S);</span><br><span class="line">	<span class="comment">//traverse(&amp;S);</span></span><br><span class="line">	<span class="keyword">if</span>(pop(&amp;S, &amp;val)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈成功，出栈的元素是%d\n&quot;</span>,val);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(&amp;S);<span class="comment">//遍历输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pS)</span> </span>&#123;</span><br><span class="line">	pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (pS-&gt;pTop == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pS-&gt;pBottom = pS-&gt;pTop;</span><br><span class="line">		pS-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>; <span class="comment">// pS-&gt;pBottom-&gt;pNext = NULL; </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pS,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	pNew-&gt;data = val;</span><br><span class="line">	pNew-&gt;pNext = pS-&gt;pTop;<span class="comment">//pS-&gt;pTop不能改成pS-&gt;pBottom</span></span><br><span class="line">	pS-&gt;pTop = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK pS)</span> </span>&#123;</span><br><span class="line">	PNODE p = pS-&gt;pTop;</span><br><span class="line">	<span class="keyword">while</span>(p != pS-&gt;pBottom) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p=p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pS)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把pS所指向的栈出栈一次，并把出栈的元素存入pVal形参所指向的变量中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pS,<span class="keyword">int</span> * pVal)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		PNODE r =pS-&gt;pTop;</span><br><span class="line">		*pVal = r-&gt;data;</span><br><span class="line">		pS-&gt;pTop=r-&gt;pNext;</span><br><span class="line">		r = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pS)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		PNODE p = pS-&gt;pTop;	</span><br><span class="line">		<span class="keyword">while</span>(p != pS-&gt;pBottom) &#123;</span><br><span class="line">			pS-&gt;pTop = p-&gt;pNext;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">			p = pS-&gt;pTop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>进制转换</strong></p>
<p><strong>括号匹配</strong></p>
<p><strong>表达式求值：</strong></p>
<ul>
<li>表达式组成<ul>
<li>操作符(operand)：常数、变量</li>
<li>运算符(operator)：算术运算符、关系运算符和逻辑运算符</li>
<li>界限符(delimiter)：左右括弧和表达式结束符</li>
</ul>
</li>
<li>需要两个栈：<ul>
<li>算符栈 OPTR，寄存运算符</li>
<li>操作数栈 OPND,寄存运算数和运算结果</li>
</ul>
</li>
<li>求值的处理过程是自左向右扫描表达式的每一个字符<ul>
<li>当扫描的是数字，将其压入OPND栈</li>
<li>当扫描到的是运算符<ul>
<li>若这个运算符比OPTR栈顶运算符优先级高，则入栈OPTR</li>
<li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，将运算结果压入栈OPND</li>
</ul>
</li>
</ul>
</li>
<li>继续处理当前字符，直到结束符为止</li>
</ul>
<h1 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h1><blockquote>
<p>只能在表头的一端进行插入运算，在表的另一端进行删除运算的线性表</p>
</blockquote>
<p>队列是一种 <strong>先进先出</strong>(First In First Out—<strong>FLFO</strong>)的线性表。在表一段插入（表尾），在另一端（表头）删除</p>
<h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><p>逻辑结构：一对一</p>
<p>存储结构：<strong>顺序队</strong> 或 <strong>链队</strong>，以<strong>循环顺序队列更常见</strong></p>
<p>运算规则：只能在队首和队尾运算，且访问结点时依照 FIFO 的原则</p>
<p>分类：</p>
<ul>
<li><p>链式队列：用链表实现</p>
</li>
<li><p>静态队列：用数组实现</p>
<ul>
<li>静态队列通常都必须是循环队列</li>
</ul>
</li>
</ul>
<p>循环队列：</p>
<ol>
<li>静态队列为什么必须是循环队列</li>
<li>循环队列需要几个参数来确定</li>
<li>循环队列各个参数的含义</li>
<li>循环队列入队伪算法</li>
<li>循环队列出队伪算法</li>
<li>如何判断循环队列是否为空</li>
<li>如何判断循环队列是否已满</li>
</ol>
<h2 id="队列顺序表示和实现"><a href="#队列顺序表示和实现" class="headerlink" title="队列顺序表示和实现"></a>队列顺序表示和实现</h2><p>设立一个队首指针front,一个队尾指针rear，分别指向队首和队尾元素</p>
<ul>
<li>初始化：<code>front=rear=0</code></li>
<li>入队：将新元素插入rear所指的位置，然后rear加1</li>
<li>出队：删去front所指的元素，然后加1并返回被删元素</li>
<li>队列为空：<code>front == rear</code></li>
<li>队满：<code>rear == MAX_QUEUE_SIZE-1</code> 或 <code>front==rear</code></li>
</ul>
<p>在非空队列里，队首指针始终指向队头元素，而队尾指针始终指向队尾元素的下一位置。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>1.顺序队列中存在 <strong>“假溢出”</strong> 现象。</p>
<p><strong>假溢出:</strong> 尾指针已超出向量空间的上界而不能做入队操作</p>
<p><strong>解决方法</strong>：引入循环队列<br>C呈现<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span> == MAX_QUEUE_SIZE)</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	i++;</span><br></pre></td></tr></table></figure><br><strong>用模运算可简化为</strong>：<code>i=(i+1) % MAX_QUEUE_SIZE</code>;</p>
<p>2.队空和队满时头尾指针均相等，<strong>无法通过front=rear来判断队列”空”，还是”满”</strong>。</p>
<p><strong>解决方法</strong>:</p>
<ul>
<li>1.另外 <strong>设一个标志tag</strong> 以区别队空、队满（如队满为1，队空为0）</li>
<li>2.另外设一个变量，记录元素个数</li>
<li>3.<strong>少用一个元素空间</strong><ul>
<li>队空：<code>front==rear</code></li>
<li>队满：<code>(rear+1)%MAX_QUEUE_SIZE==font</code><br><img src="/2021/07/27/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/queue1.png"></li>
</ul>
</li>
</ul>
<h2 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h2><ul>
<li>队列初始化：分配空间，头尾指针置为0</li>
<li><strong>队列长度</strong>：<code>(reat-front+MAX_QUEUE_SIZE)%MAX_QUEUE_SIZE</code></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2.算法(用C语言实现)</title>
    <url>/2021/06/28/2-%E7%AE%97%E6%B3%95%EF%BC%88C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h1><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>设两数为$a、b(a\geqslant b)$，求$a$和$b$的最大公约数步骤：</p>
<ol>
<li>用$a$除以$b(a\geqslant b)$,得$a\div b=q\cdots r_1(0\leqslant r_1)$</li>
<li>若$r_1=0$,则$(a,b)=b$</li>
<li>若$r_1\neq 0$,则再用$b$除以$r_1$,得$b\div r_1=q\cdots r_2(0\leqslant r_2)$</li>
<li>若$r_2=0$，则$(a,b)=r_1$，若$r_2\neq0$,则继续用$r_1$除以$r_2$,……如此下去，直到能整除为止，<br>其最后一个余数为0的除数，即为$(a,b)$的最大公约数</li>
</ol>
<p>简单来说就是$a$和$b$的最大公约数等于 <strong>$a$的余数</strong> 和$b$的最大公约数</p>
<p>C语言代码实现</p>
<p>1.while循环实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max,min,c;</span><br><span class="line">    max=(a&gt;b)?a:b;</span><br><span class="line">    min=(a&lt;b)?a:b;</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = max % min;</span><br><span class="line">        max = min;</span><br><span class="line">        min = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.函数嵌套实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max,min;</span><br><span class="line">    max=(a&gt;b)?a:b;</span><br><span class="line">    min=(a&lt;b)?a:b;</span><br><span class="line">    <span class="keyword">if</span>(max % min==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(max,max % min);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>求出最大公因数，最小公倍数也很容易得出，就是两数乘积除以最大公约数</p>
<h2 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h2><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote>
<p>基本思想：两两比较相邻记录的关键字，，如果反序就交换，直到没有反序为止</p>
</blockquote>
<p>步骤：（正序为例）</p>
<ol>
<li>比较相邻元素，如果第一个比第二个大，则两数交换。</li>
<li>对之后的相邻元素进行同样的工作，从开始到结束,这样最后的元素就是最大的数，也就像泡泡一样浮到顶端不用管了</li>
<li>(小循环)针对前面未排序元素重复以上步骤。</li>
<li>(大循环)重复上述步骤，直到排序完成</li>
</ol>
<p>C语言代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp,m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="keyword">while</span>(m)<span class="comment">//如果已经是有序数组就跳出while循环，从而提高效率</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//循环次数</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N<span class="number">-1</span>-i;j++)<span class="comment">//一次循环的比较次数</span></span><br><span class="line">                <span class="keyword">if</span>(*(p+j)&gt;*(p+j+<span class="number">1</span>))<span class="comment">//相邻两个数进行比较</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        m=<span class="number">1</span>;</span><br><span class="line">                        temp=*(p+j+<span class="number">1</span>);</span><br><span class="line">                        *(p+j+<span class="number">1</span>)=*(p+j);</span><br><span class="line">                        *(p+j)=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序的复杂度分析</strong><br>最好的情况，本身有序</p>
<p>时间复杂度为$O(n)$</p>
<p>最坏的情况：<br>$\sum\limits_{k=2}^n(k-1)=\displaystyle\frac{n(n-1)}{2}$</p>
<p>也就是说最坏的情况，比较了$\displaystyle\frac{n(n-1)}{2}$次</p>
<p>时间复杂度为$O(n^2)$</p>
<p>平均时间复杂度$O(n^2)$</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p>首先在末排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，放在已排好序序列的末尾。</p>
</blockquote>
<p>简单来说就是从后面的数选出较小的数排到前面</p>
<p>C语言代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,i,j;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//循环次数</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;N;j++)<span class="comment">//一次循环的比较次数</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])<span class="comment">//也就是第i+1个数和后面的数比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp=a[j];</span><br><span class="line">                    a[j]=a[i];</span><br><span class="line">                    a[i]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论传入什么数据时间复杂度都是$O(n^2)$</p>
<p>当然这种排序方法也是一般人最容易想到的排序方法n适合处理数据较少的情况。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的个数加一的有序数组<br>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可被认为已经排好序</li>
<li>取出下一个元素，在已经排好的数组中向前扫描</li>
<li>如果已排序的元素大于这个取出的元素，就移到下一个位置</li>
<li>(小循环)重复步骤3，直到找到已排序的元素小于或等于该取出元素</li>
<li>将取出元素插入到该空出的位置</li>
<li>(大循环)重复上述步骤<br>C语言代码实现<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[i];<span class="comment">//储存要插入的数据</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;temp&lt;a[j] &amp;&amp; j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];<span class="comment">//数据向后移，给较小数据挪位</span></span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//插入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>步骤：</p>
<ol>
<li>如果n=1,结束</li>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>将两个子序列分别采用归并排序</li>
<li>将两个排好序的子序列合并成一个最终的排序序列</li>
</ol>
<p>C语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> mid)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">if</span>(end-start&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (start + end)/<span class="number">2</span>; </span><br><span class="line">		mergesort(a,start,mid);<span class="comment">//递归分解数组</span></span><br><span class="line">		mergesort(a,mid+<span class="number">1</span>,end);</span><br><span class="line">		merge(a,start,end,mid);<span class="comment">//归并数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*归并函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=start;</span><br><span class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end)<span class="comment">//两个数组pk比较大小，储存在b中</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">			b[k++]=a[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			b[k++]=a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == mid + <span class="number">1</span>)<span class="comment">//第二个数组剩余的多</span></span><br><span class="line">		<span class="keyword">while</span>(j &lt;= end)</span><br><span class="line">			b[k++]=a[j++];<span class="comment">//那么第二个数组直接排到后面</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(j == end + <span class="number">1</span>)<span class="comment">//第一个数组剩余的多</span></span><br><span class="line">		<span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">			b[k++]=a[i++];</span><br><span class="line">	<span class="keyword">for</span>(i=start,j=<span class="number">0</span>;j&lt;k;i++,j++)</span><br><span class="line">		a[i]=b[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	mergesort(a,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>思想：</p>
<ul>
<li>找公共前后缀</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*KMP算法实现*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> string[] ,<span class="keyword">char</span> ch[] ,<span class="keyword">int</span> next[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> next[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j; </span><br><span class="line">	<span class="keyword">char</span> string[<span class="number">15</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">9</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> next[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	next[<span class="number">0</span>]=<span class="number">8</span>;</span><br><span class="line">	<span class="built_in">GetNext</span>(ch,next);</span><br><span class="line">	<span class="comment">//为啥调用完函数后,字符数组ch中的值会消失?</span></span><br><span class="line">	<span class="keyword">char</span> ch1[<span class="number">9</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//没找到解决办法，只好重新创建一个了~_~</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)<span class="comment">//打印出next数组中的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,next[i]);</span><br><span class="line">	j=<span class="built_in">kmp</span>(string,ch1,next);</span><br><span class="line">	<span class="keyword">if</span>(j)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;匹配成功,从第%d个开始\n&quot;</span>,j);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;匹配失败\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> next[])</span><span class="comment">//得到next数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">	next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=next[<span class="number">0</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">0</span>||ch[i]==ch[j])<span class="comment">//这里挺难理解的</span></span><br><span class="line">			next[++i]=++j;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j=next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> string[],<span class="keyword">char</span> ch[],<span class="keyword">int</span> next[])</span><span class="comment">//字符匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=<span class="number">14</span>&amp;&amp;j&lt;next[<span class="number">0</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">0</span>||string[i]==ch[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j == next[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">return</span> i-next[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法花了很长时间，主要浪费的时间不是在思考上，而是找 bug 上，程序没有报错，但是却输出不了正确的值，用笔一步一步推演发现并没有逻辑上的错误，一点点检查才发现,字符数组ch在调用完void Getnext()函数后里面的值竟然消失了，很奇怪，用的编译器是Microsoft visual c++6.0,到网上寻找也没找到答案，最终只好创建一个新的数组 —﹏—。</p>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>基本原理：</p>
<p>将数字<strong>按顺序排列</strong>，将要查找的元素（key）与数组中间元素比较</p>
<ul>
<li>如果key小于中间元素，只需要在数组的前一半元素中继续查找</li>
<li>如果key和中间元素相等，匹配成功，查找结束</li>
<li>如果key大于中间元素，只需要在数组的后一半元素中继续查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nums</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(struct Nums *N,<span class="keyword">int</span> low,<span class="keyword">int</span> numsSize,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> high = numsSize<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high) &#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(N[mid].num==x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(N[mid].num &gt; x) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><h2 id="react-时间分片"><a href="#react-时间分片" class="headerlink" title="react 时间分片"></a>react 时间分片</h2><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h1>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2-计网第二章</title>
    <url>/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、物理层基本概念"><a href="#一、物理层基本概念" class="headerlink" title="一、物理层基本概念"></a>一、物理层基本概念</h1><blockquote>
<p>物理层解决如何在来解决各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输</p>
</blockquote>
<p>物理层主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性</p>
<p>1、机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</p>
<p>2、电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等</p>
<p>3、功能特性：指明某条线上出现的某一 <strong>电平表示何种意义</strong>，接口部件的信号线的用途。</p>
<p>4、规程特性：（过程特性）定义各条物理线路的工作规程和时序关系</p>
<h1 id="二、数据通信基础知识"><a href="#二、数据通信基础知识" class="headerlink" title="二、数据通信基础知识"></a>二、数据通信基础知识</h1><h2 id="2-1-典型数据通信模型"><a href="#2-1-典型数据通信模型" class="headerlink" title="2.1. 典型数据通信模型"></a>2.1. 典型数据通信模型</h2><p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.png" style="zoom:50%;"></p>
<p>模拟信号是指用连续变化的物理量表示的信息，其信号的幅度，或频率，或相位随时间作连续变化，或在一段连续的时间间隔内，其代表信息的特征量可以在任意瞬间呈现为任意数值的信号。</p>
<span id="more"></span>
<h2 id="2-2-数据通信相关术语"><a href="#2-2-数据通信相关术语" class="headerlink" title="2.2. 数据通信相关术语"></a>2.2. 数据通信相关术语</h2><p>通信的目的是传送消息</p>
<ul>
<li><p><strong>数据：</strong>传送信息的实体，通常是有意义的符号序列</p>
</li>
<li><p><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong></p>
<ul>
<li>数字信号：代表消息的参数取值是离散的</li>
<li>模拟信号：代表消息的参数取值是连续的</li>
</ul>
</li>
<li><p><strong>信源：</strong>产生和发送数据的源头</p>
</li>
<li><p><strong>信宿：</strong>接受数据的终点</p>
</li>
<li><p><strong>信道：</strong>信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</p>
<script type="math/tex; mode=display">
\text{信道}\;
\begin{cases}
\;\text{传输信号}
\begin{cases}
\text{模拟信道（传送模拟信号）}\\ \\
\text{数字信道（传送数字信号）}
\end{cases}
\\ \\
\;\text{传输媒介}
\begin{cases}
\;\text{无线信道}\\ \\
\;\text{有线信道}
\end{cases}
\end{cases}</script></li>
</ul>
<h2 id="2-3-三种通信方式"><a href="#2-3-三种通信方式" class="headerlink" title="2.3. 三种通信方式"></a>2.3. 三种通信方式</h2><p>1、单工通信：只有一个方向的通信而没有反方向的交互，仅需要 <strong>一条</strong> 信道</p>
<p>2、半双工通信：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接收，需要 <strong>两条</strong> 信道。</p>
<p>3、全双工通信：通信双方可以同时发送和接受信息，也需要 <strong>两条</strong> 信道</p>
<h2 id="2-4-两种数据传输方式"><a href="#2-4-两种数据传输方式" class="headerlink" title="2.4. 两种数据传输方式"></a>2.4. 两种数据传输方式</h2><script type="math/tex; mode=display">
\text{传输方式}\;
\begin{cases}
\text{串行传输：速度慢，费用低，适合远距离}\\
\\
\text{并行传输：速度快，费用高，适合近距离}\\
\qquad\text（用于计算机内部数据传输）
\end{cases}</script><h2 id="2-5-码元"><a href="#2-5-码元" class="headerlink" title="2.5. 码元"></a>2.5. 码元</h2><p><strong>码元</strong> 是指用一个 <strong>固定时长</strong> 的 <strong>信号波形</strong>（数组脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而 <strong>该时长称为码元宽度</strong>。当码元的离散状态有M个时（M大于2），此时码元为M进制码元。</p>
<p>1 码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态</p>
<h2 id="2-6-速率、波特、带宽"><a href="#2-6-速率、波特、带宽" class="headerlink" title="2.6. 速率、波特、带宽"></a>2.6. 速率、波特、带宽</h2><p>速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用 <strong>码元传输速率</strong> 和 <strong>信息传输速率</strong> 表示</p>
<ul>
<li><strong>码元传输速率：</strong>别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为<strong>脉冲个数或信号变化的次数</strong>），单位是 <strong>波特（Baud）</strong>。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关<ul>
<li>简单来说就是 <strong>1s传输多少个码元</strong>（1 Baud = 1 码元/秒）</li>
</ul>
</li>
<li><strong>信息传输速率：</strong>别名信息速率、比特率等，表示单位时间内数字通信系统的二进制码元个数（即比特数），单位是比特/秒（b/s）<ul>
<li>简单来说就是 <strong>1s传输多少个比特</strong></li>
</ul>
</li>
</ul>
<p><strong>关系：</strong> 若一个码元携带 n bit 的信息量，则 M Baud 的码元传输速率所对应的信息传输速率为 $\text{M}\times \text{n\;bit/s}$</p>
<p><strong>带宽：</strong>表示在单位时间内从网络中的某一点到另一点  所能通过的 <strong>“最高数据率”</strong> ，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p>
<h1 id="三、编码与调制"><a href="#三、编码与调制" class="headerlink" title="三、编码与调制"></a>三、编码与调制</h1><h2 id="3-1-基带信号与宽带信号"><a href="#3-1-基带信号与宽带信号" class="headerlink" title="3.1. 基带信号与宽带信号"></a>3.1. 基带信号与宽带信号</h2><p><strong>信道：</strong>信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</p>
<script type="math/tex; mode=display">
\text{信道}\;
\begin{cases}
\;\text{传输信号}
\begin{cases}
\text{模拟信道（传送模拟信号）}\\ \\
\text{数字信道（传送数字信号）}
\end{cases}
\\ \\
\;\text{传输媒介}
\begin{cases}
\;\text{无线信道}\\ \\
\;\text{有线信道}
\end{cases}
\end{cases}</script><p><strong>信道上的信号：</strong></p>
<ul>
<li><strong>基带信号：</strong>将数字信号1和0直接用两种不同的电压表示，再送到 <strong>数字信道</strong> 上去（<strong>基带传输</strong>）。来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的 <strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号</li>
<li><strong>宽带信号：</strong>把基带信号进行调制后形成的频分复用模拟信号，再传送到 <strong>模拟信道</strong>上去传输（<strong>宽带信道</strong>）。把基带信号经过 <strong>载波调制</strong> 后，把信号的 <strong>频率范围搬移</strong> 到 <strong>较高的频段</strong> 以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li>
</ul>
<p>所以在传输<strong>距离较近</strong>时，计算机网络采用<strong>基带传输</strong></p>
<p><strong>传输距离较远</strong>，采用<strong>宽带传输</strong>方式</p>
<h2 id="3-2-编码与调制"><a href="#3-2-编码与调制" class="headerlink" title="3.2. 编码与调制"></a>3.2. 编码与调制</h2><script type="math/tex; mode=display">
\text{数据}\longrightarrow {\color{green}\text{数字信号}\quad\text{编码}}\\
\text{数据}\longrightarrow {\color{red}\text{模拟信号}\quad\text{调制}}</script><script type="math/tex; mode=display">
\begin{aligned}
&{\color{green}\text{数字} }\xrightarrow{\text{数字发送器} }{\color{green}\text{数字信号}\quad\text{编码}}\\
&{\color{green}\text{数据} }\xrightarrow{\;\text{ 调制器 }\;\;}{\color{red}\text{模拟信号}\quad\text{调制}}
\end{aligned}
\qquad\begin{aligned}
&{\color{red}\text{模拟} }\xrightarrow{\text{PCM编码器} }{\color{green}\text{数字信号}\quad\text{编码}}\\
&{\color{red}\text{数据} }\xrightarrow{\text{放大器调制器} }{\color{red}\text{模拟信号}\quad\text{调制}}
\end{aligned}</script><h3 id="3-2-1-数字数据编码为数字信号"><a href="#3-2-1-数字数据编码为数字信号" class="headerlink" title="3.2.1. 数字数据编码为数字信号"></a>3.2.1. 数字数据编码为数字信号</h3><p><strong>（1）非归零编码【NRZ】：</strong></p>
<p>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方<strong>难以保持同步</strong></p>
<p><strong>（2）曼彻斯特编码</strong></p>
<p>将一个码元分成两个相等的间隔，前一个间隔为低电平，后一个间隔为高电平表示码元1；码元0则正好相反。也可以采用相反的规定。</p>
<p>该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步），又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。</p>
<p>每一个码元都被调成两个电平，所以<strong>数据传输速率只有调制速率的1/2</strong></p>
<p><strong>（3）差分曼彻斯特编码</strong></p>
<p><strong>同1异0</strong></p>
<p>常用于局域网传输，其规则是：若常用码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且<strong>抗干扰强于曼彻斯特编码</strong></p>
<p><strong>（4）归零编码【RZ】：</strong></p>
<p>信号电平在一个码元之内都要恢复到零    </p>
<p><strong>（5）反向不归零编码【NRZI】</strong></p>
<p>信号电平翻转表示0，信号电平不变表示1</p>
<p><strong>（6）4B/5B编码</strong></p>
<p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>4比特数据</th>
<th>5比特编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>11110</td>
</tr>
<tr>
<td>0001</td>
<td>01001</td>
</tr>
<tr>
<td>0010</td>
<td>10100</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/4.png" style="zoom:50%;"></p>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/5.png" style="zoom:50%;"></p>
<h3 id="3-2-2-数字数据调制为模拟信号"><a href="#3-2-2-数字数据调制为模拟信号" class="headerlink" title="3.2.2. 数字数据调制为模拟信号"></a>3.2.2. 数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/6.png" style="zoom: 67%;"></p>
<h3 id="3-3-3-模拟数据编码为数字信号"><a href="#3-3-3-模拟数据编码为数字信号" class="headerlink" title="3.3.3. 模拟数据编码为数字信号"></a>3.3.3. 模拟数据编码为数字信号</h3><p>计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即<strong>实现音频数字化</strong>）</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步：抽样、量化、编码。</p>
<ul>
<li><p><strong>抽样：</strong>对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号</p>
<p>为了是所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：$\text{f}_{\text{采样频率} }\geqslant 2\text{f}_{\text{信号最高频率} }$</p>
</li>
<li><p><strong>量化：</strong>把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的点评复制转换为离散的数字量。</p>
</li>
<li><p><strong>编码：</strong>把量化的结果转换为与之对应的二进制编码</p>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/7.png" style="zoom: 67%;"></p>
</li>
</ul>
<h3 id="3-3-4-模拟数据调制为模拟信号"><a href="#3-3-4-模拟数据调制为模拟信号" class="headerlink" title="3.3.4 模拟数据调制为模拟信号?"></a>3.3.4 模拟数据调制为模拟信号?</h3><p>为了实现传输的有效性，可能需要较高的频率。 这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<h1 id="四、奈氏准则、香农定理"><a href="#四、奈氏准则、香农定理" class="headerlink" title="四、奈氏准则、香农定理"></a>四、奈氏准则、香农定理</h1><h2 id="4-1-失真"><a href="#4-1-失真" class="headerlink" title="4.1. 失真"></a>4.1. 失真</h2><p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.png" style="zoom: 50%;"></p>
<p>影响失真程度因素：</p>
<ul>
<li><strong>码元传输速率</strong></li>
<li><strong>信号传输距离</strong></li>
<li><strong>噪声干扰</strong></li>
<li>传输媒体质量</li>
</ul>
<h3 id="4-1-1-码间串扰"><a href="#4-1-1-码间串扰" class="headerlink" title="4.1.1. 码间串扰"></a>4.1.1. 码间串扰</h3><p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/3.png" style="zoom:50%;"></p>
<p><strong>码间串扰：</strong>接收端收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象</p>
<p>传输过快，导致码元在接收端距离过近，界限就不清楚，而这就出现了奈氏准则.</p>
<h2 id="4-2-奈氏准则（奈奎斯特定理）"><a href="#4-2-奈氏准则（奈奎斯特定理）" class="headerlink" title="4.2. 奈氏准则（奈奎斯特定理）"></a>4.2. 奈氏准则（奈奎斯特定理）</h2><blockquote>
<p>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz</p>
</blockquote>
<p><strong>理想低通信道下的极限传输速率</strong>  $=2\text{W}\log_2\text{V(b/s)}$</p>
<p>其中 V 表示几种码元/码元的离散电平数目</p>
<p>这部分可在通讯原理教科书查阅，我们只需要知道：</p>
<ul>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li>信道的 <strong>频带越宽</strong>（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输</li>
<li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</li>
<li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法</li>
</ul>
<h2 id="4-3-香农定理"><a href="#4-3-香农定理" class="headerlink" title="4.3. 香农定理"></a>4.3. 香农定理</h2><p><strong>噪声</strong>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对较小。因此，<strong>信噪比</strong> 就很重要</p>
<script type="math/tex; mode=display">
\text{信噪比}=\frac{\text{信号的平均功率} }{\text{噪声的平均功率} }</script><p>常记为S/N，并用分贝（dB）作为度量单位，即：</p>
<script type="math/tex; mode=display">
\text{信噪比（dB）} = 10\log_{10}\text{(S/N)}</script><p>它们都叫做信噪比，只是衡量单位不同，而往往这个值会很大，所以一般取对数，<strong>严格来说信噪比只是S/N，声强级才是 $10\log_{10}\text{(S/N)}$</strong>，声强级是为了方便读数理解而对信噪比进行的变换（类似科学记数法）</p>
<p><strong>香浓定理：</strong>在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限</p>
<p><strong>信道的极限数据传输速率</strong> $=\text{W}\log_2(1+\dfrac{S}{N})\text{（b/s）}$</p>
<p>W 表示带宽 (Hz)，信噪比 S/N </p>
<p><br></p>
<p><strong>根据公式得到的推论：</strong></p>
<ul>
<li><p>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong></p>
</li>
<li><p>对于一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p>
</li>
<li><p>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现<strong>无差别的传输</strong></p>
</li>
<li><p>香浓定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p>
</li>
</ul>
<h2 id="4-4-二者区别"><a href="#4-4-二者区别" class="headerlink" title="4.4. 二者区别"></a>4.4. 二者区别</h2><p><strong>奈氏定理（内忧）：</strong></p>
<p>带宽受限无噪声条件下，为了避免码间串扰，码元传输速率的上限 2W Baud</p>
<p>理想低通信道下的极限传输速率  $=2\text{W}\log_2\text{V(b/s)}$</p>
<p>要想提高数据率，就要提高带宽/采用更好的编码技术</p>
<p><strong>香农定理（外患）：</strong></p>
<p>带宽受限有噪声条件下的信息传输速率</p>
<p>信道的极限数据传输速率 $=\text{W}\log_2(1+\dfrac{S}{N})\text{（b/s）}$</p>
<p>要想提高数据率，就要提高带宽/信噪比</p>
<h1 id="五、物理层传输介质"><a href="#五、物理层传输介质" class="headerlink" title="五、物理层传输介质"></a>五、物理层传输介质</h1><h2 id="5-1-传输介质及分类"><a href="#5-1-传输介质及分类" class="headerlink" title="5.1. 传输介质及分类"></a>5.1. 传输介质及分类</h2><p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p>
<p><strong>传输媒体并不是物理层。</strong>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层，在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p>
<script type="math/tex; mode=display">
\text{传输介质}
\begin{cases}
\text{导向性传输介质}\rightarrow \text{电磁波被导向沿着固体媒介传播}\\
\\
\text{非导向型传输介质}\rightarrow\text{自由空间，介质可以是空气、真空、海水等}
\end{cases}</script><h2 id="5-2-导向型传输介质"><a href="#5-2-导向型传输介质" class="headerlink" title="5.2. 导向型传输介质"></a>5.2. 导向型传输介质</h2><h3 id="5-2-1-双绞线-？"><a href="#5-2-1-双绞线-？" class="headerlink" title="5.2.1. 双绞线 ？"></a>5.2.1. 双绞线 ？</h3><p>双绞线是古老的、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的<strong>铜导线</strong>组成。</p>
<p><strong>绞合可以减少对相邻导线的电磁干扰</strong></p>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/8.png" style="zoom:50%;"></p>
<h3 id="5-2-2-同轴电缆"><a href="#5-2-2-同轴电缆" class="headerlink" title="5.2.2. 同轴电缆"></a>5.2.2. 同轴电缆</h3><p>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。按特性阻抗数值的不同，通常将同轴电缆分为两类：50 $\Omega$ 同轴电缆和75 $\Omega$同轴电缆。其中，50 $\Omega$ 同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用；75 $\Omega$ 同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统。</p>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/9.png" style="zoom:50%;"></p>
<h3 id="5-2-3-光纤"><a href="#5-2-3-光纤" class="headerlink" title="5.2.3. 光纤"></a>5.2.3. 光纤</h3><p>光纤通信就是利用光导纤维（简称光纤）传递光脉冲来进行通信。由光脉冲表示1、无光脉冲表示 0 。而可见光的频率大约是 $10^8$ MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体的带宽。</p>
<p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p>
<p>光纤主要<strong>纤芯（实心的！）</strong>和<strong>包层</strong>构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现<strong>全反射</strong>，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去</p>
<p><img src="/2021/11/17/2-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/10.png" style="zoom:50%;"></p>
<p><strong>超低损耗，传送超远距离</strong></p>
<p>光纤的特点：</p>
<p>1、传输<strong>损耗小</strong>，中继距离长，对远距离传输特别经济。</p>
<p>2、<strong>抗雷电和电磁干扰性好。</strong></p>
<p>3、无串音干扰，保密性好，也<strong>不易被窃听或截取数据</strong>。</p>
<p>4、<strong>体积小，重量轻。</strong></p>
<h2 id="5-3-非导向型传输介质"><a href="#5-3-非导向型传输介质" class="headerlink" title="5.3. 非导向型传输介质"></a>5.3. 非导向型传输介质</h2><p><strong>无线电波</strong>（信号向<strong>所有方向</strong>传播）：较强穿透能力，可传远距离，广泛用于通信领域（如手机通信）</p>
<p><strong>微波</strong>（信号<strong>固定方向</strong>传播）：微波通信频率较高、频段范围宽，因此数据率很高。</p>
<ul>
<li>地面微波接力通信</li>
<li>卫星通信<ul>
<li>优点：通信容量大、距离远、覆盖广、广播通信和多址通信</li>
<li>缺点：传播时延长、受气候影响大、误码率高、成本高</li>
</ul>
</li>
</ul>
<p><strong>红外线、激光</strong>（信号<strong>固定方向</strong>传播）：把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再在空间中传播。</p>
<h1 id="六、物理层设备"><a href="#六、物理层设备" class="headerlink" title="六、物理层设备"></a>六、物理层设备</h1><h2 id="6-1-中继器"><a href="#6-1-中继器" class="headerlink" title="6.1. 中继器"></a>6.1. 中继器</h2><p>诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将会造成信号失真，因此会导致接受错误。</p>
<p>中继器的功能：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度</p>
<p><strong>中继器的两端：</strong></p>
<ul>
<li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</li>
<li>中继器只将任何电缆端上的数据发送到另一段电缆上，它仅作用于信号的电气部分，不并管数据中是否有错误数据或不适于网段的数据。</li>
<li>两端可连相同媒体，也可连不同媒体。</li>
<li>中继器两端的网段一定要是同一个协议。</li>
</ul>
<p><strong>5-4-3规则：</strong> 网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</p>
<h2 id="6-2-集线器（多口中继器）"><a href="#6-2-集线器（多口中继器）" class="headerlink" title="6.2. 集线器（多口中继器）"></a>6.2. 集线器（多口中继器）</h2><p><strong>集线器的功能</strong>：对信号进行再生<strong>放大转发</strong> ，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2.矩阵</title>
    <url>/2021/06/18/2.%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>如果A和B都是m$\times$n矩阵，称A和B是 <strong>同型矩阵</strong></p>
<h2 id="几类特殊的矩阵"><a href="#几类特殊的矩阵" class="headerlink" title="几类特殊的矩阵"></a>几类特殊的矩阵</h2><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>$<br>\quad\begin{pmatrix}<br>    {\large a}_{11}    \\<br>     &amp; {\large a}_{22}\\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; {\large a}_{nn}<br>\end{pmatrix}^{\large n}<br>$</p>
<p>$=<br>\begin{pmatrix}<br>    {\large a}_{11}^n    \\<br>     &amp; {\large a}_{22}^n\\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; {\large a}_{nn}^n<br>\end{pmatrix}<br>$<br><br><br><br>$<br>\qquad\begin{pmatrix}<br>    {\large k}    \\<br>     &amp; {\large k}\\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; {\large k}<br>\end{pmatrix}$</p>
<p>$=\large k<br>\begin{pmatrix}<br>    1    \\<br>     &amp; 1 \\<br>     &amp;     &amp; \ddots \\<br>     &amp;     &amp;     &amp; 1<br>\end{pmatrix}<br>$</p>
<h3 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h3><blockquote>
<p>单位矩阵经 <strong>一次初等变换</strong> 所得到的矩阵</p>
</blockquote>
<p>可以是行变换,也可以是列变换</p>
<p>左乘是行变换，右乘是列变换</p>
<ol>
<li>互换两行两列的位置：<br>$E(i,j)$表示交换第$i$行(列)和第$j$行(列)<br><br></li>
<li>以数$k\neq0$乘某行或某列：<br>$E(i(k))$表示第$i$行(列)乘$k$<br><br></li>
<li>以数$k$乘某行(列)加到另一行(列)上去：<br>$E(i,j(k))$表示$j$行(列)乘$k$加到$i$行(列)</li>
</ol>
<p><strong>等价矩阵：</strong></p>
<blockquote>
<p>矩阵A经过有限次初等变换变成矩阵B，记作A$\cong$B</p>
</blockquote>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><blockquote>
<p>满足$A^T=A$</p>
</blockquote>
<h3 id="反对称矩阵"><a href="#反对称矩阵" class="headerlink" title="反对称矩阵"></a>反对称矩阵</h3><blockquote>
<p>满足$A^T=-A$</p>
</blockquote>
<h3 id="幂零矩阵"><a href="#幂零矩阵" class="headerlink" title="幂零矩阵"></a>幂零矩阵</h3><blockquote>
<p>对方阵$A$,如果存在正整数m，使得$A^m=0$,则称$A$为幂零矩阵</p>
</blockquote>
<h3 id="幂等矩阵"><a href="#幂等矩阵" class="headerlink" title="幂等矩阵"></a>幂等矩阵</h3><blockquote>
<p>满足$A^2=A$</p>
</blockquote>
<h3 id="对合矩阵"><a href="#对合矩阵" class="headerlink" title="对合矩阵"></a>对合矩阵</h3><blockquote>
<p>满足$A^2=E$</p>
</blockquote>
<h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><p>令$A=[{\large a}_{ij}]_{m\times s},B=[{\large b}_{ij}]_{s\times n}$<br><br>$AB=C=[{\large c}_{ij}]_{m\times n}$<br><br>${\large c}_{ij}={\large\sum\limits_{k=1}^s}{\large a}_{ik}{\large b}_{kj}$</p>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊:"></a>特殊:</h3><p>$\quad A=[{\large a}_{1j}]_{1\times s}$</p>
<p>$\quad A^T=[{\large a}_{j1}]_{s\times1}$</p>
<p>$\quad 则\;AA^T=\sum\limits_{j=1}^n{\large a}_j^2$</p>
<p>$\therefore\;$<strong>行在前列在后就是一个数</strong></p>
<h2 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h2><blockquote>
<p>$AB=BA=I$</p>
<ul>
<li>$<br>A=<br>\begin{pmatrix}<br>  {\large a}_{11}\\<br>  \\<br>   &amp; {\large a}_{22}\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp; {\large a}_{nn}<br>\end{pmatrix}<br>$<br>$<br>B=<br>\begin{pmatrix}<br>   \displaystyle\frac{1}{ {\large a}_{11} }\\<br>   &amp; \displaystyle\frac{1}{ {\large a}_{22} }\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp;\displaystyle\frac{1}{ {\large a}_{nn} }<br>\end{pmatrix}<br>$<br><br><br>$<br>\because<br>\begin{pmatrix}<br>  {\large a}_{11}\\<br>  \\<br>   &amp; {\large a}_{22}\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp; {\large a}_{nn}<br>\end{pmatrix}<br>\begin{pmatrix}<br>  {\large b}_{11}\\<br>  \\<br>   &amp; {\large b}_{22}\\<br>   &amp;     &amp; \ddots \\<br>   &amp;     &amp;     &amp; {\large b}_{nn}<br>\end{pmatrix}<br>$<br><br><br>$<br>=\begin{pmatrix}<br>  {\large a}_{11}{\large b}_{11} \\<br>  \\<br>   &amp; {\large a}_{22}{\large b}_{22}\\<br>   \\<br>   &amp;     &amp; \ddots\\<br>   \\<br>   &amp;     &amp;     &amp; {\large a}_{nn}{\large b}_{nn}<br>\end{pmatrix}<br>$</li>
</ul>
</blockquote>
<p>$\therefore AB=BA=I$<br><br>$\therefore A^{-1}=B$<br><br>一些可逆矩阵的证明要想到从定义的角度出发</p>
<hr>
<p>$AA^{ * } =A^{ * }A=|A|I$</p>
<p>推论：</p>
<ol>
<li>$A^{-1}=\displaystyle{ \frac{A^*}{|A|} }\longrightarrow即\;|A|\not=0,\;A^{-1}存在$</li>
</ol>
<p>$\therefore$求逆矩阵先 <strong>看行列式是否为零</strong></p>
<ol>
<li>伴随矩阵$A^{ * }$的一些常用结论 <ul>
<li>$|A^*|=|A|^{n-1}$</li>
<li>$(A^{ * })^{ * }=|A|^{n-2}A$</li>
<li>若$A$可逆，且$A^{ * }$可逆,$(A^{ * })^{-1}=(A^{-1})^{ * }=\displaystyle\frac{1}{|A|}A$</li>
<li>$(AB)^{ * }=B^{ * }A^{ * }$</li>
<li>$(A^{ * })^T=(A^T)^{ * }$</li>
</ul>
</li>
<li><strong>A如果可逆，那么A一定可以表示为有限个初等矩阵的乘积</strong></li>
</ol>
<p>$P_t\cdots P_2P_1A=I$</p>
<p><br></p>
<p>$\because P_t\cdots P_2P_1A=I$</p>
<p>$\therefore A^{-1}=P_t\cdots P_2\;P_1$</p>
<p>$\;P_t\cdots P_2\;P_1\;I=A^{-1}$<br><br><br>$P_t\cdots P_2\;P_1\;A=I$<br><br>$P_t\cdots P_2\;P_1\;I=A^{-1}$</p>
<p>由这两个式子可得：</p>
<p>A经过行初等变换变成$I$</p>
<p>$I$就经过同样的行初等变换变成$A^{-1}$</p>
<p>$<br>\therefore[A\;|\;I\,]\rightarrow\cdots\rightarrow[\,I\;|\;A^{-1}]<br>$<br><br>或者可以这么理解<br>$A^{-1}[A|I]=[I|A^{-1}]$<br><br>用分块矩阵的思想，这样理解更加直观,其实这样求解的原因<br>就是$A$和$I$可以经过相同的变换变成$I$和$A^{-1}$</p>
<p><strong>推广</strong></p>
<p>$AX=B$<br>如果A可逆，$X=A^{-1}B$</p>
<p>令$P=A^{-1}$</p>
<p>由</p>
<p>$\;PA=I$<br><br>$PB=X$</p>
<p>有$\;[A|B]=[I|X]$</p>
<p>即$\;$遇到$A^{-1}B$时，可以将$A，B$拼在一起将$A$化成单位矩阵就是所求的$X$</p>
<h2 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h2><h3 id="分成四块"><a href="#分成四块" class="headerlink" title="分成四块"></a>分成四块</h3><p>$<br>\left(\begin{array}{cc|ccc}<br>     1 &amp; 2 &amp; 0 &amp; 0 &amp; 0\\<br>     3 &amp; 4 &amp; 0 &amp; 0 &amp; 0\\<br>     \hline<br>     0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\<br>     0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\<br>     0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\<br>\end{array}\right)=<br>\left(\begin{array}{cc}<br>     A &amp; O\\<br>     O &amp; B<br>\end{array}\right)<br>$</p>
<p>分块后的矩阵满足四个区域整体满足</p>
<p>矩阵的加法</p>
<p>对角矩阵的乘法</p>
<p>逆矩阵</p>
<h3 id="按行分块"><a href="#按行分块" class="headerlink" title="按行分块"></a>按行分块</h3><ul>
<li>$<br>\left(\begin{array}{ccc}<br>a_{11}&amp;a_{12}&amp;a_{13}\\<br>\hdashline<br>a_{21}&amp;a_{22}&amp;a_{23}\\<br>\hdashline<br>a_{31}&amp;a_{32}&amp;a_{33}<br>\end{array}\right)<br>=\begin{bmatrix}<br>\alpha_1^T\\<br>\alpha_2^T\\<br>\alpha_3^T<br>\end{bmatrix}<br>$<br><br>按行分块一般会加转置符号，主要原因时默认$\alpha$是列向量<h3 id="按列分块"><a href="#按列分块" class="headerlink" title="按列分块"></a>按列分块</h3>类比按行分块<br><br>一般证明的时候会选择按列分块</li>
</ul>
<h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><blockquote>
<p>秩与线性方程组的解有着密切的联系，所以要将线性方程组和秩结合起来，<br>而这样就容易理解后面的n元向量的一些秩的表示形式</p>
</blockquote>
<ul>
<li>矩阵A的一个k阶子式:<br><br>$\qquad$矩阵A中随便找k行随便找k列，按原来次序排列构成的行列式</li>
</ul>
<h3 id="秩的性质"><a href="#秩的性质" class="headerlink" title="秩的性质"></a>秩的性质</h3><ol>
<li>$0\leqslant r(A_{m\times n})\leqslant min(m,n)$<br><br><br></li>
<li>$r(A^T)=r(A)$<br><br><br></li>
<li>$r(A+B)\leqslant r(A)+r(B)$<br><br><br></li>
<li>$r(kA)=r(A)(k\neq0)\;\leftarrow\; r(A)=r(-A)，r(A-E)=r(E-A)$<br><br><br></li>
<li><p>$r(AB)\leqslant min(r(A),r(B))$<br><br><br></p>
</li>
<li><p>如P.Q可逆，则<br>$r(PAQ)=r(A)$<br><br><br></p>
</li>
<li>$\;r\left[\begin{array}{cc} A&amp;O\\O&amp;B\end{array}\right]=r(A)+r(B)$<br><br><br></li>
<li>$max(r(A),r(B))\leqslant r(A，B)\leqslant r(A+B)\leqslant r(A)+r(B)$<br><br>$r(A+B)\leqslant r(A)+r(B)$的证明(三秩相等)<br><br>$<br>\begin{aligned}<br>&amp;设r(A)=r,极大线性无关组：\alpha_{i1}\alpha_{i2}\cdots\alpha_{ir}\\<br>&amp;\quad r(B)=t,极大线性无关组：\beta_{j1}\beta_{j2}\cdots\beta_{jt}\\<br>&amp;A+B=(\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n)\\<br>\end{aligned}<br>$<br><br><br>$<br>\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n可由\alpha_{i1},\cdots,\alpha_{ir},\beta_{j1},\cdots,\beta_{jt}线性表示$<br><br>$则r(\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n)\leqslant r(\alpha_{i1},\cdots,\alpha_{ir},\beta_{j1},\cdots,\beta_{jt})\rightarrow在向量组线性表示里$<br><br><br>$<br>\begin{aligned}<br>\therefore r(A+B)&amp;=r(\alpha_1+\beta_1,\alpha_2+\beta_2,\cdots,\alpha_n+\beta_n)\\<br>\\<br>&amp;\leqslant r(\alpha_{i1},\cdots,\alpha_{ir},\beta_{j1},\cdots,\beta_{jt})\leqslant r+t=r(A)+r(B)<br>\end{aligned}<br>$</li>
</ol>
<p>当然理解起来很好理解，因为假设r(A)=m,r(B)=n,r(A+B)的秩必定小于m+n</p>
<h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><p>前提$AB=BA$,<br>那么$(A+B)^n=\sum\limits_{i=0}^nC_n^iA^iB^{n-i}$</p>
<p>矩阵跟线性变换有着紧密的联系，左乘对应行变换，右乘对应列变换，而后面会继续深入学习矩阵的几何意义……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>3.CSS的背景</title>
    <url>/2021/07/20/3-CSS%E7%9A%84%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS-的背景"><a href="#CSS-的背景" class="headerlink" title="CSS 的背景"></a>CSS 的背景</h1><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><p><strong>background-color</strong> 属性定义了元素的背景颜色<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: 颜色值;</span><br></pre></td></tr></table></figure><br>一般情况下元素背景颜色默认值是 <strong>transparent(透明)</strong>，我们也可以手动指定背景颜色为透明色。</p>
<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p><strong>background-image</strong> 属性描述了元素的背景图像，实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片，优点是便于控制位置<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">绝对或相对位置</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h2><p>如果需要在HTML页面上对背景图像进行平铺，可以使用 <strong>background-repeat</strong> 属性<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-repeat</span>: repeat | no-repeat | repeat-x | repeat-y </span><br></pre></td></tr></table></figure></p>
<h2 id="背景图片位置"><a href="#背景图片位置" class="headerlink" title="背景图片位置"></a>背景图片位置</h2><p>利用 <strong>bcakground-positon</strong> 属性可以改变图片在背景中的位置。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: x y;</span><br></pre></td></tr></table></figure><br>参数代表的意思是：x坐标和y坐标，可以使用方位名词或者精确单位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:left">百分数 / 由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">方位名词：<br>top / center / bottom <br>left / center / right </td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.参数是方位名词</strong></p>
<ul>
<li>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top和top left 效果一样</li>
<li>如果指定了一个方位名词，另一个省略，则第二个值<strong>默认居中对齐</strong></li>
</ul>
<p><strong>2.参数是精确单位</strong></p>
<ul>
<li>如果参数值是精确坐标，那么第一个肯定是x坐标，第二个肯定是y坐标</li>
<li>如果只指定一个数值，那该数值一定是x坐标，另一个<strong>默认垂直居中</strong></li>
</ul>
<p><strong>3.参数是混合单位</strong></p>
<ul>
<li>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
<h2 id="背景图像固定（背景附着）"><a href="#背景图像固定（背景附着）" class="headerlink" title="背景图像固定（背景附着）"></a>背景图像固定（背景附着）</h2><p><strong>background-attachment</strong> 属性设置背景图像是否固定或者随着页面的其余部分滚动。</p>
<p>background-attachment后期可以制作时差滚动效果<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-attachment</span>: <span class="built_in">fixed</span>(固定) | <span class="built_in">scroll</span>(滚动) </span><br></pre></td></tr></table></figure></p>
<h2 id="背景复合写法"><a href="#背景复合写法" class="headerlink" title="背景复合写法"></a>背景复合写法</h2><p>我们可以将这些属性合并写在同一个属性background中，<strong>约定的顺序</strong>为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;</span><br></pre></td></tr></table></figure>
<h2 id="背景色半透明"><a href="#背景色半透明" class="headerlink" title="背景色半透明"></a>背景色半透明</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>rgba也就是red、green、blue、alpha</strong></p>
<ul>
<li>最后一个参数是 <strong>alpha</strong> 透明度，取值范围0~1之间</li>
<li><strong>习惯上把0.3的0省略</strong>，写为background: rgba(0,0,0,.3);</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">background-color</td>
<td style="text-align:left">背景颜色</td>
<td style="text-align:left">预定义颜色值、十六进制、RGB代码</td>
</tr>
<tr>
<td style="text-align:left">background-image</td>
<td style="text-align:left">背景图片</td>
<td style="text-align:left">url(图片路径)</td>
</tr>
<tr>
<td style="text-align:left">background-repeat</td>
<td style="text-align:left">是否平铺</td>
<td style="text-align:left">repeat / no-repeat / repeat-x / repeat-y</td>
</tr>
<tr>
<td style="text-align:left">background-position</td>
<td style="text-align:left">背景位置</td>
<td style="text-align:left">length / positon 分别是x和y坐标</td>
</tr>
<tr>
<td style="text-align:left">background-attachment</td>
<td style="text-align:left">背景附着</td>
<td style="text-align:left">scroll(滚动) / fixed(固定)</td>
</tr>
<tr>
<td style="text-align:left">背景简写</td>
<td style="text-align:left">减少代码量</td>
<td style="text-align:left"><strong>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</strong></td>
</tr>
<tr>
<td style="text-align:left">背景色半透明</td>
<td style="text-align:left">背景颜色半透明</td>
<td style="text-align:left">background:rgba(0,0,0,.3); 后面<strong>必须是4个值</strong></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>3.numpy的数据类型</title>
    <url>/2021/07/03/3-numpy%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><strong>因为在numpy中有许多的数据类型，所以今天就来着重梳理一下numpy中的数据类型及其应用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="numpy的数据类型和C的对比"><a href="#numpy的数据类型和C的对比" class="headerlink" title="numpy的数据类型和C的对比"></a>numpy的数据类型和C的对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">numpy的类型</th>
<th style="text-align:left">C的类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">np.bool</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">布尔值(True or False)</td>
</tr>
<tr>
<td style="text-align:left">np.byte</td>
<td style="text-align:left">signed char</td>
<td style="text-align:left">精度平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.ubyte</td>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.short</td>
<td style="text-align:left">short</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.ushort</td>
<td style="text-align:left">unsigned short</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.intc</td>
<td style="text-align:left">int</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.uintc</td>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.int_</td>
<td style="text-align:left">long</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.unint</td>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.longlong</td>
<td style="text-align:left">longlong</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.ulonglong</td>
<td style="text-align:left">unsigned longlong</td>
<td style="text-align:left">平台定义</td>
</tr>
<tr>
<td style="text-align:left">np.half / np.float16</td>
<td style="text-align:left"></td>
<td style="text-align:left">半精度浮点数：符号位，5位指数，10位尾数</td>
</tr>
<tr>
<td style="text-align:left">np.single</td>
<td style="text-align:left">float</td>
<td style="text-align:left">平台定义的单精度浮点数：通常为1位符号位，8位指数，23位尾数</td>
</tr>
<tr>
<td style="text-align:left">np.double</td>
<td style="text-align:left">double</td>
<td style="text-align:left">平台定义的双精度浮点数：通常为符1位号位，11位指数，52位尾数</td>
</tr>
<tr>
<td style="text-align:left">np.longdouble</td>
<td style="text-align:left">long double</td>
<td style="text-align:left">平台定义的扩展精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">np.csingle</td>
<td style="text-align:left">float complex</td>
<td style="text-align:left">复数，由两个单精度浮点数（实部和虚部）表示</td>
</tr>
<tr>
<td style="text-align:left">np.cdouble</td>
<td style="text-align:left">double complex</td>
<td style="text-align:left">复数，由两个双精度浮点数（实部和虚部）表示</td>
</tr>
<tr>
<td style="text-align:left">np.clongdouble</td>
<td style="text-align:left">long double complex</td>
<td style="text-align:left">复数，由两个扩展精度浮点数（实部和虚部）表示</td>
</tr>
</tbody>
</table>
</div>
<h2 id="numpy中的一组固定大小的别名"><a href="#numpy中的一组固定大小的别名" class="headerlink" title="numpy中的一组固定大小的别名"></a>numpy中的一组固定大小的别名</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">numpy类型</th>
<th style="text-align:left">C的类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">np.int8</td>
<td style="text-align:left">int8_t</td>
<td style="text-align:left">字节(-128—127)</td>
</tr>
<tr>
<td style="text-align:left">np.int16</td>
<td style="text-align:left">int16_t</td>
<td style="text-align:left">整数(-32768—32767)</td>
</tr>
<tr>
<td style="text-align:left">np.int64</td>
<td style="text-align:left">int64_t</td>
<td style="text-align:left">整数($-2^{63}—2^{63}-1$)</td>
</tr>
<tr>
<td style="text-align:left">np.uint8</td>
<td style="text-align:left">uint8_t</td>
<td style="text-align:left">无符号整数(0—255)</td>
</tr>
<tr>
<td style="text-align:left">np.uint16</td>
<td style="text-align:left">uint16_t</td>
<td style="text-align:left">无符号整数(0—65535)</td>
</tr>
<tr>
<td style="text-align:left">np.uint32</td>
<td style="text-align:left">uint32</td>
<td style="text-align:left">无符号整数(0—$2^{32}$)</td>
</tr>
<tr>
<td style="text-align:left">np.uint64</td>
<td style="text-align:left">uint64</td>
<td style="text-align:left">无符号整数(0—$2^{64}$)</td>
</tr>
<tr>
<td style="text-align:left">np.intp</td>
<td style="text-align:left">intptr_t</td>
<td style="text-align:left">用于索引的整数，通常与索引相同ssize_t</td>
</tr>
<tr>
<td style="text-align:left">np.uintp</td>
<td style="text-align:left">uintptr_t</td>
<td style="text-align:left">整数大到足以容纳指针</td>
</tr>
<tr>
<td style="text-align:left">np.float32</td>
<td style="text-align:left">float</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">np.float64/np.float_</td>
<td style="text-align:left">double</td>
<td style="text-align:left">这与内置python float的精度相匹配</td>
</tr>
<tr>
<td style="text-align:left">np.complex64</td>
<td style="text-align:left">float complex</td>
<td style="text-align:left">复数,由两个32位浮点数(实数和虚数)表示</td>
</tr>
<tr>
<td style="text-align:left">np.complex128/np.complex_</td>
<td style="text-align:left">double complex</td>
<td style="text-align:left">注意，这与内置python复合体的精度相匹配</td>
</tr>
</tbody>
</table>
</div>
<p>numpy数据类型是dtype(数据类型)对象的实例</p>
<h2 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.power(<span class="number">100</span>,<span class="number">8</span>,dtype=np.int64)</span><br></pre></td></tr></table></figure>
<pre><code>10000000000000000
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.power(<span class="number">100</span>,<span class="number">8</span>,dtype=np.int32)<span class="comment">#应该输出的是10000000000000000</span></span><br></pre></td></tr></table></figure>
<pre><code>1874919424
</code></pre><h2 id="np-iinfo和np-finfo"><a href="#np-iinfo和np-finfo" class="headerlink" title="np.iinfo和np.finfo"></a>np.iinfo和np.finfo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.iinfo(np.int32)</span><br></pre></td></tr></table></figure>
<pre><code>iinfo(min=-2147483648, max=2147483647, dtype=int32)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.finfo(np.float_)</span><br></pre></td></tr></table></figure>
<pre><code>finfo(resolution=1e-15, min=-1.7976931348623157e+308, max=1.7976931348623157e+308, dtype=float64)
</code></pre>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>3.树和森林</title>
    <url>/2021/07/28/3-%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树是n（n&geqslant;0）个结点的有限集.</p>
<ul>
<li>n=0，空树</li>
<li>n&gt;0，则满足以下条件<ul>
<li><strong>有且仅有一个</strong> 特定的称为 <strong>根</strong> 的结点</li>
<li>其余节点可分为m（m&geqslant;0）个互不相交的有限集T1，T2，T3……，Tm，其中每一个集合本身又是一棵树，并称为根的 <strong>子树</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p><strong>根节点</strong>：非空树中无前驱结点的结点</p>
<p><strong>结点的度</strong>：结点拥有的子树数</p>
<p><strong>树的度</strong>：树内各结点的度的最大值</p>
<p><strong>度=0</strong> —&gt; 称为 <strong>叶子结点</strong>（终端结点）</p>
<p><strong>度≠0</strong> —&gt; 称为 <strong>分支结点</strong>（非终端节点）</p>
<p>根节点以外的分支结点称为 <strong>内部节点</strong></p>
<p>结点的子树的根称为该结点的 <strong>孩子</strong>，该结点称为孩子的 <strong>双亲</strong></p>
<p><strong>兄弟</strong>：深度相同，双亲结点相同</p>
<p><strong>堂兄弟</strong>：深度相同，双亲结点不同</p>
<p>结点的 <strong>祖先</strong>：从根到该结点所经分支上的所有结点</p>
<p>结点的 <strong>子孙</strong>：以某结点为根的子树中的任一结点</p>
<p><strong>树的深度</strong>：树中结点的最大层次</p>
<p><strong>有序树</strong>：树中结点的各子树从左至右有次序</p>
<p><strong>无序树</strong>：树中结点的各子树无次序</p>
<p><strong>森林</strong>：是m（m&geqslant;0）棵互不相交的树的集合</p>
<h1 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>二叉树是n（n&geqslant;0）个结点的有限集.或是空集，或是一个根节点和两棵不相交的分别称作这个根的左子树和右子树的二叉树组成</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>每个结点最多有两个孩子（二叉树中不存在度大于2的结点）</li>
<li>子树有左右之分，其次序不能颠倒</li>
<li>二叉树可以是空集合，根可以有空的左子树或空的右子树</li>
</ol>
<p><strong>注意</strong>：二叉树 <strong>不是</strong> 树的特殊情况，它们是两个概念</p>
<p><strong>二叉树</strong> 结点的子树要 <strong>区分左子树和右子树</strong>，即使只有一棵子树也要区分，说明它是左子树，还是右子树</p>
<p><strong>树</strong> 当节点只有一个孩子时，就 <strong>无需区分</strong> 它是左还是右的次序，因此二者是不同的。这是二叉树与树的最主要差别</p>
<h2 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT BinaryTree&#123;</span><br><span class="line">    数据对象D:  D是具有相同特性的数据元素的集合。</span><br><span class="line">    数据关系R:  若D=Φ,则R=Φ;</span><br><span class="line">                若D≠Φ,则R=&#123;H&#125;;H是如下二元关系:</span><br><span class="line">                <span class="number">1.</span>root唯一      <span class="comment">//关于根的说明</span></span><br><span class="line">                <span class="number">2.</span>D_j∩D_k=Φ     <span class="comment">//关于子树不相交的说明</span></span><br><span class="line">                <span class="number">3.</span>……            <span class="comment">//关于数据元素的说明</span></span><br><span class="line">                <span class="number">4.</span>……            <span class="comment">//关于左子树和右子树的说明</span></span><br><span class="line">    基本操作P</span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><blockquote>
<p>所有的结点都在，即深度为k且右 $2^k-1$ 个结点的二叉树称为满二叉树</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的 <strong>满二叉树</strong> 中 <strong>编号</strong> 为1~n的结点 <strong>一一对应</strong> 时，称之为完全二叉树。</p>
</blockquote>
<p><strong>注：</strong> 满二叉树中，最后一个结点开始，<strong>连续</strong> 去掉 <strong>任意</strong> 个结点，即是一棵完全二叉树</p>
<p><strong>满二叉树一定是完全二叉树</strong></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.具有n个节点的完全二叉树深度为 $\lfloor \log_2n \rfloor +1$</p>
<p>注：$\lfloor x \rfloor$：称作x的底，表示不大于x的最大整数</p>
<p>2.如果对对一棵有n个结点的完全二叉树，结点按层序编号，则对 <strong>任一结点i</strong>(i&leqslant;i&leqslant;n),有：</p>
<ul>
<li>如果i = 1，则结点i是二叉树的根，无双亲；如果 i&gt;1 ，则其双亲是 <strong>结点 $\lfloor i/2 \rfloor$</strong></li>
<li>如果2i &gt; n，则结点i为叶子结点，无左孩子；否则，其 <strong>左孩子是结点 2i</strong></li>
<li>如果2i+1 &gt; n，则结点i无右孩子；否则，其 <strong>右孩子是结点 2i+1</strong> </li>
</ul>
<h2 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h2><p>实现：按 <strong>满二叉树</strong> 的结点层次编号，依次存放二叉树中的数据元素<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTSIZE 100</span></span><br><span class="line">Typedef TElemTye SqBiTree[MAXTSIZE]</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>:<br>会浪费空间，所以适合 <strong>满二叉树</strong> 和 <strong>完全二叉树</strong></p>
<h2 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h2><p><strong>二叉链表</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<p>n个结点的二叉链表中有，<strong>n+1</strong> 个空指针域</p>
<ul>
<li>因为每个非空指针域都存放着一个结点</li>
</ul>
<p><strong>三叉链表</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>&#123;</span></span><br><span class="line">    TelemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>*<span class="title">parent</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="comment">//比二叉节点多了一个双亲指针</span></span><br><span class="line">&#125;TriTNode,*TriTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p><strong>方法</strong><br>假设：L：遍历左子树，D：访问根结点，R：遍历右子树</p>
<p>遍历方案共有六种：DLR、LDR、LRD、DRL、RLD</p>
<p>若规定 <strong>先左后右</strong>，则只有前三种情况：</p>
<ul>
<li><strong>DLR</strong>——先序（根）遍历</li>
<li><strong>LDR</strong>——中序（根）遍历</li>
<li><strong>LRD</strong>——后序（根）遍历</li>
</ul>
<p><strong>先序遍历递归算法</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre</span><span class="params">(BiTree *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;data);</span><br><span class="line">        pre(T-&gt;lchild);</span><br><span class="line">        pre(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>中序遍历非递归算法</strong><br>算法设计思路：使用栈<br><strong>二叉树的层次遍历</strong><br>算法设计思路：使用一个队列</p>
<ul>
<li>将根节点进队;</li>
<li>队不空时循环：从队列中出列一个结点*p，访问它；<ul>
<li>若它有左孩子结点，将左孩子结点进队；</li>
<li>若它有右孩子结点，将右孩子结点进队。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">    BTNode *p; SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(qu,b);<span class="comment">//根结点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu))&#123;<span class="comment">//队不为空，则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出队结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//访问结点p</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">            enQueue(qu,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">            enQueue(qu,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h2><ul>
<li>若二叉树中各结点的值均不相同，则二叉树的结点的先序序列，中序序列，后序序列都是唯一的</li>
<li>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树</li>
</ul>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><p>C语言描述<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTree,*pBiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">pBiTree <span class="title">Create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(pBiTree )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pBiTree p=<span class="literal">NULL</span>;</span><br><span class="line">	p=Create();</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建成功\n&quot;</span>);</span><br><span class="line">	traverse(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;遍历成功\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pBiTree <span class="title">Create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	pBiTree T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		T=(pBiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">		T-&gt;data = ch;</span><br><span class="line">		T-&gt;lchild=Create();<span class="comment">//递归</span></span><br><span class="line">		T-&gt;rchild=Create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(pBiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,T-&gt;data);</span><br><span class="line">		traverse(T-&gt;lchild);</span><br><span class="line">		traverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线索二叉树-Threaded-Binary-Tree"><a href="#线索二叉树-Threaded-Binary-Tree" class="headerlink" title="线索二叉树(Threaded Binary Tree)"></a>线索二叉树(Threaded Binary Tree)</h2><p>问题：如何寻找特定遍历序列中二叉树结点的前驱和后继</p>
<p>解决方法：</p>
<ol>
<li>通过遍历寻找—-费时间</li>
<li>再增设前驱、后继指针域—-增加存储负担</li>
<li><p><strong>利用二叉链表中的空指针域</strong></p>
<ul>
<li>如果某个结点的左孩子为空，则将空的左孩子指针域改为 <strong>指向其前驱</strong>；如果某结点的右孩子为空，则将空的右孩子指针域改为 <strong>指向其后继</strong>——这种改变指向的指针称为“线索”</li>
</ul>
<p>为区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：</p>
<ul>
<li>l(r)tag = 0 l(r)child指向该结点的左（右）孩子</li>
<li>l(r)tag = 1 l(r)child指向该结点的前驱（后继）</li>
</ul>
<p><strong>增设了一个头结点</strong>以中序遍历为例）：</p>
<ul>
<li>ltag=0,lchild指向根结点，</li>
<li>rtag=1,rchild指向遍历序列中最后一个结点</li>
<li>遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点</li>
</ul>
</li>
</ol>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>实现：</p>
<ul>
<li>定义结构数组存放树的结点，每个结点含两个域<ul>
<li>数据域：存放结点本身信息</li>
<li>双亲域：指示本结点的双亲结点在数组中的位置</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//树的结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r,n;    <span class="comment">//根结点位置和结点个数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure>
<h2 id="双亲表示法-1"><a href="#双亲表示法-1" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储</p>
<p><strong>特点</strong><br>找孩子容易，找双亲难</p>
<p><strong>孩子结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*childPtr;</span><br></pre></td></tr></table></figure></p>
<p><strong>双亲结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CTbox;</span><br></pre></td></tr></table></figure></p>
<p><strong>树结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;    <span class="comment">//结点数和根结点的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉链表表示法"><a href="#二叉链表表示法" class="headerlink" title="二叉链表表示法"></a>二叉链表表示法</h2><p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其 <strong>第一个孩子结点</strong> 和 <strong>下一个兄弟结点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<h1 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h1><ul>
<li>将树转换成二叉树进行处理，利用二叉树的算法实现对数的操作</li>
<li>由于树和二叉树都可以用二叉链表作存储结构，则 <strong>以二叉链表作媒介</strong> 可以导出树与二叉树之间的一个对应关系。</li>
</ul>
<p><strong>口诀：兄弟相连留长子</strong></p>
<h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><blockquote>
<p>森林是m(m&geqslant;0)棵互不相交的树的集合<br>森林—-&gt;树—-&gt;二叉树</p>
</blockquote>
<p>森林变二叉树：树变二叉根相连</p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><p><strong>1.树的遍历方式（三种）</strong></p>
<ul>
<li><strong>先根（次序）遍历</strong>：<ul>
<li>若树不空，则先访问根结点，然后依次先根遍历各课子树</li>
</ul>
</li>
<li><strong>后根（次序）遍历</strong>:<ul>
<li>若树不空，则先依次后根遍历各棵子树，然后访问根结点</li>
</ul>
</li>
<li><strong>按层次遍历</strong>：<ul>
<li>若树不空，则自上而下自左至右访问树中每个结点</li>
</ul>
</li>
</ul>
<p><strong>2.森林的遍历</strong><br>将森林看作由三部分构成：</p>
<ul>
<li>森林中第一棵树的根结点；</li>
<li>森林中第一棵树的子树森林</li>
<li><p>森林中其它树构成的森林</p>
</li>
<li><p><strong>先序遍历</strong></p>
<ul>
<li>若树不空，则</li>
<li><strong>访问森林中第一棵树的根结点</strong></li>
<li>先序遍历森林中第一棵树的子树森林</li>
<li>先序遍历森林中（除第一棵树外）其余树构成的森林<blockquote>
<p>即依次从左至右对森林中的每一棵树进行先根遍历</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>中序遍历</strong></p>
<ul>
<li>若树不空，则</li>
<li>中序遍历森林中第一棵树的子树森林</li>
<li>访问森林中第一棵树的根结点</li>
<li>中序遍历森林中（除第一棵树外）其余树构成的森林<blockquote>
<p>即依次从左到右对森林中的每一棵树进行后根遍历</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.<strong>路径</strong>：从树中一个结点到另一个结点之间的 <strong>分支</strong> 构成这两个结点间的路径</p>
<p>2.<strong>结点的路径长度</strong>：两个结点路径上的 <strong>分支数</strong></p>
<p>3.<strong>树的路径长度</strong>：从 <strong>树根</strong> 到每个结点的 <strong>路径长度之和</strong>。记作：TL</p>
<p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p>
<p>4.<strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权</p>
<p>5.<strong>结点的带权路径长度</strong>：从根结点到该结点之间的 <strong>路径长度</strong> 与该结点的 <strong>权</strong> 的 <strong>乘积</strong></p>
<p>6.<strong>树的带权路径长度</strong>：树中所有 <strong>叶子</strong> 结点的 <strong>带权路径长度之和</strong> 记WPL</p>
<h2 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h2><p><strong>哈夫曼算法</strong></p>
<ul>
<li>构造森林全是根</li>
<li>选用两小造新树</li>
<li>删除两小添新人</li>
<li>重复2、3剩单根</li>
</ul>
<p>哈夫曼树的结点的度数为0或2，没有度为1的结点</p>
<h2 id="哈夫曼树构造算法的实现"><a href="#哈夫曼树构造算法的实现" class="headerlink" title="哈夫曼树构造算法的实现"></a>哈夫曼树构造算法的实现</h2><p>采用顺序存储结构—-一维结构数组<br>节点类型定义<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent,lch,rch;</span><br><span class="line">&#125;HTNode,*HuffmanTree;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>初始化 <strong>HT[1……2n-1]</strong>; lch=rch=parent=0;</li>
<li>输入初始 <strong>n个叶子结点</strong>：置HT[1……n]的weight值;</li>
<li>进行以下 <strong>n-1次合并</strong>，依次产生n-1个结点HT[i],i=n+1……2n:<ul>
<li>在HT[1…i-1]中选两个 <strong>未被选过</strong>（从parent==0中选）的weight最小的两个结点HT[s1]和HT[s2]，s1、s2为两个最小结点下标</li>
<li>修改HT[s1]和HT[s2]的parent值：HT[s1].parent=i;HT[s2].parent=i;</li>
<li>修改产生的HT[i]：<ul>
<li>HT[i].weight=HT[s1].weight + HT[s2].weight;</li>
<li>HT[i].lch=s1;HT[i].rch=s2;</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHuffmanTree</span><span class="params">(HuffmanTree HT,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;    <span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT=<span class="keyword">new</span> HTNode[m+<span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//将2n-1个元素的lch、rch、parent置为0</span></span><br><span class="line">        HT[i].lch=<span class="number">0</span>;HT[i].rch=<span class="number">0</span>;HT[i].parent=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;HT[i]weight;<span class="comment">//输入前n个元素的weight值</span></span><br><span class="line">    <span class="comment">//初始化完成</span></span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//合并产生n-1个结点---构造Huffman树</span></span><br><span class="line">        Select(HT,i<span class="number">-1</span>,s1,s2);<span class="comment">//在HT[k](1 ≤ k ≤ i-1)中选择两个其双亲域为0</span></span><br><span class="line">        <span class="comment">//且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class="line">        HT[s1].parent=i; HT[s2].parent=i;<span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">        HT[i].lch=s1;HT[i].rch=s2;<span class="comment">//s1.s2分别作为i的左右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>标注时左分支为0，右分支为1</p>
<p>哈夫曼编码是前缀码</p>
<p>哈夫曼编码是最优前缀码</p>
<h3 id="哈夫曼编码的算法实现"><a href="#哈夫曼编码的算法实现" class="headerlink" title="哈夫曼编码的算法实现"></a>哈夫曼编码的算法实现</h3><p><strong>编码</strong></p>
<ul>
<li>将字符集C作为叶子节点；</li>
<li>将频率集W作为叶子节点的权值；</li>
<li>使用C和W构造哈夫曼树；</li>
<li>对哈夫曼树的所有分支，左子树分支编码为0，右子树分支编码为1；</li>
</ul>
<p><strong>解码</strong></p>
<ul>
<li>构造哈夫曼树</li>
<li>依次读入二进制码</li>
<li>读入0，则走向左孩子；读入1，则走向右孩子</li>
<li>一旦到达某叶子时，即可译出字符</li>
<li>然后再从根出发继续译码，直到结束</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3.计网第三章</title>
    <url>/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、数据链路层功能概述"><a href="#一、数据链路层功能概述" class="headerlink" title="一、数据链路层功能概述"></a>一、数据链路层功能概述</h1><h2 id="1-1-数据链路层的基本概念"><a href="#1-1-数据链路层的基本概念" class="headerlink" title="1.1. 数据链路层的基本概念"></a>1.1. 数据链路层的基本概念</h2><p><strong>结点：</strong>主机、路由器</p>
<p><strong>链路：</strong>网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p>
<p><strong>数据链路：</strong> 网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成数据链路。</p>
<p><strong>帧：</strong>链路层的协议数据单元，封装网络层数据报。</p>
<p><strong>数据链路层 </strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p>
<span id="more"></span>
<h2 id="1-2-数据链路层功能概述"><a href="#1-2-数据链路层功能概述" class="headerlink" title="1.2. 数据链路层功能概述"></a>1.2. 数据链路层功能概述</h2><p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层的数据可靠地传输到相邻节点的目标机网络层。其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，是指对网络层表现出一条无差错的链路</p>
<p>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p>
<p>功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）。</p>
<p>功能三：组帧</p>
<p>功能四：流量控制</p>
<p>功能五：差错控制（帧错/位错）。</p>
<h1 id="二、封装成帧和透明传输"><a href="#二、封装成帧和透明传输" class="headerlink" title="二、封装成帧和透明传输"></a>二、封装成帧和透明传输</h1><h2 id="2-1-封装成帧"><a href="#2-1-封装成帧" class="headerlink" title="2.1. 封装成帧"></a>2.1. 封装成帧</h2><p><strong>封装成帧 </strong> 就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>
<p>首部和尾部包括许多的控制信息，他们的一个重要作用：<strong>帧定界</strong>（确定帧的界限）。</p>
<p><strong>帧同步：</strong> <strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止</p>
<p><strong>组帧的四种方法</strong>：1.字符计数法，2.字符（节）填充法，3.零比填充法，4.违规编码法。</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/1.png" style="zoom: 67%;"></p>
<h2 id="2-2-透明传输"><a href="#2-2-透明传输" class="headerlink" title="2.2. 透明传输"></a>2.2. 透明传输</h2><p><strong>透明传输</strong>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西.</p>
<p>当所有数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息，这样才能保证数据链路层的传输是透明的</p>
<h3 id="2-2-1-字符计数法"><a href="#2-2-1-字符计数法" class="headerlink" title="2.2.1. 字符计数法"></a>2.2.1. 字符计数法</h3><p>帧首部使用一个计数字段（第一个<strong>字节</strong>，八位）来标明帧内字符数</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/2.png" style="zoom: 67%;"></p>
<p>问题：假如第一个计数字符出现错误，就会导致后面的全部错位</p>
<h3 id="2-2-2-字符填充法"><a href="#2-2-2-字符填充法" class="headerlink" title="2.2.2. 字符填充法"></a>2.2.2. 字符填充法</h3><h3 id="2-2-3-零比特填充法"><a href="#2-2-3-零比特填充法" class="headerlink" title="2.2.3. 零比特填充法"></a>2.2.3. 零比特填充法</h3><p>首部和尾部填充的的标识符一样</p>
<p>5“1”  1“0”</p>
<h3 id="2-2-4-违规编码法"><a href="#2-2-4-违规编码法" class="headerlink" title="2.2.4. 违规编码法"></a>2.2.4. 违规编码法</h3><p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/3.png" style="zoom: 67%;"></p>
<p>可以用 <strong>“高-高”</strong>，<strong>“低-低”</strong>来这样的违规编码来作为定界帧的起始和终止。</p>
<p>由于字节计数法中Count字段的脆弱性（其值若有差错将导致灾难性后果）及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong></p>
<h1 id="三、-差错控制"><a href="#三、-差错控制" class="headerlink" title="三、 差错控制"></a>三、 差错控制</h1><h2 id="3-1-差错从何而来？"><a href="#3-1-差错从何而来？" class="headerlink" title="3.1. 差错从何而来？"></a>3.1. 差错从何而来？</h2><p>概括来说，传输中的差错都是由于噪声引起的。</p>
<p><strong>全局性</strong> ：</p>
<ul>
<li>由于线路本身电气特性所产生的<strong>随机噪声</strong>（热噪声），是信道固有的，随即存在的。 </li>
<li>解决办法：提高信噪比来减少或避免干扰。</li>
</ul>
<p><strong>局部性</strong> ：</p>
<ul>
<li>外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因。</li>
<li>解决办法：通常利用编码技术来解决。</li>
</ul>
<script type="math/tex; mode=display">
\text{差错}
\begin{cases}
\text{位错}\text{【比特位出错，1变成0，0变成1】}\\
\\
\text{帧错}
\begin{cases}
\text{丢失：收到 [1]-[2]}\\
\text{重复：收到 [1]-[2]-[2]-[3]}\\
\text{失序：收到 [1]-[3]-[2]}
\end{cases}\\
\text{[1]-[2]-[3]}
\end{cases}</script><p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/4.png" style="zoom: 67%;"></p>
<h2 id="3-2-数据链路层的差错控制"><a href="#3-2-数据链路层的差错控制" class="headerlink" title="3.2. 数据链路层的差错控制"></a>3.2. 数据链路层的差错控制</h2><script type="math/tex; mode=display">
\text{差错控制（比特错）}
\begin{cases}
\text{检错编码}
\begin{cases}
\text{奇偶校验码}\\
\\
\text{循环冗余码 CRC}
\end{cases}
\\
\\
\text{纠错编码：}\text{海明码}
\end{cases}</script><p><strong>冗余编码</strong></p>
<p>在数据发送之前，先按某种关系<strong>附加</strong>上一定的<strong>冗余位</strong>，构成一个符合某一规则的码字后再发送。当要发送的有效数据发生变化时，相应的冗余位也随之变化，使码字遵从不变的规律。接收端根据收到码字是否符合原规律，从而判断是否出错。</p>
<h2 id="3-3-检错编码"><a href="#3-3-检错编码" class="headerlink" title="3.3. 检错编码"></a>3.3. 检错编码</h2><h3 id="3-3-1-奇偶校验码"><a href="#3-3-1-奇偶校验码" class="headerlink" title="3.3.1. 奇偶校验码"></a>3.3.1. 奇偶校验码</h3><script type="math/tex; mode=display">
\text{奇偶校验码}
\begin{cases}
\text{奇校验码：“1”的个数为奇数}\\
\\
\text{偶校验码：“1”的个数为偶数}
\end{cases}</script><p>例题：</p>
<p>如果一个字符S的ASCLL编码从低到高依次为1100101，采用奇校验，在下述收到的传输后字符中，哪个错误不能检测。D</p>
<p>A.11000011 B.11001010 C.11001100 D.11010011</p>
<p>奇偶校验码特点：</p>
<p>只能检查出<strong>奇数个比特错误</strong>，检错能力为50%</p>
<h3 id="3-3-2-CRC循环冗余码"><a href="#3-3-2-CRC循环冗余码" class="headerlink" title="3.3.2. CRC循环冗余码"></a>3.3.2. CRC循环冗余码</h3><p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/5.png" style="zoom: 67%;"></p>
<p>例：要发送的数据是1101011011，采用CRC校验，生成多项式10011，那么最终发送的数据应该是？</p>
<p>最终发送的数据：要发送的数据+帧校验序列FCS</p>
<p><strong>计算冗余码：</strong></p>
<ul>
<li><strong>加0</strong>：假设生成多项式$G(x)$ 的阶为 r，则加 r 个0</li>
<li><strong>模2除法</strong>：数据加0后<strong>除以多项式，余数</strong>为冗余码/FCS/CRC检验码的比特序列。</li>
</ul>
<p>10011表示成多项式为 </p>
<script type="math/tex; mode=display">
\begin{aligned}
&1·x^4+0·x^3+0·x^2+1·x^1+1·x^0\\
=&x^4+x+1
\end{aligned}</script><p>阶为4</p>
<p>多项式N位，阶为N-1</p>
<h2 id="3-4-纠错编码"><a href="#3-4-纠错编码" class="headerlink" title="3.4. 纠错编码"></a>3.4. 纠错编码</h2><h3 id="3-4-1-海明码"><a href="#3-4-1-海明码" class="headerlink" title="3.4.1. 海明码?"></a>3.4.1. 海明码?</h3><blockquote>
<p>海明码：发现双比特错，纠正单比特错</p>
</blockquote>
<p><strong>工作原理：</strong>牵一发而动全身</p>
<p><strong>工作流程：</strong></p>
<p>确定校验码位数 r $\rightarrow$ 确定校验码和数据的位置 $\rightarrow$ 求出校验码的值 $\rightarrow$ 检错并纠错</p>
<h4 id="确定校验码位数-r"><a href="#确定校验码位数-r" class="headerlink" title="确定校验码位数 r"></a>确定校验码位数 r</h4><p>海明不等式：$2^r\geqslant k+r+1$</p>
<p>$r$ 为冗余信息为，$k$ 为信息位。</p>
<h4 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h4><p>$D=101101$</p>
<p>假设这4位校验码分别为$P_1$ 、$P_2$、$P_3$、$P_4$ ;数据从左到右为 $D_1$、$D_2$、……、$D_6$</p>
<p>$P_i$ 放在 $2^{i-1}$的位置，然后按序用 $D_i$ 把空填满</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据位</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码</td>
<td>$P_1$</td>
<td>$P_2$</td>
<td>$D_1$</td>
<td>$P_3$</td>
<td>$D_2$</td>
<td>$D_3$</td>
<td>$D_4$</td>
<td>$P_4$</td>
<td>$D_5$</td>
<td>$D_6$</td>
</tr>
<tr>
<td>实际值</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>令所有要校验的位异或=0</p>
<h4 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h4><div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>0001</th>
<th>0010</th>
<th>0011</th>
<th>0100</th>
<th>0101</th>
<th>0110</th>
<th>0111</th>
<th>1000</th>
<th>1001</th>
<th>1010</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>代码</td>
<td>$P_1$</td>
<td>$P_2$</td>
<td>$D_1$</td>
<td>$P_3$</td>
<td>$D_2$</td>
<td>$D_3$</td>
<td>$D_4$</td>
<td>$P_4$</td>
<td>$D_5$</td>
<td>$D_6$</td>
</tr>
<tr>
<td>实际值</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<h1 id="四、数据链路层的流量控制"><a href="#四、数据链路层的流量控制" class="headerlink" title="四、数据链路层的流量控制"></a>四、数据链路层的流量控制</h1><p><strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作</p>
<p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</p>
<p><strong>数据链路层</strong>流量控制手段：接收方收不下就不回复确认</p>
<p><strong>传输层</strong>流量控制手段：接收端给发送端一个窗口公告。</p>
<h2 id="4-1-流量控制的方法"><a href="#4-1-流量控制的方法" class="headerlink" title="4.1. 流量控制的方法"></a>4.1. 流量控制的方法</h2><p>可靠传输：发送端发啥，接收端收啥</p>
<p>流量控制：控制发送速率，使接收方有足够的缓冲时间来接收每一个帧</p>
<h3 id="4-1-1-停止-等待协议"><a href="#4-1-1-停止-等待协议" class="headerlink" title="4.1.1. 停止-等待协议"></a>4.1.1. 停止-等待协议</h3><p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后发送下一个帧</p>
<p>发送窗口大小=1，接收窗口=1</p>
<script type="math/tex; mode=display">
\text{滑动窗口解决}
\begin{cases}
\text{流量控制（收不下就不给确认，想发也发不了）}
\\
\\
\text{可靠传输（发送方自动重传）}
\end{cases}</script><h4 id="为什么有停止-等待协议？"><a href="#为什么有停止-等待协议？" class="headerlink" title="为什么有停止-等待协议？"></a>为什么有停止-等待协议？</h4><p>1、 解决丢包问题：除了<strong>比特出差错</strong>，底层信道还会出现丢包问题。</p>
<blockquote>
<p>丢包：物理层线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失。</p>
</blockquote>
<p>2、为了实现流量控制</p>
<h4 id="研究停等协议的前提"><a href="#研究停等协议的前提" class="headerlink" title="研究停等协议的前提"></a>研究停等协议的前提</h4><p>1、为了讨论问题方便，仅考虑一方数据（发送方），一方接收数据（接收方）。（正常是全双工通信）</p>
<p>2、不考虑数据是在那一层上传送的。（只需要了解工作原理和机制）</p>
<p>3、“停止-等待” 就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p>
<h4 id="通知等待协议应用情况"><a href="#通知等待协议应用情况" class="headerlink" title="通知等待协议应用情况"></a>通知等待协议应用情况</h4><p><strong>无差错情况</strong></p>
<blockquote>
<p>每发送1个数据帧就停止并等待，因此用1bit来编号就够。</p>
</blockquote>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/6.png" style="zoom: 67%;"></p>
<p><strong>有差错情况</strong></p>
<ul>
<li><p>数据帧丢失或检测到帧出错</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/7.png" style="zoom: 67%;"></p>
<ul>
<li>发完一个帧后，必须保留它的副本</li>
<li>数据帧和确认帧必须编号</li>
</ul>
</li>
<li><p>ACK丢失</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/8.png" style="zoom: 67%;"></p>
</li>
<li><p>ACK迟到</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/9.png" style="zoom: 67%;"></p>
</li>
</ul>
<h4 id="停等协议性能"><a href="#停等协议性能" class="headerlink" title="停等协议性能"></a>停等协议性能</h4><p>操作简单，但信道利用率太低</p>
<p>信道利用率 $\text{U}=\dfrac{T_D}{T_D+\text{RTT}+T_A}$</p>
<p>$T_D$ 是发送方的发送时延，$T_A$ 是接收方的接受时延</p>
<h3 id="4-1-2-后退N帧协议（GBN）"><a href="#4-1-2-后退N帧协议（GBN）" class="headerlink" title="4.1.2. 后退N帧协议（GBN）"></a>4.1.2. 后退N帧协议（GBN）</h3><p>发送窗口大小&gt;1，接收窗口大小=1</p>
<h4 id="后退N帧协议中的滑动窗口"><a href="#后退N帧协议中的滑动窗口" class="headerlink" title="后退N帧协议中的滑动窗口"></a>后退N帧协议中的滑动窗口</h4><p>发送窗口：发送方维持一组连续的允许发送的帧的序号</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/10.png" style="zoom: 67%;"></p>
<p>接收窗口：接受双方维持一组连续的允许接收帧的序号</p>
<h4 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h4><p><strong>1、上层的调用</strong></p>
<p>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送；如果<strong>窗口已满</strong>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）。</p>
<p><strong>2、收到了一个ACK</strong></p>
<p>GBN协议中，对n号帧的确认采用<strong>累计确认</strong>的方式，表明接收方已经收到n号帧和它之前的全部帧。</p>
<p><strong>3、超时事件</strong></p>
<p>协议的名字为后退N帧/回退N帧，来源于出现丢失或时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p>
<h4 id="GBN接收方要做的事"><a href="#GBN接收方要做的事" class="headerlink" title="GBN接收方要做的事"></a>GBN接收方要做的事</h4><p>如果正确收到n号帧，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p>
<p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum（下一个按序接收的帧序号）。</p>
<h4 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h4><p>若采用n个比特对帧编号，那么发送窗口的尺寸 $W_T$ 应满足：$1\leqslant W_T\leqslant 2^n-1$ 。因为发送尺寸过大，就会使得接收方无法区别新帧和旧帧。</p>
<h4 id="GBN协议重点总结"><a href="#GBN协议重点总结" class="headerlink" title="GBN协议重点总结"></a>GBN协议重点总结</h4><p>1、累计确认（偶尔稍待确认）</p>
<p>2、接收方只按顺序接收帧，不按序就丢弃</p>
<p>3、确认序列号最大的、按序到达的帧</p>
<p>4、发送窗口最大为 $2^n-1$，接收窗口大小为1</p>
<h4 id="GBN协议性能分析"><a href="#GBN协议性能分析" class="headerlink" title="GBN协议性能分析"></a>GBN协议性能分析</h4><p>因连续发送数据帧而提高了信道利用率</p>
<p>在重传时必须<strong>把原来已经正确传送的数据帧重传</strong>，传送效率降低。</p>
<h3 id="4-1-3-选择重传协议（SR）"><a href="#4-1-3-选择重传协议（SR）" class="headerlink" title="4.1.3. 选择重传协议（SR）"></a>4.1.3. 选择重传协议（SR）</h3><p>发送窗口大小&gt;1，接收窗口大小&gt;1</p>
<p>选择重传就是只重传出错的帧</p>
<p>解决办法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p>
<h4 id="选择重传协议的滑动窗口"><a href="#选择重传协议的滑动窗口" class="headerlink" title="选择重传协议的滑动窗口"></a>选择重传协议的滑动窗口</h4><p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/11.png" style="zoom: 67%;"></p>
<h4 id="SR发送方必须响应的三件事"><a href="#SR发送方必须响应的三件事" class="headerlink" title="SR发送方必须响应的三件事"></a>SR发送方必须响应的三件事</h4><p><strong>1、上层的调用</strong></p>
<p>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则就像GBN一样，要么将数据<strong>缓存</strong>，要么<strong>返回给上层</strong>之后再传输</p>
<p><strong>2、收到一个ACK</strong></p>
<p>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</p>
<p><strong>3、超时事件</strong></p>
<p>每个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧。</strong></p>
<h4 id="SR接收方要做的事"><a href="#SR接收方要做的事" class="headerlink" title="SR接收方要做的事"></a>SR接收方要做的事</h4><p><strong>来者不拒（窗口内的帧）</strong></p>
<p>SR接收方将确认一个正确接收的帧而<strong>不管是否按序</strong>。失序的帧将被<strong>缓存</strong>，并返回给发送方一个该帧的确认帧<strong>【收谁确认谁】</strong>，置到所有帧（即序号更小的帧）皆被收到为止，这时才可以将一批批帧按序交付给上层，然后<strong>向前移动滑动窗口</strong></p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/12.png" style="zoom: 67%;"></p>
<p>如果收到了窗口序号外（小于窗口下界）的帧，就返回一个ACK。</p>
<p>其他情况，就忽略该帧。</p>
<h4 id="滑动窗口长度-1"><a href="#滑动窗口长度-1" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h4><p>发送窗口最好等于接收窗口（大了就会溢出，小了没意义）</p>
<p>$W_{Tmax}=W_{Rmax}=2^{n-1}$</p>
<h4 id="SR协议重点总结"><a href="#SR协议重点总结" class="headerlink" title="SR协议重点总结"></a>SR协议重点总结</h4><p>1、对数据帧逐一确认</p>
<p>2、只重传出错帧</p>
<p>3、接收方有缓存</p>
<p>4、$W_{Tmax}=W_{Rmax}=2^{n-1}$</p>
<h1 id="五、介质访问控制（MAC）"><a href="#五、介质访问控制（MAC）" class="headerlink" title="五、介质访问控制（MAC）"></a>五、介质访问控制（MAC）</h1><p>MAC：Multiple Access Control 多路访问控制</p>
<p>亦或是Medium Access Control 介质访问控制</p>
<h2 id="5-1-传输数据使用的两种链路"><a href="#5-1-传输数据使用的两种链路" class="headerlink" title="5.1. 传输数据使用的两种链路"></a>5.1. 传输数据使用的两种链路</h2><p><strong>点对点链路</strong></p>
<ul>
<li>两个相邻节点通过一个链路相连，没有第三者。</li>
<li>应用：PPP协议，常用于<strong>广域网</strong></li>
</ul>
<p><strong>广播式链路</strong></p>
<ul>
<li>所有主机共享通信介质</li>
<li>应用：早期的总线以太网、无线局域网，常用于<strong>局域网</strong></li>
<li>典型的拓扑结构：总线型、星型（逻辑总线型）</li>
</ul>
<h2 id="5-2-介质访问控制"><a href="#5-2-介质访问控制" class="headerlink" title="5.2. 介质访问控制"></a>5.2. 介质访问控制</h2><p><strong>介质访问控制</strong>：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p>
<script type="math/tex; mode=display">
\text{介质访问控制}
\begin{cases}
\;\text{静态划分信道}-{\color{red}\text{信道划分介质访问控制} }
\begin{cases}
\;\text{频分多路复用 FDM}\\
\;\text{时分多路复用 TDM}\\
\;\text{波分多路复用 WDM}\\
\;\text{码分多路复用 CDM}\\
\end{cases}
\\
\\
\;\text{动态分配信道}
\begin{cases}
\;{\color{red}\text{轮询访问介质访问控制} }-\text{令牌传递协议}
\\
\\
\;{\color{red}\text{随机访问介质访问控制} }
\begin{cases}
\;\text{ALOHA 协议}\\
\;\text{CSMA 协议}\\
\;\text{CSMA/CD 协议⭐}\\
\;\text{CSMA/CA 协议⭐}\\
\end{cases}
\end{cases}
\end{cases}</script><h2 id="5-3-信道划分介质访问控制"><a href="#5-3-信道划分介质访问控制" class="headerlink" title="5.3. 信道划分介质访问控制"></a>5.3. 信道划分介质访问控制</h2><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把<strong>时域</strong>或<strong>频域</strong>资源合理地分配给网络上的设备</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/13.png" style="zoom: 67%;"></p>
<h3 id="5-3-1-频分多路复用FDM"><a href="#5-3-1-频分多路复用FDM" class="headerlink" title="5.3.1. 频分多路复用FDM"></a>5.3.1. 频分多路复用FDM</h3><blockquote>
<p>也就是在一条信道上通过不同频率传播</p>
</blockquote>
<p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</strong></p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/14.png" style="zoom: 67%;"></p>
<p><strong>优点：</strong></p>
<ul>
<li>充分利用传输介质带宽，系统<strong>效率较高</strong></li>
<li>由于技术比较成熟，实现也比较<strong>容易。</strong></li>
</ul>
<h3 id="5-3-2-时分多路复用TDM"><a href="#5-3-2-时分多路复用TDM" class="headerlink" title="5.3.2. 时分多路复用TDM"></a>5.3.2. 时分多路复用TDM</h3><p><strong>将时间划分为一段段等长</strong>的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用<strong>固定序号的时隙</strong>，所有用户轮流占用信道</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/15.png" style="zoom: 67%;"></p>
<p><strong>改进版：统计时分复用STDM</strong></p>
<blockquote>
<p>车满发车</p>
</blockquote>
<p>每个STDM帧中的时隙小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的<strong>输入缓存，</strong> 然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。<strong>STDM不是固定分配时隙，而是按需动态分配时隙。</strong></p>
<h4 id="5-3-3-波分多路复用WDM"><a href="#5-3-3-波分多路复用WDM" class="headerlink" title="5.3.3. 波分多路复用WDM"></a>5.3.3. 波分多路复用WDM</h4><p>波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p>
<h3 id="5-3-4-码分多路复用CDM"><a href="#5-3-4-码分多路复用CDM" class="headerlink" title="5.3.4. 码分多路复用CDM"></a>5.3.4. 码分多路复用CDM</h3><p><strong>码分多址（CDMA）</strong>是码分复用的一种方式</p>
<p>1个比特分为多个码片/芯片（chip），每一个站点都被指定一个唯一的m位的芯片序列。</p>
<p>发送1时站点发送芯片序列，发送0时发送芯片序列反码（通常把0写成-1）</p>
<p><strong>如何不打架：多个站点同时发送数据的时候，要求各个站点芯片序列相互正交。</strong>（也就是线性无关）</p>
<p><strong>如何合并：各路数据在信道中被线性相加</strong></p>
<p><strong>如何分离：合并的数据和源站规格化内积。</strong></p>
<h2 id="5-4-随机访问介质访问控制"><a href="#5-4-随机访问介质访问控制" class="headerlink" title="5.4. 随机访问介质访问控制"></a>5.4. 随机访问介质访问控制</h2><p>动态媒体接入控制/多点接入</p>
<ul>
<li>特点：信道并非在用户通信时固定分配给用户。</li>
</ul>
<h3 id="5-4-1-ALOHA-协议"><a href="#5-4-1-ALOHA-协议" class="headerlink" title="5.4.1. ALOHA 协议"></a>5.4.1. ALOHA 协议</h3><p><strong>纯ALOHA协议</strong></p>
<blockquote>
<p>不监听信道，不按时间槽发送，随机重发。<strong>（想发就发）</strong></p>
</blockquote>
<p><strong>冲突检测：</strong>如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。</p>
<p><strong>冲突解决：</strong>超时后第一随机时间再重传。</p>
<p><strong>时隙ALOHA协议</strong></p>
<blockquote>
<p>把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。<strong>（控制想发就发的随意性）</strong></p>
</blockquote>
<p><strong>总结：</strong></p>
<p>1、纯ALOHA比时隙ALOHA吞吐量更低，效率更低。</p>
<p>2、纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</p>
<h3 id="5-4-2-CSMA协议"><a href="#5-4-2-CSMA协议" class="headerlink" title="5.4.2. CSMA协议"></a>5.4.2. CSMA协议</h3><blockquote>
<p>思想：发送帧之前，<strong>监听</strong>信道</p>
</blockquote>
<p>载波监听多路访问协议CSMA（carrier sense multiple access）</p>
<p><strong>CS：</strong>载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>
<blockquote>
<p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站点同时在发送数据，表明产生了碰撞，即发生了冲突</p>
</blockquote>
<p><strong>MA：</strong>多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p>
<p><strong>监听结果</strong>：</p>
<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持CSMA</li>
<li>非坚持CSMA</li>
<li>p-坚持CSMA</li>
</ul>
</li>
</ul>
<h4 id="1-坚持CSMA"><a href="#1-坚持CSMA" class="headerlink" title="1-坚持CSMA"></a>1-坚持CSMA</h4><p>坚持：对于监听<strong>信道忙</strong>之后的<strong>坚持</strong></p>
<blockquote>
<p>思想：</p>
<ul>
<li><p>如果一个主机发送消息，那么它先监听信道。</p>
</li>
<li><p><strong>空闲则直接传输，不必等待；</strong></p>
</li>
<li><p><strong>忙则一直监听，直到空闲马上传输。</strong></p>
</li>
<li><p>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</p>
</li>
</ul>
</blockquote>
<p><strong>优点：</strong>只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</p>
<p><strong>缺点：</strong>假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p>
<h4 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a>非坚持CSMA</h4><p>非坚持：对于监听<strong>信道忙</strong>之后就<strong>不继续监听</strong></p>
<blockquote>
<p>思想：</p>
<ul>
<li>如果一个主机要发送信息，那么它先监听信道。</li>
<li><strong>空闲则直接传输，不必等待；</strong></li>
<li><strong>忙则等待一个随机的时间之后再进行监听</strong></li>
</ul>
</blockquote>
<p><strong>优点：</strong>采用随机的重发延迟时间可以减少冲突发生的可能性</p>
<p><strong>缺点：</strong>可能存在大家都在延迟等待过程中。使得媒体仍可能处于空闲状态，媒体使用率低。</p>
<h4 id="p-坚持CSMA"><a href="#p-坚持CSMA" class="headerlink" title="p-坚持CSMA"></a>p-坚持CSMA</h4><p>p-坚持：对于监听信道<strong>空闲</strong>的处理</p>
<blockquote>
<p>思想：</p>
<ul>
<li>如果一个主机要发送信息，那么它先监听信道。</li>
<li><strong>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输。</strong></li>
</ul>
</blockquote>
<p><strong>优点：</strong>既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</p>
<p><strong>缺点：</strong>发生冲突之后还是要坚持把数据帧发送完，造成了浪 费</p>
<h4 id="三种CSMA总结"><a href="#三种CSMA总结" class="headerlink" title="三种CSMA总结"></a>三种CSMA总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>1-坚持CSMA</th>
<th>非坚持CSMA</th>
<th>p-坚持CSMA</th>
</tr>
</thead>
<tbody>
<tr>
<td>信道空闲</td>
<td>马上发</td>
<td>马上发</td>
<td>p 概率马上发<br>1-p 概率等到下一个时隙再发送</td>
</tr>
<tr>
<td>信道忙</td>
<td>继续坚持监听</td>
<td>放弃监听，等一个随机事件再监听</td>
<td>放弃监听，等一个随机时间再监听</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-4-3-CSMA-CD协议"><a href="#5-4-3-CSMA-CD协议" class="headerlink" title="5.4.3. CSMA/CD协议"></a>5.4.3. CSMA/CD协议</h3><p>载波监听多点接入/碰撞检测CSMA/CD（carrier sense multiple access with collision detection）</p>
<p><strong>CS：</strong>载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>要检测一下总线上是否有其他计算机在发送数据。</p>
<p><strong>MA：</strong>多点接入，表示许多计算机以多点接入的方式连接在一根总线上。（总线型网络）</p>
<p><strong>CD：</strong>碰撞检测（冲突检测），“<strong>边发送边监听”</strong>，适配器边发送数据便检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。（半双工网络）</p>
<h4 id="如何确定碰撞后的重传时机"><a href="#如何确定碰撞后的重传时机" class="headerlink" title="如何确定碰撞后的重传时机"></a>如何确定碰撞后的重传时机</h4><p><strong>截断二进制指数规避算法</strong></p>
<p>1、确定基本退避（推迟）时间位争取用期 $2\tau$ 。</p>
<p>2、定义参数k，它等于<strong>重传次数</strong>，但k不超过10，即k=min[重传次数，10]。<strong>当重传次数不超过10时，k等于重传次数；当重传次数大于10时，k就不再增大而是一直等于10.</strong></p>
<p>3、从离散的整数集合 <strong>[$0,1,\cdots,2^k-1$]</strong> 中随机取出一个数 r，重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即2r $\tau$ 。</p>
<p>4、  当重传达<strong>16次</strong>仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</p>
<p><strong>举例</strong></p>
<blockquote>
<p>第一次重传，k=1，r从{0，1}选；</p>
<p>重传推迟时间为0 或 $2\tau$ ，在这两个时间中随机选一个；</p>
<p>若再次碰撞，则在第二次重传时，k=2，r从{0,1,2,3}选；</p>
<p>重传推迟时间为0 或 $2\tau$ 或 $4\tau$ 或 $6\tau$ ，在这四个时间中随机选一个；</p>
<p>若再次碰撞，则第三次重传时，k=3，r从{0,1,2,3,4,5,6,7}选……</p>
</blockquote>
<h4 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h4><p>帧的传输时延至少要两倍于信号在总线中的传输时延。</p>
<script type="math/tex; mode=display">
\frac{\text{帧长（bit）} }{\text{数据传输速率} }\geqslant 2\tau</script><p><strong>最小帧长</strong> = 总线传播时延 $\times$ 数据传输速率 $\times$ 2</p>
<blockquote>
<p>以太网规定最短帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧。</p>
</blockquote>
<h3 id="5-4-4-CSMA-CA协议"><a href="#5-4-4-CSMA-CA协议" class="headerlink" title="5.4.4. CSMA/CA协议"></a>5.4.4. CSMA/CA协议</h3><p>载波监听多点接入/碰撞避免CSMA/CA（carrier sense multiple access with collsion avoidance）</p>
<p><strong>为什么要有CSMA/CA？</strong></p>
<ul>
<li>主要适用于无线局域网</li>
</ul>
<p><strong>原因：</strong></p>
<ul>
<li>无线局域网无法做到 360°全面检测碰撞</li>
<li>隐蔽站：当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会导致冲突</li>
</ul>
<h4 id="CSMA-CA协议工作原理"><a href="#CSMA-CA协议工作原理" class="headerlink" title="CSMA/CA协议工作原理"></a>CSMA/CA协议工作原理</h4><p>发送数据前，先检测信道是否空闲。</p>
<p>空闲则发出<strong>RTS（request to send）</strong>，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</p>
<p>接收端收到<strong>RTS</strong>后，将相应 <strong>CTS（clear to send）</strong>。</p>
<p>发送端收到CTS后，开始发送数据帧（同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据）。</p>
<p>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应<strong>ACK帧</strong>。</p>
<p>发送方收到<strong>ACK</strong>就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用<strong>二进制指数规避算法</strong>来确定随机的推迟时间）</p>
<p>1、预约信道</p>
<p>2、ACK帧</p>
<p>3、RTS/CTS帧（可选）</p>
<h3 id="5-4-5-CSMA-CD与CSMA-CA的异同"><a href="#5-4-5-CSMA-CD与CSMA-CA的异同" class="headerlink" title="5.4.5. CSMA/CD与CSMA/CA的异同"></a>5.4.5. CSMA/CD与CSMA/CA的异同</h3><p><strong>相同点：</strong></p>
<p>CSMA/CD与CSMA/CA机制都从属于CSMA的思路，其核心是<strong>先听再说</strong>。换言之，两个在接入信道之前都要进行监听。当发现信道空闲后，才能进行接入。</p>
<p><strong>不同点：</strong></p>
<p><strong>1、传输介质不同</strong>：CSMA/CD用于总线式以太网【有线】，而CSMA/CA用于无线局域网【无线】。</p>
<p><strong>2、载波检测方式不同</strong>：因<strong>传播介质不同，CSMA/CD与CSMA的检测方式也不同</strong>。CSMA/CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA/CA采用能量检测（ED）、载波检测（CS）和能量载波混合检测三种检测信道空闲的方式。</p>
<p>3、<strong>CSMA/CD检测冲突，CSMA/CA避免冲突</strong>，二者出现冲突后都会进行<strong>有上限的重传</strong>。</p>
<h2 id="5-5-轮询访问介质访问控制"><a href="#5-5-轮询访问介质访问控制" class="headerlink" title="5.5. 轮询访问介质访问控制"></a>5.5. 轮询访问介质访问控制</h2><p>轮询访问MAC协议/轮流协议/轮转访问MAC协议：</p>
<p>既<strong>不产生冲突（信道划分介质访问控制优点）</strong>，又要发送时 <strong>占全部带宽（随机访问介质访问控制优点）。</strong></p>
<h3 id="5-5-1-轮询协议"><a href="#5-5-1-轮询协议" class="headerlink" title="5.5.1. 轮询协议"></a>5.5.1. 轮询协议</h3><p>主节点<strong>轮流</strong> “邀请” 从属结点发送数据。</p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/16.png" style="zoom: 67%;"></p>
<p>问题：</p>
<ul>
<li>有轮询开销：因为要一个个问</li>
<li>等待延迟：对于靠后的主机来说，得等半天才能传送数据</li>
<li>单点故障：主节点宕机</li>
</ul>
<h3 id="5-5-2-令牌传递协议"><a href="#5-5-2-令牌传递协议" class="headerlink" title="5.5.2. 令牌传递协议"></a>5.5.2. 令牌传递协议</h3><p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/17.png" style="zoom: 67%;"></p>
<p><strong>令牌：</strong></p>
<ul>
<li>一个特殊格式的MAC控制帧，不含任何信息。</li>
<li>控制信道的使用，确保同一时刻只有一个结点独占信道</li>
</ul>
<p><strong>防止冲突</strong>：因为每次只有一个主机能掌握这个令牌，只要掌握令牌就能发送数据。</p>
<p>每个结点都可以在一定的时间内（令牌持有时间）获得发送数据的权力，并不是无限制的持有令牌。</p>
<p><strong>问题：</strong></p>
<ul>
<li>令牌开销：比如令牌消失、令牌重新创建</li>
<li>等待延迟：需要等到令牌传到自己才能发送数据</li>
<li>单点故障：其中有一台主机宕机，链路就断了</li>
</ul>
<p>应用于令牌环网（物理星型拓扑，逻辑环形拓扑）</p>
<p>采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中</p>
<h1 id="六、局域网基本概念和体系结构"><a href="#六、局域网基本概念和体系结构" class="headerlink" title="六、局域网基本概念和体系结构"></a>六、局域网基本概念和体系结构</h1><h2 id="6-1-局域网"><a href="#6-1-局域网" class="headerlink" title="6.1. 局域网"></a>6.1. 局域网</h2><p>局域网（Local Area Network）：简称LAN，是指在<strong>某一区域</strong>内有多台计算机互联成的计算机组，使用<strong>广播信道</strong>。</p>
<p>特点1：覆盖地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p>
<p>特点2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s~10Gb/s）</p>
<p>特点3：通信延迟短，误码率低，可靠性较高</p>
<p>特点4：各站为平等关系，共享传输信道。</p>
<p>特点5：多采用分布式控制和广播式通信，能进行广播和组播。</p>
<p>决定局域网的主要要素：<strong>网络拓扑</strong>，<strong>传输介质</strong>与<strong>介质访问控制方法</strong></p>
<h2 id="6-2-局域网拓扑结构"><a href="#6-2-局域网拓扑结构" class="headerlink" title="6.2. 局域网拓扑结构"></a>6.2. 局域网拓扑结构</h2><p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/18.png" style="zoom: 67%;"></p>
<p><strong>其中总线型拓扑结构是最好的</strong></p>
<h2 id="6-3-局域网传输介质"><a href="#6-3-局域网传输介质" class="headerlink" title="6.3. 局域网传输介质"></a>6.3. 局域网传输介质</h2><script type="math/tex; mode=display">
\text{局域网}
\begin{cases}
\text{有线局域网-常用介质：双绞线、同轴电缆、光纤}
\\
\\
\text{无线局域网-常用介质：电磁波}
\end{cases}</script><h2 id="6-4-局域网介质访问控制方法"><a href="#6-4-局域网介质访问控制方法" class="headerlink" title="6.4. 局域网介质访问控制方法"></a>6.4. 局域网介质访问控制方法</h2><p>1.CSMA/CD：常用于<strong>总线型局域网</strong>，也用于树形网络</p>
<p>2.令牌总线：</p>
<ul>
<li>常用于<strong>总线型局域网</strong>，也用于树形网络</li>
<li>它是把总线型或树形网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</li>
</ul>
<p>3.令牌环：用于环型局域网，如令牌环网</p>
<h2 id="6-5-局域网的分类"><a href="#6-5-局域网的分类" class="headerlink" title="6.5. 局域网的分类"></a>6.5. 局域网的分类</h2><p><strong>1、以太网</strong>：以太网是应用最广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000Mbps）和10G以太网，他们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑星型或拓展星型。使用CSMA/CD</p>
<p><strong>2、令牌环网</strong>：物理上采用星型拓扑结构，逻辑上是环形拓扑结构。（因造价等问题，基本用不到）</p>
<p><strong>3、FDDI网（Fiber Distributed Data Interface）</strong>：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。</p>
<p><strong>4、ATM网 （Asynchronous Transfer Mode）</strong>：较新型的单元交换技术，使用53字节固定长度的单元进行交换</p>
<p><strong>5、无线局域网 （Wireless Local Area Network: WLAN）</strong>：采用IEEE 802.11标准</p>
<h2 id="6-6-IEEE-802标准"><a href="#6-6-IEEE-802标准" class="headerlink" title="6.6. IEEE 802标准"></a>6.6. IEEE 802标准</h2><p>IEEE 802系列标准是IEEE802 LAN/MAN 标准委员会制定的局域网、城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p>
<h2 id="6-7-MAC子层和LLC子层"><a href="#6-7-MAC子层和LLC子层" class="headerlink" title="6.7. MAC子层和LLC子层"></a>6.7. MAC子层和LLC子层</h2><p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型中的<strong>数据链路层与物理层</strong>，它将数据链路层划分为逻辑链路层<strong>LLC子层</strong>和介质访问控制<strong>MAC子层</strong></p>
<p><img src="/2021/11/22/3-%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/19.png" style="zoom: 67%;"></p>
<p>LLC负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包作何处理。为网络层提供服务：无确认无连接、面向连接、待确认无连接、高速传送。</p>
<p>MAC子层的主要功能包括数据帧的封装/谢庄，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性。</p>
<h2 id="6-8-以太网"><a href="#6-8-以太网" class="headerlink" title="6.8. 以太网"></a>6.8. 以太网</h2><p>以太网（Ethernet）指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带<strong>总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。以太网络使用<strong>CSMA/CD</strong>技术。</p>
<p>以太网在局域网各种技术中占<strong>统治性</strong>地位：</p>
<ul>
<li>造价低廉（以太网网卡不到100块）</li>
<li>是应用最广泛的局域网</li>
<li>比令牌环网、ATM网便宜，简单；</li>
<li><strong>满足网络速率要求：10Mb/s~10Gb/s</strong></li>
</ul>
<p>以太网的两个标准：</p>
<ul>
<li>DIX Ethernet V2：第一个局域网产品（以太网）规约</li>
<li>IEEE 802.3：IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。</li>
</ul>
<h3 id="以太网无连接、不可靠的服务"><a href="#以太网无连接、不可靠的服务" class="headerlink" title="以太网无连接、不可靠的服务"></a>以太网无连接、不可靠的服务</h3><p><strong>无连接</strong>：发送方和接收方之间无 “握手过程”</p>
<p><strong>不可靠</strong>：不对发送方的数据帧编号，接收方不向发送方进行<strong>确认</strong>，差错帧直接丢弃，差错纠正由高层负责。</p>
<p><strong>以太网只实现无差错接收，不实现可靠传输</strong></p>
<h3 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h3><p>10BASE-T是传送<strong>基带信号</strong>的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是<strong>无屏蔽双绞线（UTP）</strong>，传输速率是<strong>10Mb/s</strong></p>
<p><strong>物理上采用星型拓扑，逻辑上总线型</strong>，每段双绞线最长为100m</p>
<p>采用<strong>曼彻斯特编码</strong></p>
<p>采用<strong>CAMA/CD</strong>介质访问控制：会发生冲突</p>
<h3 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h3><p>计算机与外界局域网的连接是通过<strong>通信适配器</strong>的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>4.CSS的元素显示模式</title>
    <url>/2021/07/20/4-CSS%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS-的元素显示模式"><a href="#CSS-的元素显示模式" class="headerlink" title="CSS 的元素显示模式"></a>CSS 的元素显示模式</h1><blockquote>
<p>元素显示模式就是元素（标签）以什么方式进行显示，比如&lt;div&gt;自己占一行，比如一行可以放多个&lt;span&gt;</p>
</blockquote>
<p>HTML元素一般分为 <strong>块元素</strong> 和 <strong>行内元素</strong></p>
<h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><p>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;li&gt;等，其中&lt;div&gt;标签式最典型的块元素</p>
<p>块级元素特点：</p>
<p>1.独占一行</p>
<p>2.高度，宽度，外边距以及内边距都可以控制。</p>
<p>3.宽度默认是<strong>容器（父级宽度）的100%。</strong></p>
<p>4.是一个容器及盒子，里面可以放行内或者块级元素。</p>
<p><strong>注意:</strong></p>
<ul>
<li><strong>文字类元素内不能使用块级元素</strong></li>
<li><strong>&lt;p&gt;标签主要用于存放文字</strong>，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt;</li>
<li>同理，&lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素</li>
</ul>
<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签是最典型的行内元素。</p>
<p><strong>行内元素的特点：</strong></p>
<p>1.相邻行内元素在一行上，<strong>一行可以显示多个</strong>。</p>
<p>2.<strong>高、宽直接设置是无效的</strong></p>
<p>3.默认宽度就是<strong>它本身内容的宽度</strong>。</p>
<p>4.行内元素<strong>只能容纳文本或其它行内元素</strong>。</p>
<p>5.<strong>margin只有左右有效，padding四个方向都有效</strong></p>
<p><strong>注意:</strong></p>
<ul>
<li>链接里面不能再放链接</li>
<li>特殊情况&lt;a&gt;里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全</li>
</ul>
<h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p>在行内元素中有几个特殊的标签 —— &lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，他们同时具有块元素和行内元素的特点，有些资料称它们为行内块元素。</p>
<p>行内块元素的特点：</p>
<p>1.和相邻行内元素（行内块）在一行上，但是他们之间<strong>会有空白缝隙</strong>，<strong>一行可以显示多个</strong> <strong>（行内元素特点）</strong></p>
<p>2.默认宽度就是<strong>它本身内容的宽度</strong> <strong>（行内元素的特点）</strong></p>
<p>3.高度、行高、外边距以及内边距都可以控制 <strong>（块级元素特点）</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">元素模式</th>
<th style="text-align:left">元素排列</th>
<th style="text-align:left">设置样式</th>
<th style="text-align:left">默认宽度</th>
<th style="text-align:left">包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">块级元素</td>
<td style="text-align:left">一行只能放一个块级元素</td>
<td style="text-align:left">可以设置宽度高度</td>
<td style="text-align:left">容器的100%</td>
<td style="text-align:left">容器可以包含任何标签</td>
</tr>
<tr>
<td style="text-align:left">行内元素</td>
<td style="text-align:left">一行可以放多个行内元素</td>
<td style="text-align:left">不可以设置宽度高度</td>
<td style="text-align:left">它自身内容的宽度</td>
<td style="text-align:left">容纳文本或者其他行内元素</td>
</tr>
<tr>
<td style="text-align:left">行内块元素</td>
<td style="text-align:left">一行放多个行内块元素</td>
<td style="text-align:left">可以设置宽度高度</td>
<td style="text-align:left">它本身内容的宽度</td>
<td style="text-align:left"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="元素显示模式转换"><a href="#元素显示模式转换" class="headerlink" title="元素显示模式转换"></a>元素显示模式转换</h2><p>特殊情况下，我们需要元素模式的转换，简单理解：一个模式的元素需要另外一种模式的特性，比如想要增加链接&lt;a&gt;的触发范围</p>
<ul>
<li>转换为<strong>块元素：display:block;</strong></li>
<li>转换为<strong>行内元素： display:inline;</strong></li>
<li>转换为<strong>行内块元素： display:inline-block;</strong></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>3.方程组</title>
    <url>/2021/06/19/3.%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><h2 id="克莱姆法则"><a href="#克莱姆法则" class="headerlink" title="克莱姆法则"></a>克莱姆法则</h2><ul>
<li>形式<br>$\begin{cases}<br>{\large a}_{11}{\large x}_1+{\large a}_{12}{\large x}_2+\cdots+{\large a}_{1n}{\large x}_n={\large b}_1\\<br>{\large a}_{21}{\large x}_1+{\large a}_{22}{\large x}_2+\cdots+{\large a}_{2n}{\large x}_n={\large b}_2\qquad(1)\\<br>\qquad\cdots\cdots\\<br>{\large a}_{n1}{\large x}_1+{\large a}_{n2}{\large x}_2+\cdots+{\large a}_{nn}{\large x}_n={\large b}_b<br>\end{cases}<br>$<br><br>的系数行列式<br><br>$<br>D=\left|\begin{array}{ccc}<br> {\large a}_{11}&amp;{\large a}_{12}&amp;\cdots&amp;{\large a}_{1n}\\<br> {\large a}_{21}&amp;{\large a}_{22}&amp;\cdots&amp;{\large a}_{2n}\\<br> \vdots&amp;\vdots&amp;&amp;\vdots\\<br> {\large a}_{n1}&amp;{\large a}_{n2}&amp;\cdots&amp;{\large a}_{nn}<br>\end{array}\right|\not=0<br>$<br><br>则方程组有唯一解<br><br>$\displaystyle {\large x}_1=\frac{D_1}{D},{\large x}_2=\frac{D_2}{D},\cdots, {\large x}_n=\frac{D_n}{D}$<br><br>其中<br><br>$<br>D_j=\left|\begin{array}{ccc}<br>{\large a}_{11}&amp;\cdots&amp;{\large a}_{1 j-1}&amp;{\large b}_1&amp;{\large a}_{1 j+1}&amp;\cdots&amp;{\large a}_{1n}\\<br>{\large a}_{21}&amp;\cdots&amp;{\large a}_{2 j-1}&amp;{\large b}_2&amp;{\large a}_{2 j+1}&amp;\cdots&amp;{\large a}_{2n}\\<br>\vdots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\<br>{\large a}_{n1}&amp;\cdots&amp;{\large a}_{n j-1}&amp;{\large b}_n&amp;{\large a}_{n j+1}&amp;\cdots&amp;{\large a}_{nn}<br>\end{array}\right|<br>$</li>
</ul>
<p>证明：<br>以后补充……<br>推论:</p>
<p>$<br>\begin{cases}<br>{\large a}_{11}{\large x}_1+{\large a}_{12}{\large x}_2+\cdots+{\large a}_{1n}{\large x}_n=0\\<br>{\large a}_{21}{\large x}_1+{\large a}_{22}{\large x}_2+\cdots+{\large a}_{2n}{\large x}_n=0\qquad(2)\\<br>\qquad\cdots\cdots\\<br>{\large a}_{n1}{\large x}_1+{\large a}_{n2}{\large x}_2+\cdots+{\large a}_{nn}{\large x}_n=0<br>\end{cases}<br>$<br><br><br>$|A|\not=0$,则方程只有零解</p>
<p>若齐次方程(2)有非零解,则$|A|=0$</p>
<h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><p>把矩阵化成行阶梯型</p>
<p>然后化成行最简型矩阵</p>
<p>矩阵的 <strong><u>行</u></strong> 初等变换其实就是对应的方程组的三种变换</p>
<h2 id="n元线性方程组-Ax-b"><a href="#n元线性方程组-Ax-b" class="headerlink" title="n元线性方程组$Ax=b$"></a>n元线性方程组$Ax=b$</h2><ol>
<li>无解<br>$\;\Longleftrightarrow\;r(A)+1=r(\overline{A})$<br><br></li>
<li>唯一解<br>$\;\Longleftrightarrow\;r(A)=r(\overline{A})=n\;\longrightarrow\;A是可逆矩阵\Leftrightarrow|A|\neq0$<br><br></li>
<li>无穷多解<br>$\;\Longleftrightarrow\;r(A)=r(\overline{A})&lt; n$<br><br><br> </li>
</ol>
<ul>
<li><p>齐次方程组$Ax=0$<br><br>$\qquad$有非0解$\;\Longleftrightarrow\;r(A) &lt; n$<br><br>$\qquad$只有零解$\;\Longleftrightarrow\;r(A)=n$</p>
</li>
<li><p>$\;$矩阵方程$AX=B$有解$\;\Longleftrightarrow\;r(A)=r(A\vdots B)\longrightarrow\;$其实就是上面的推广</p>
</li>
</ul>
<h2 id="基础解系"><a href="#基础解系" class="headerlink" title="基础解系"></a>基础解系</h2><p>理论基础：$A-m\times n,r(A)=r&lt;n$,则齐次方程组$Ax=0\;$由n-r个线性无关的解，且$Ax=0$的任一个解可由这n-r个线性无关的解线性表示</p>
<blockquote>
<p>基础解系其实就是齐次方程组解向量的极大无关组<br><br>不过要注意与向量组的极大无关组进行区分</p>
<hr>
<p>即，如果满足：<br><br>$\quad$(1)$\eta_1\;\eta_2\;\cdots\;\eta_t\;$是$Ax=0$的解；<br><br><br>$\quad$(2)$\eta_1\;\eta_2\;\cdots\;\eta_t\;$线性无关;<br><br><br>$\quad$(3)$Ax=0$的任一个解均可由$\eta_1\;\eta_2\;\cdots\;\eta_t\;$线性表示<br><br><br>则$\eta_1\;\eta_2\;\cdots\;\eta_t\;$是齐次方程组$Ax=0$的基础解系</p>
</blockquote>
<h3 id="齐次方程求基础解系和通解"><a href="#齐次方程求基础解系和通解" class="headerlink" title="齐次方程求基础解系和通解"></a>齐次方程求基础解系和通解</h3><ul>
<li><strong>例</strong><br><br>求齐次方程组<br><br>$<br>\begin{cases}<br>x_1+2x_2-x_3-5x_5=0\\<br>x_2-x_3+x_4+x_5=0\\<br>2x_1+4x_2-2x_3+x_4-8x_5=0<br>\end{cases}<br>$<br><br>的基础解系与通解<br><br>解：<br>对系数矩阵作初等行变换化为行最简型<br><br>$<br>A=<br>\begin{pmatrix}<br>  1&amp;2&amp;-1&amp;0&amp;-5\\<br>   0&amp;1&amp;-2&amp;1&amp;1\\<br>   2&amp;4&amp;-2&amp;1&amp;-8<br>\end{pmatrix}<br>\longrightarrow<br>\begin{pmatrix}<br>  1&amp;0&amp;3&amp;0&amp;-3\\<br>   0&amp;1&amp;-2&amp;0&amp;1\\<br>   0&amp;0&amp;0&amp;1&amp;2<br>\end{pmatrix}<br>$<br><br><br>$<br>n-r(A)=5-3=2\quad\longrightarrow\;表明该方程组由两个基础解系<br>$<br><br><br>同解方程组<br><br>$<br>\begin{cases}<br>x_1+3x_3-3x_5=0\\<br>x_2-2x_3-x_5=0\\<br>x_4+2x_5=0<br>\end{cases}<br>$<br><br><br>$<br>\begin{cases}<br>x_1=-3x_3+3x_5\\<br>x_2=2x_3+x_5\\<br>x_4=-2x_5<br>\end{cases}<br>$<br><br><br>$<br>分别令\begin{bmatrix}x_3\\x_5\end{bmatrix}为\begin{bmatrix}1\\0\end{bmatrix}和\begin{bmatrix}0\\1\end{bmatrix}<br>$<br><br><br>代入方程组对应求出<br>$<br>\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}为\begin{bmatrix}-3\\2\\0\end{bmatrix}和\begin{bmatrix}3\\1\\ -2\end{bmatrix}<br>$<br><br><br>得到基础解系：<br>$\quad\eta_1=[-3,2,1,0,0]^T$<br><br>$\quad\eta_2=[3,1,0,-2,1]^T$<br><br><br>通解：<br>$k_1\eta_1+k_2\eta_2$<br><br>$即\;\;k_1\begin{bmatrix}-3\\2\\1\\0\\0\end{bmatrix}+k_2\begin{bmatrix}3\\1\\0\\ -2\\1\end{bmatrix}$</li>
</ul>
<h3 id="非齐次线性方程求通解"><a href="#非齐次线性方程求通解" class="headerlink" title="非齐次线性方程求通解"></a>非齐次线性方程求通解</h3><ul>
<li>方程组$Ax=b$的通解：<br><br>$\alpha_0+k_1\eta_1+k_2\eta_2+\cdots+k_{n-r}\eta_{n-r}$<br><br>其中$\eta_1\eta_2\cdots\eta_{n-1}$是导出组$Ax=0$的基础解系$，\alpha_0$是$Ax=b$的一个解<br><br>$\qquad\longrightarrow$微分方程也是这个思想</li>
</ul>
<ul>
<li><strong>例</strong><br><br>解方程组<br><br>$<br>\begin{cases}<br>  x_1-x_2-x_3+x_4=0\\<br>  x_1-x_2+x_3-3x_4=1\\<br>  x_1-x_2-2x_3+3x_4=-\frac{1}{2}<br>\end{cases}<br>$<br><br>解：<br>对增广矩阵做初等行变换，化为行最简型<br><br>$<br>\overline{A}=<br>\begin{pmatrix}<br> 1&amp;-1&amp;-1&amp;1&amp;0\\<br> 1&amp;-1&amp;1&amp;-3&amp;1\\<br> 1&amp;-1&amp;-2&amp;3&amp;-\frac{1}{2}<br>\end{pmatrix}<br>\rightarrow<br>\begin{pmatrix}<br> 1&amp;-1&amp;0&amp;-1&amp;\frac{1}{2}\\<br> 0&amp;0&amp;1&amp;-2&amp;\frac{1}{2}\\<br> 0&amp;0&amp;0&amp;0&amp;0<br>\end{pmatrix}<br>$<br><br>$r(A)=r(\overline{A})=2<4\;\rightarrow\;方程组有无穷解$<br><br>$n-r(A)=4-2=2$<br><br>$<br>\begin{cases}<br>x_1=x_2+x_4+\displaystyle\frac{1}{2}\\<br>x_3=2x_4+\displaystyle\frac{1}{2}<br>\end{cases}$<br><br>令$\;x_2=x_4=0\;\Rightarrow\;x_1=\displaystyle\frac{1}{2},x_3=\displaystyle\frac{1}{2}<br>$<br><br><br>特解$\quad\alpha=\begin{bmatrix}\displaystyle\frac{1}{2}\\0\\ \displaystyle\frac{1}{2}\\0\end{bmatrix}$<br><br><br>令$\begin{bmatrix}x_2\\x_4\end{bmatrix}$分别为$\begin{bmatrix}1\\0\end{bmatrix}和\begin{bmatrix}0\\1\end{bmatrix}<br>$</4\;\rightarrow\;方程组有无穷解$<br></li>
</ul>
<p>$\Rightarrow\begin{bmatrix}x_1\\x_3\end{bmatrix}为\begin{bmatrix}1\\0\end{bmatrix}和\begin{bmatrix}1\\2\end{bmatrix}$<br><br><br>则基础解系为<br><br>$\eta_1=[1,1,0,0]^T，\eta_2=[1,0,2,1]^T$<br><br><br>$\therefore$方程组组的通解：<br><br>$<br>x=<br>\begin{bmatrix}x_1\\x_2\\x_3\\x_4\end{bmatrix}=<br>k_1\begin{bmatrix}1\\1\\0\\0\end{bmatrix}+<br>k_2\begin{bmatrix}1\\0\\2\\1\end{bmatrix}+<br>\begin{bmatrix}\displaystyle\frac{1}{2}\\0\\ \displaystyle\frac{1}{2}\\0\end{bmatrix}<br>$<br><br><br>这里的方程组我认为可以和向量空间，后面继续拓展深入研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>4.图</title>
    <url>/2021/07/30/4-%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>完全图</strong>：任意两个点都有一条边相连</p>
<ul>
<li>无向完全图：没有方向</li>
<li>有向完全图：有方向<span id="more"></span>
<img style="transform:scale(0.5);" src="/2021/07/30/4-%E5%9B%BE/pic1.png"></li>
</ul>
<p><strong>稀疏图</strong>：有很少边或弧的图</p>
<p><strong>稠密图</strong>：有较多边或弧的图</p>
<p><strong>邻接</strong>：有边/弧相连的两个顶点之间的关系</p>
<ul>
<li>存在 $(v_i,v_j)$，则称 $v_i$ 和 $v_j$ 互为临邻接点</li>
<li>存在 &lt;$v_i,v_j$&gt;，则称 $v_i$ <strong>邻接到</strong> $v_j$ ，$v_j$ <strong>邻接于</strong> $v_i$</li>
</ul>
<p><strong>关联</strong>：边/弧与顶点之间的关系</p>
<ul>
<li>存在 $(v_i,v_j)$ /&lt;$v_i,v_j$&gt; ，则称该边/弧关联于 $v_i$ 和 $v_j$</li>
</ul>
<p><strong>顶点的度</strong>：与该顶点相关联的边的数目，记为TD(v)</p>
<ul>
<li>在有向图中，顶点的度等于该顶点的 <strong>入度</strong> 和 <strong>出度</strong> 之和<ul>
<li>顶点v的 <strong>入度</strong> 是 <strong>以v为终点</strong> 的有向边的条数，记作ID(v)</li>
<li>顶点v的 <strong>出度</strong> 是以 <strong>v为始点</strong> 的有向边的条数，记作OD(v)</li>
</ul>
</li>
</ul>
<p><strong>路径</strong>：接续的边构成的顶点序列</p>
<p><strong>路径长度</strong>：路径上边或弧的数目/权值之和</p>
<p><strong>回路（环）</strong>：第一个顶点和最后一个顶点相同的路径</p>
<p><strong>简单路径</strong>：除路径起点和终点可以相同外，其余顶点均不相同的路径</p>
<p><strong>简单回路</strong>：除路径起点和终点相同外，其余顶点均不相同</p>
<p><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic2.png"></p>
<p><strong>连通图（强连通图）</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic3.png"></p>
<p><strong>权</strong>：图中边或弧所具有的相关数称为 <strong>权</strong>。表明从一个顶点到另一个顶点的距离或耗费</p>
<p><strong>网</strong>：边/弧带权的图</p>
<p><strong>子图</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic4.png"></p>
<p><strong>连通分量（强连通分量）</strong></p>
<ul>
<li>无向图G的 <strong>极大连通子图</strong> 称为G的 <strong>连通分量</strong><br>极大连通子图：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通</li>
<li>有向图G的极大强连通子图称为G的强连通分量<br>极大强连通子图：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的</li>
</ul>
<p><strong>极小连通子图</strong>：该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通</p>
<p><strong>生成树</strong>：包含无向图G所有顶点的极小连通子图</p>
<p><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合<br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic5.png"></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>1、数组（邻接矩阵）表示法</p>
<ul>
<li>建立一个 <strong>顶点表</strong>（记录各个顶点信息）和一个 <strong>邻接矩阵</strong>（表示各个顶点之间关系）</li>
</ul>
<p><strong>无向图的邻接矩阵表示法：</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic6.png"></p>
<p><strong>有向图的邻接矩阵表示法：</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic7.png"></p>
<p><strong>行为出度，列为入度</strong></p>
<p><strong>网（即有权图）的邻接矩阵表示法</strong><br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic8.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VerTexType;<span class="comment">//设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType; <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum]; <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125;AMGragh;<span class="comment">//Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure>
<p>2、采用邻接矩阵表示法 <strong>创建无向网</strong></p>
<ul>
<li>输入总顶点数和总边数</li>
<li>依次输入点的信息存入顶点表中</li>
<li>初始化邻接矩阵，使每个权值初始化为极大值</li>
<li>构造邻接矩阵</li>
</ul>
<p>邻接矩阵优点：</p>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便计算任一顶点的”度”</li>
</ul>
<p>缺点：</p>
<ul>
<li>不便于增加或删除顶点</li>
<li>浪费空间—-存稀疏图（点很多而且边很少）有大量无效元素<ul>
<li>当然对稠密图（特别是完全图）划算</li>
</ul>
</li>
<li>浪费时间—-统计稀疏图中一共有多少条边</li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>1、邻接表表示法（链式）<br><img style="transform:scale(0.7);" src="/2021/07/30/4-%E5%9B%BE/pic9.png"></p>
<ul>
<li>顶点：<ul>
<li>按编号顺序将顶点数据存储在 <strong>一维数组</strong> 中</li>
</ul>
</li>
<li>关联同一顶点的边（以顶点为尾的弧）：<ul>
<li>用线性 <strong>链表</strong> 存储</li>
</ul>
</li>
</ul>
<p><strong>顶点结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br></pre></td></tr></table></figure></p>
<p><strong>弧（边）的结点结构</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br></pre></td></tr></table></figure></p>
<p><strong>图的结构定义</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//vertices--vertex的复数</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure></p>
<p>2、采用邻接表法创建无向网</p>
<p>算法思想</p>
<ul>
<li>输入总顶点数和总边数</li>
<li>建立顶点表<ul>
<li>依次输入点的信息存入顶点表中</li>
<li>使每个表头结点的指针域初始化为NULL</li>
</ul>
</li>
<li><p>创建邻接表</p>
<ul>
<li>依次输入每条边依附的两个顶点</li>
<li>确定两个顶点的序号i和j，建立边结点</li>
<li>将此边结点分别插入到$v_i$和$v_j$对应的两个边链表的头部</li>
</ul>
</li>
<li><p>方便找任一顶点的所有“邻接点”</p>
</li>
<li>节约稀疏图的空间<ul>
<li>需要N个头指针+2E个结点（每个结点至少两个域）</li>
</ul>
</li>
<li>计算任一顶点的“度”<ul>
<li>对无向图：是</li>
<li>对有向图：只能计算“出度”；需要构造“逆邻接表”来计算“入度”</li>
</ul>
</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul>
<li>深度优先搜索（Depth_First Search—-DFS）</li>
<li>广度优先搜索（Breadth_First Search—-BFS）</li>
</ul>
<h3 id="深度优先遍历的算法实现"><a href="#深度优先遍历的算法实现" class="headerlink" title="深度优先遍历的算法实现"></a>深度优先遍历的算法实现</h3><p>邻接矩阵表示的无向图深度遍历实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMGraph G,<span class="keyword">int</span> V)</span></span>&#123;<span class="comment">//图G为邻接矩阵类型</span></span><br><span class="line">    cout&lt;&lt;v;visited[v]=<span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)<span class="comment">//依次检查邻接矩阵v所在的行</span></span><br><span class="line">        <span class="keyword">if</span>((G.arcs[v][w]!=<span class="number">0</span>)&amp;&amp;(!visited[w]))</span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        <span class="comment">//w是v的邻接点，如果w未访问，则递归调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历算法实现"><a href="#广度优先遍历算法实现" class="headerlink" title="广度优先遍历算法实现"></a>广度优先遍历算法实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;v;visted[v]=<span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);<span class="comment">//v进队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;<span class="comment">//队列非空</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,u);<span class="comment">//队头元素出队并置为u</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstAdjVex</span>(G,u);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextAdjVex</span>(G,u,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            cout&lt;&lt;w;visted[w]=<span class="literal">true</span>; <span class="built_in">EnQueue</span>(Q,w);<span class="comment">//w进队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><strong>1、普利姆（prim）算法</strong><br>适应范围：稠密图<br>时间复杂度$O(n^2)$<br><strong>2、克鲁斯卡尔(Kruskal)算法</strong><br>适应范围：稀疏图<br>时间复杂度：$O(e\log e)$</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ol>
<li>单源最短路径—用 Dijkstra(迪杰斯特拉)算法<ul>
<li>初始化：先找出从源点 $v_0$ 到各终点 $v_k$ 的直达路径($v_0$,$v_k$)，即通过一条弧到达的路径</li>
<li>选择：从这些路径中找出一条长度最短的路径($v_0$ , u)</li>
<li>更新：然后对其余各条路径进行适当调整：<ul>
<li>若在途中存在弧（u , $v_k$），且($v_0$ , u)+(u , $v_k$) &lt; ($v_0$ , $v_k$)，则以路径则以路径($v_0$ , u , $v_k$)代替($v_0$ , $v_k$)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li>所有顶点间的最短路径—用 Floyd(弗洛伊德)算法<br>s</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4.索引补充</title>
    <url>/2021/07/04/4-%E7%B4%A2%E5%BC%95%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>5
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 3, 4])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11]],

       [[12, 13, 14, 15, 16, 17],
        [18, 19, 20, 21, 22, 23]]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])
</code></pre><h1 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">arr2d</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:<span class="number">2</span>] <span class="comment"># 表示选取前两行</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[<span class="number">1</span>:] <span class="comment"># 表示选取第1行之后的所有行</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:<span class="number">2</span>,<span class="number">1</span>:] <span class="comment"># 两个结合起来使用，第一个选取行，第二个选取列</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [5, 6, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:,<span class="number">2</span>] <span class="comment"># 只有冒号表示整个轴</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 2,  6, 10])
</code></pre><h1 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = np.array([<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;wang&quot;</span>,<span class="string">&quot;zhang&quot;</span>,<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;zhang&quot;</span>,<span class="string">&quot;wang&quot;</span>,<span class="string">&quot;wang&quot;</span>])</span><br><span class="line">data =  np.arange(<span class="number">21</span>).reshape(<span class="number">7</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure>
<pre><code>array([&#39;liu&#39;, &#39;wang&#39;, &#39;zhang&#39;, &#39;liu&#39;, &#39;zhang&#39;, &#39;wang&#39;, &#39;wang&#39;],
      dtype=&#39;&lt;U5&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14],
       [15, 16, 17],
       [18, 19, 20]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[name == <span class="string">&quot;liu&quot;</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[name == <span class="string">&quot;liu&quot;</span>,:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1],
       [ 9, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[(name==<span class="string">&#x27;liu&#x27;</span>)|(name==<span class="string">&#x27;wang&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 9, 10, 11],
       [15, 16, 17],
       [18, 19, 20]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[data &lt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre><p>也就是说布尔索引会把括号里面为真的按顺序返回</p>
<h1 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h1><blockquote>
<p>利用整数数组进行索引</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    arr[i] = i</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[2., 2., 2., 2.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [1., 1., 1., 1.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([ 2, 11,  5, 10])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]][:,[<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5,  6],
       [ 9, 10]])
</code></pre><p>花式索引和切片不一样，它总是复制到新数组中</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>4.n维向量</title>
    <url>/2021/06/20/4.n%E7%BB%B4%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="n维向量"><a href="#n维向量" class="headerlink" title="n维向量"></a>n维向量</h1><blockquote>
<p>n个数$a_1,a_2,\cdots a_n$构成的有序数组</p>
</blockquote>
<p>$\left[\begin{array}{c}a_1\\a_2\\ \vdots \\a_n\end{array}\right]$<br>或$\left[\begin{array}{c}a_1\;a_2\;\cdots\;a_n\end{array}\right]^T\longrightarrow$列向量<br><br><br>$\left[\begin{array}{c}a_1\;a_2\;\cdots\;a_n\end{array}\right]\longrightarrow$行向量</p>
<h2 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h2><p>运算方法其实就是矩阵的运算方法</p>
<h2 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h2><h3 id="向量的线性表示"><a href="#向量的线性表示" class="headerlink" title="向量的线性表示"></a>向量的线性表示</h3><blockquote>
<p>m个n维向量$\alpha_1\alpha_2\cdots\alpha_m$及m个实数$k_1,k_2,\cdots,k_m$,称</p>
<p>$\quad k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m$</p>
<p>是向量$\alpha_1\alpha_2\cdots\alpha_m$的一个线性组合，$k_1,k_2,\cdots,k_m$为这个线性组合的系数<br><br><br>如果向量$\beta$能表示为$\alpha_1\alpha_2\cdots\alpha_m$的线性组合，即</p>
<p>$\qquad\qquad \beta=k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m$</p>
<p>则称向量$\beta$可由$\alpha_1\alpha_2\cdots\alpha_m$线性表示</p>
</blockquote>
<p>$[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}k_1\\k_2\\ \vdots\\k_m\end{array}\right]=\beta$<br><br>$\Longleftrightarrow方程组$<br>$[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}x_1\\x_2\\ \vdots\\x_m\end{array}\right]=\beta\;\;有解$<br><br>$\Longleftrightarrow r(\alpha_1\alpha_2\cdots\alpha_m)= r(\alpha_1\alpha_2\cdots\alpha_m\beta)$</p>
<p><strong>例</strong></p>
<p>$设\alpha_1=[1,-1,1]^T，\alpha_2=[-2,1,1]^T$<br>$\alpha_3=[4,-3,1]^T，\beta=[3,-1,3]^T$<br><br>$判断\beta能否由\alpha_1\alpha_2\alpha_3线性表示$</p>
<p>解：<br>$设k_1\alpha_1+k_2\alpha_2+k_3\alpha_3=\beta$<br><br>即<br>$k_1[1,-1,1]^T+k_2[-2,1,1]^T+k_3[4,-3,1]^T$<br>$=[3,-1,3]^T$<br></p>
<ul>
<li>即<br>$\begin{cases}<br>  k_1-2k_2+4k_3=3\\<br>  -x_1+x_2-3x_3=-1\\<br>  x_1+x_2+x_3=-1\\<br>\end{cases}$</li>
</ul>
<p>$下面就转化为了高斯消元法进行求解出k_1k_2k_3$<br><br>$\qquad\qquad\downarrow$<br><br>$\overline{A}=<br>\begin{pmatrix}<br>    1&amp;-2&amp;4&amp;3\\<br>    -1&amp;1&amp;-3&amp;-1\\<br>    1&amp;1&amp;1&amp;-3<br>\end{pmatrix}$<br><br>$\therefore$可以将上面的向量直接转化成增广矩阵进行求解</p>
<p>在这里将方程组用矩阵进行表示就可以抽象为<br><br>$<br>\begin{pmatrix}<br>    1&amp;-2&amp;4&amp;3\\<br>    -1&amp;1&amp;-3&amp;-1\\<br>    1&amp;1&amp;1&amp;-3<br>\end{pmatrix}<br>\begin{pmatrix}<br>    x_1\\<br>    x_2\\<br>    x_3\\<br>    x_4<br>\end{pmatrix}<br>=\begin{pmatrix}<br>    -3\\<br>    1\\<br>    -1<br>\end{pmatrix}<br>$<br><br>也就是说一组坐标经过有限次线性变换后可以将其转化成$\beta$</p>
<h3 id="向量组的线性表示"><a href="#向量组的线性表示" class="headerlink" title="向量组的线性表示"></a>向量组的线性表示</h3><blockquote>
<p>设向量组<br>$(a)\alpha_1,\alpha_2,\cdots,\alpha_s,\;<br> \;(b)\beta_1,\beta_2,\cdots,\beta_t$<br><br>若(a)中的每个向量$\alpha_i(i=1,2,\cdots,s)$ <strong>均</strong> 可由(b)线性表示，则称向量组(a)可由向量组(b)线性表示,如果两个向量组可以互相表示，则称两个向量组等价</p>
</blockquote>
<p><strong>例</strong></p>
<p>设$A，B$均为3阶矩阵，且$AB=C$</p>
<p>证明：$C$的列向量可由$A$的列向量线性表示,若矩阵$B$可逆,则$C$和$A$的列向量组等价。</p>
<p>设$A=[\alpha_1\;\alpha_2\;\alpha_3],C=[\gamma_1\;\gamma_2\;\gamma_3],B=[b_{ij}]_{3\times3}$</p>
<p>$A$和$C$都是按照按列进行划分</p>
<p>$由\;AB=C\;有$<br><br><br>$<br>[\alpha_1\;\alpha_2\;\alpha_3]<br>\left[\begin{array}{ccc}b_{11}&amp;b_{12}&amp;b_{13}\\<br>    b_{21}&amp;b_{22}&amp;b_{23}\\<br>    b_{31}&amp;b_{32}&amp;b_{33}<br>\end{array}\right]=[\gamma_1\;\gamma_2\;\gamma_3]<br>$</p>
<ul>
<li>即<br>$<br>\begin{cases}<br>b_{11}\alpha_1+b_{21}\alpha_2+b_{31}\alpha_3=\gamma_1\\<br>b_{12}\alpha_1+b_{22}\alpha_2+b_{32}\alpha_3=\gamma_2\\<br>b_{13}\alpha_1+b_{23}\alpha_2+b_{33}\alpha_3=\gamma_3\\<br>\end{cases}<br>$<br><br>$<br>\therefore\;C的列向量可由A的列向量线性表示<br>$</li>
</ul>
<p>$\because B可逆$<br><br>$\therefore A=CB^{-1}\;,记B^{-1}=[k_{ij}]_{3\times3}$<br><br><br>$<br>[\alpha_1\;\alpha_2\;\alpha_3]<br>=[\gamma_1\;\gamma_2\;\gamma_3]<br>\left[\begin{array}{ccc}<br>    k_{11}&amp;k_{12}&amp;k_{13}\\<br>    k_{21}&amp;k_{22}&amp;k_{23}\\<br>    k_{31}&amp;k_{32}&amp;k_{33}<br>\end{array}\right]<br>$</p>
<ul>
<li>即<br>$<br>\begin{cases}<br>k_{11}\gamma_1+k_{21}\gamma_2+k_{31}\gamma_3=\alpha_1\\<br>k_{12}\gamma_1+k_{22}\gamma_2+k_{32}\gamma_3=\alpha_2\\<br>k_{13}\gamma_1+k_{23}\gamma_2+k_{33}\gamma_3=\alpha_3\\<br>\end{cases}<br>$<br><br>$ \therefore A的列向量可由C的列向量线性表示$<br><br>$\therefore C$的列向量可由A的列向量线性表示</li>
</ul>
<p>因为矩阵$B$可逆</p>
<p>则$C$和$A$的列向量组等价。<br></p>
<h4 id="矩阵和向量组等价的概念区分"><a href="#矩阵和向量组等价的概念区分" class="headerlink" title="矩阵和向量组等价的概念区分"></a>矩阵和向量组等价的概念区分</h4><p>矩阵的A和B等价：A经初等变换可以变成B<br><br>向量组(a)和(b)等价：(a)和(b)可以 <strong>互相</strong> 线性表示<br><br>$\therefore$两者没有必然的联系，不要搞混</p>
<h4 id="用方程组理解向量组的线性表示"><a href="#用方程组理解向量组的线性表示" class="headerlink" title="用方程组理解向量组的线性表示"></a>用方程组理解向量组的线性表示</h4><blockquote>
<p>向量组$\beta_1\;\beta_2\;\cdots\;\beta_t$可以用向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$线性表示，<br><br>则$r(B)\leqslant r(A)$<br><br>其中$B=(\beta_1\;\beta_2\;\cdots\;\beta_t),$<br><br>$A=(\alpha_1\;\alpha_2\;\cdots\;\alpha_s)$<br><br><br>如果$r(A)=r(B)$，则两个向量组等价</p>
</blockquote>
<p>个人直观理解：<br>B的秩肯定小于A的秩，如果大于的话矩阵最后有几行就不能被表示了，<br>小于的话，最后几行就算多出来，$k_{ij}$令为0就行了<br>而两者的秩如果相等，那么两者就正好能被互相表示出来，也就是说两个向量组等价</p>
<p>证明：<br>$\beta_1\;\beta_2\;\cdots\;\beta_t$可由$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$线性表示</p>
<p>$\Leftrightarrow\;$方程组</p>
<p>$\quad\; Ax=\beta_1，Ax=\beta_2，\cdots，Ax=\beta_t$有解</p>
<p>$\Leftrightarrow\;r(A)=r(A,B)$</p>
<p>$\because r(B)\leqslant r(A,B)\;\longleftarrow\;$矩阵的秩的性质</p>
<p>$\therefore r(B)\leqslant r(A)$</p>
<h2 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h2><blockquote>
<p>$给定m个n维向量\alpha_1\;\alpha_2\;\cdots\;\alpha_m，$如果存在不全为零的数$k_1，k_2，\cdots，k_m$使得<br><br>$\qquad k_1\alpha_1+k_2\alpha_2+\cdots k_m\alpha_m=0$<br><br>则称向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_m$线性相关，否则为线性无关</p>
</blockquote>
<p>个人直观理解：<br>线性相关其实就是向量经过长度变换能够首尾相连，就是线性表示的一种特殊情况</p>
<p><strong>注意</strong>：<br>有零向量的向量组肯定线性相关</p>
<hr>
<p>线性相关同样可以用高斯消元法求出$k_1,k_2,\cdots k_m$，<br><br>因为这其实就是线性表示$\beta$为零向量，且$k_i$不全为零的一种特殊情况<br><br><br>$[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}k_1\\k_2\\ \vdots\\k_m\end{array}\right]=0$<br><br>$\Longleftrightarrow方程组$<br><br>$\qquad[\alpha_1\alpha_2\cdots\alpha_m]\left[\begin{array}{c}x_1\\x_2\\ \vdots\\x_m\end{array}\right]=0\;\;有非零解$<br><br>$\Longleftrightarrow r(\alpha_1\alpha_2\cdots\alpha_m)&lt; m$<br>$\quad m$就是方程组解的个数</p>
<p><strong>推论</strong></p>
<ol>
<li>$n个n维向量\alpha_1\;\alpha_2\;\cdots\;\alpha_n\;$相关<br><br>$\Leftrightarrow\;|\alpha_1\;\alpha_2\;\cdots\;\alpha_n|=0\;$<br><br></li>
<li>$n+1个n维向量必线性相关 \rightarrow r \leqslant n &lt; n+1$<br><br></li>
<li>如果$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$线性相关，则$\alpha_1\;\alpha_2\;\cdots\;\alpha_s\;\cdots\;\alpha_t$线性相关<br><br></li>
<li>如果向量组线性无关，增加维度仍然线性无关</li>
</ol>
<h3 id="相关定理及结论"><a href="#相关定理及结论" class="headerlink" title="相关定理及结论"></a>相关定理及结论</h3><ol>
<li>向量组$<br>\alpha_1,\alpha_2,\cdots,\alpha_s(s\leqslant2)$线性相关<br>$\Leftrightarrow\;$至少有一个向量$\alpha_i$可由其余向量$\alpha_1,\alpha_2,\cdots,\alpha_{i-1},\alpha_{i+1},\cdots,\alpha_s$线性表示<br><br></li>
<li>如果n维向量组$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关，而$\alpha_1,\alpha_2,\cdots,\alpha_s,\beta\;$线性相关，则向量$\beta\;$必能由$\alpha_1,\alpha_2,\cdots,\alpha_s$线性表示，且表示法唯一<br><br></li>
<li>如果$\alpha_1,\alpha_2,\cdots,\alpha_s$可由$\;\beta_1,\beta_2,\cdots,\beta_t\;$线性表示，且$s&gt;t$,则$\alpha_1,\alpha_2,\cdots,\alpha_s$必线性相关<br><br>推论：如果$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关，且$\alpha_1,\alpha_2,\cdots,\alpha_s$可由$\;\beta_1,\beta_2,\cdots,\beta_t\;$线性表示,则$\;s\leqslant t$（极大线性无关组）<br><br></li>
<li>$n+1$个$n$维向量必线性相关<br><br></li>
<li>初等 <strong>行变换</strong> 不改变矩阵的 <strong>列向量组</strong> 之间的线性关系；初等 <strong>列变换</strong> 不改变 <strong>行向量组</strong> 之间的线性关系<br><br></li>
<li>一个零向量线性相关，一个非零向量线性无关</li>
</ol>
<blockquote>
<p>线性表示和线性相关无关的定理和结论都是从定义出发进行推理的，推理主要是通过方程组的思想。</p>
</blockquote>
<h2 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h2><blockquote>
<p>向量组的$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的极大线性无关组中所含 <strong>向量的个数r</strong> 称为向量组的秩.<br>记为$R(\alpha_1\;\alpha_2\;\cdots\;\alpha_s)=r$<br><br>规定只有零向量的向量组的秩为0<br>三秩相等：矩阵A的秩等于A 的列向量的秩，也等于A的行向量的秩</p>
</blockquote>
<h3 id="极大线性无关组："><a href="#极大线性无关组：" class="headerlink" title="极大线性无关组："></a>极大线性无关组：</h3><blockquote>
<p>$\qquad$在向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$中，如果存在r个向量$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}$线性 <strong>无关</strong> ，<strong>再</strong> 添加任一个向量$\alpha_j,(j=1,2,\cdots,s)$,向量组$\alpha_{i1}\;\alpha_{i2}\;\cdots\alpha_{ir}\alpha_j$就线性 <strong>相关</strong> ，则称$\alpha_{i1}\;\alpha_{i2}\;\cdots\alpha_{ir}$是向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的一个极大线性无关组。<br><br><br>其实很好理解，极大线性无关组就是把向量组中挑出来一组最多线性无关的向量能够表示这个向量组的任何向量。</p>
</blockquote>
<p>定理：<br>如果$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$与$\alpha_{j1}\;\alpha_{j2}\;\cdots\;\alpha_{jt}\;$都是向量组$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的极大线性无关组，则$r=t$</p>
<p>证：<br>因为$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$是$\alpha_1\;\alpha_2\;\cdots\;\alpha_s$的极大线性无关组，</p>
<p>那么$\forall\alpha_{jp}(p=1,2,\cdots,t),$<br><br>必有$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\alpha_{jp}$线性相关；<br><br>又因$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$线性无关<br><br>那么$\alpha_{jp}(p=1,2,\cdots,t)$<br><br>能够由$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$线性表示<br><br>于是$\alpha_{j1}\;\alpha_{j2}\;\cdots\;\alpha_{jt}\;$可由$\alpha_{i1}\;\alpha_{i2}\;\cdots\;\alpha_{ir}\;$线性表示<br><br>又因为$\alpha_{j1}\;\alpha_{j2}\;\cdots\;\alpha_{jt}\;$线性无关<br><br>则有$\;t\leqslant r$.<br><br>又因为两者地位相等，同理可得$\;r\leqslant t$.<br><br>所以$r=t$</p>
<p>PA=B$\;\longrightarrow$A经过有限次行变换变成B<br><br>A的列向量与B的列向量<br>a.相同的线性相关性<br>b.相同的线性表示.</p>
<ul>
<li>例.求向量组$\alpha_1=(2,1,4,3)^T,$ $\alpha_2=(-1,1,-6,6)^T,$ $\alpha_3=(-1,-2,2,-9)^T,$ $\alpha_4=(1,1,-2,7)^T,$ $\alpha_5=(2,4,4,9)^T$的秩,一个极大线性无关组，并把其余的向量用该极大线性无关组线性表示。<br><br><br>解：构造矩阵$\;A=(\alpha_1\alpha_2\alpha_3\alpha_4\alpha_5)$作初等变换化为行最简型，有<br><br>$<br>A=\begin{pmatrix}<br>  2&amp;-1&amp;-1&amp;1&amp;2\\<br>  1&amp;1&amp;-2&amp;1&amp;4\\<br>  4&amp;-6&amp;2&amp;-2&amp;4\\<br>  3&amp;6&amp;-9&amp;7&amp;9<br>\end{pmatrix}<br>$<br><br><br>$<br>\longrightarrow<br>\begin{pmatrix}<br>  1&amp;0&amp;-1&amp;0&amp;4\\<br>  0&amp;1&amp;-1&amp;0&amp;3\\<br>  0&amp;0&amp;0&amp;1&amp;-3\\<br>  0&amp;0&amp;0&amp;0&amp;0<br>\end{pmatrix}<br>$<br><br><br>$r(\alpha_1\alpha_2\alpha_3\alpha_4\alpha_5)=3$</li>
</ul>
<p>极大线性无关组：$\alpha_1\;\alpha_2\;\alpha_4$</p>
<p>$\therefore\alpha_3=-\alpha_1-\alpha_2$</p>
<p>$\quad\alpha_5=4\alpha_1+3\alpha_2-3\alpha_4$</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>5.CSS盒子模型</title>
    <url>/2021/07/20/5-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h1><h2 id="盒子模型组成"><a href="#盒子模型组成" class="headerlink" title="盒子模型组成"></a>盒子模型组成</h2><p><strong>盒子模型：</strong> 就是把HTML页面中的 <strong>布局元素看作是一个矩形的盒子</strong>，或者说是一个盛装内容的容器。</p>
<p>CSS盒子模型包括：边框，外边距，内边距，内容。</p>
<h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><div style="width: 300px; height: 200px; border:5px solid #CCE8CF;text-align: center;line-height: 300px"><span style="width: 150px; height: 100px; border:5px solid #CCE8CF;  display:inline-block;"></span></div>

<p><strong>border</strong> 属性用于设置边框，三部分：边框宽度、样式、颜色</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">border-width</td>
<td style="text-align:left">边框粗细，单位是px</td>
</tr>
<tr>
<td style="text-align:left">border-style</td>
<td style="text-align:left">边框样式</td>
</tr>
<tr>
<td style="text-align:left">border-color</td>
<td style="text-align:left">边框颜色</td>
</tr>
</tbody>
</table>
</div>
<h3 id="边框的复合写法"><a href="#边框的复合写法" class="headerlink" title="边框的复合写法"></a>边框的复合写法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: border-width border-style border-color;</span><br></pre></td></tr></table></figure>
<p><strong>没有顺序</strong>，但一般按照此顺序书写</p>
<h3 id="边框的分开写法"><a href="#边框的分开写法" class="headerlink" title="边框的分开写法"></a>边框的分开写法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br><span class="line">只设定上边框，其余的同理</span><br></pre></td></tr></table></figure>
<h3 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h3><p><strong>border-collapse</strong> 属性控制浏览器绘制 <strong>表格边框</strong> 的方式，它控制相邻单元格的边框。</p>
<p>语法：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>: collapse;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>collapse是合并的意思</li>
<li>border-collapse: collapse;表示相邻边框合并在一起</li>
</ul>
<h3 id="边框影响盒子的实际大小"><a href="#边框影响盒子的实际大小" class="headerlink" title="边框影响盒子的实际大小"></a>边框影响盒子的实际大小</h3><p>边框会额外增加盒子的实际大小</p>
<p>解决方案:</p>
<ol>
<li>测量盒子大小的时候，不量边框</li>
<li>如果测量的时候包含了边框，则需要盒子长宽减去边框宽度</li>
</ol>
<h2 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h2><p>padding属性用于设置内边距，即边框与内容之间的距离。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">padding-left</td>
<td style="text-align:left">左内边距</td>
</tr>
<tr>
<td style="text-align:left">padding-right</td>
<td style="text-align:left">右内边距</td>
</tr>
<tr>
<td style="text-align:left">padding-top</td>
<td style="text-align:left">上内边距</td>
</tr>
<tr>
<td style="text-align:left">padding-bottom</td>
<td style="text-align:left">下内边距</td>
</tr>
</tbody>
</table>
</div>
<h3 id="padding复合写法"><a href="#padding复合写法" class="headerlink" title="padding复合写法"></a>padding复合写法</h3><p><strong>padding</strong> 属性可以有一到四个值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值的个数</th>
<th style="text-align:left">意思</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1个值 padding: 5px;</td>
<td style="text-align:left">上下左右内边距都是5px</td>
</tr>
<tr>
<td style="text-align:left">2个值 padding: 5px;10px;</td>
<td style="text-align:left">上下内边距是5px，左右内边距是10px</td>
</tr>
<tr>
<td style="text-align:left">3个值 padding: 5px 10px 20px;</td>
<td style="text-align:left">上内边距是5px，左右内边距10px，下内边距是20px</td>
</tr>
<tr>
<td style="text-align:left">4个值 padding: 5px 10px 20px 30px;</td>
<td style="text-align:left">上是5px，右是10px，下是20px，左是30px（顺时针）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="padding影响盒子实际大小"><a href="#padding影响盒子实际大小" class="headerlink" title="padding影响盒子实际大小"></a>padding影响盒子实际大小</h3><p>如果盒子已经有了宽度和高度，也就是内容和边框有了距离，添加了内边距后就会撑大盒子</p>
<p><strong>解决方法：</strong><br>如果保证盒子跟效果图大小保持一致，则 <strong>减去多出的内边距</strong> </p>
<p><strong>如果盒子本身没有指定长宽属性，则padding不会撑开盒子</strong></p>
<h2 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h2><p><strong>margin</strong> 属性用于设置外边距，即控制盒子和盒子之间的距离。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">margin-left</td>
<td style="text-align:left">左外边距</td>
</tr>
<tr>
<td style="text-align:left">margin-right</td>
<td style="text-align:left">右外边距</td>
</tr>
<tr>
<td style="text-align:left">margin-top</td>
<td style="text-align:left">上外边距</td>
</tr>
<tr>
<td style="text-align:left">margin-bottom</td>
<td style="text-align:left">下外边距</td>
</tr>
</tbody>
</table>
</div>
<p><strong>简写方式和padding一样</strong></p>
<p><strong>1.块级盒子水平居中</strong><br>外边距可以让块级盒子 <strong>水平居中</strong>，但是必须满足两个条件：</p>
<ol>
<li>盒子 <strong>必须制定宽度</strong></li>
<li>盒子左右的外边距都设置为auto<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123; <span class="attribute">width</span>: <span class="number">960px</span>; <span class="attribute">margin</span>:<span class="number">0</span> auto;&#125;</span><br></pre></td></tr></table></figure>
常见的写法，以下三种都可以：</li>
</ol>
<ul>
<li>margin-left: auto; margin-right: auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;</li>
</ul>
<p><strong>注意:</strong><br>以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 <strong>text-align: center</strong> 即可</p>
<p><strong>2.嵌套块元素垂直外边距的塌陷</strong><br>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p>
<p>解决方案：</p>
<p>1.可以为父元素定义边框</p>
<p>2.可以为父元素定义内边距</p>
<p>3.可以为父元素添加 <strong>overflow: hidden</strong></p>
<p>还有其他方法，比如浮动，固定，绝对定位的盒子不会有塌陷问题</p>
<h2 id="清除内外边距"><a href="#清除内外边距" class="headerlink" title="清除内外边距"></a>清除内外边距</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距，但是转换为块级和行内块元素就可以了</p>
<h1 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h1><p>border-radius 属性用于设置元素的外边框圆角<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: length;</span><br><span class="line">这里length可以用百分比表示，例如<span class="number">50%</span>表示是高度的<span class="number">50%</span></span><br></pre></td></tr></table></figure><br>radius 半径（圆的半径）原理：（椭）圆与边框的交集形成圆角效果</p>
<p>border-radius可以跟多个数值1~4个</p>
<h1 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h1><p><strong>box-shadow</strong> 属性为盒子添加阴影<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset（outset是默认值不能写）;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h-shadow</td>
<td style="text-align:left">必须，水平阴影的位置，允许负值</td>
</tr>
<tr>
<td style="text-align:left">v-shadow</td>
<td style="text-align:left">必须，垂直阴影的位置，允许负值</td>
</tr>
<tr>
<td style="text-align:left">blur</td>
<td style="text-align:left">可选，模糊距离</td>
</tr>
<tr>
<td style="text-align:left">spread</td>
<td style="text-align:left">可选，阴影的尺寸</td>
</tr>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">可选，阴影的颜色</td>
</tr>
<tr>
<td style="text-align:left">inset</td>
<td style="text-align:left">可选，将外部阴影（outset）改为内部阴影</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意</strong><br>1.默认的是外阴影（outset）,但不可以写这个单词，否则阴影无效</p>
<p>2.盒子阴影不占用空间，不会影响其他盒子排列</p>
<h1 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h1><p>语法：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-shadow blur color</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>5.查找</title>
    <url>/2021/08/08/5-%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><blockquote>
<p><strong>查找表</strong> 是由同一类型的数据元素（或记录）构成的 <strong>集合</strong></p>
</blockquote>
<ul>
<li><strong>关键字</strong>：用来表示一个数据元素（或记录）的某个数据项的值<ul>
<li>主关键字：可唯一的标识一个记录的关键字</li>
<li>次关键字：用以识别若干记录的关键字</li>
</ul>
</li>
</ul>
<p>对查找表经常进行的 <strong>操作</strong>：</p>
<ul>
<li><strong>查询</strong> 某个“特定的”数据元素是否在查找表中</li>
<li><strong>检索</strong> 某个“特定的”数据元素的各种属性</li>
<li>在查找表中 <strong>插入</strong> 一个数据元素</li>
<li><strong>删除</strong> 查找表中的某个数据元素</li>
</ul>
<span id="more"></span>
<p>查找表可分为两类：</p>
<ul>
<li>静态查找表：仅作“查询”（检索）操作的查找表</li>
<li>动态查找表：作“插入”和“删除”操作的查找表</li>
</ul>
<p><strong>查找算法的评价指标</strong>：<br>关键字的平均比较次数，也称 <strong>平均查找长度ASL</strong></p>
<script type="math/tex; mode=display">ASL = \sum\limits_{i=1}^np_ic_i</script><p>n：记录的个数</p>
<p>$p_i$：查找第i个记录的概率（通常认为$p_i=\displaystyle\frac 1n$）</p>
<p>$c_i$：找到第i个记录所需的比较次数</p>
<h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="顺序查找（线性查找）"><a href="#顺序查找（线性查找）" class="headerlink" title="顺序查找（线性查找）"></a>顺序查找（线性查找）</h2><p>应用范围：</p>
<ul>
<li>顺序表或线性链表表示的 <strong>静态查找表</strong></li>
<li>表内元素之间 <strong>无序</strong></li>
</ul>
<p>数据元素类型定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;<span class="comment">//关键字域</span></span><br><span class="line">    ……          <span class="comment">//其他域</span></span><br><span class="line">&#125;ElemType;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *R;<span class="comment">//表基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;<span class="comment">//Sequential Search Table</span></span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br></pre></td></tr></table></figure>
<p>顺序查找算法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(ST.R[i].key==key) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其他形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.R[i].key != key;i--)</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>改进</strong>：把待查关键字key存入表头（“哨兵”、“监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    ST.R[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.R[i].key!=key;i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><blockquote>
<p>每次将待查记录所在区间缩小一半</p>
</blockquote>
<p><strong>非递归算法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> Search <span class="title">Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    low = <span class="number">1</span>;high = ST.lenght;<span class="comment">//置区间初值</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.R[mid].key == key) <span class="keyword">return</span> mid;<span class="comment">//找到待查元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.R[mid].key)<span class="comment">//缩小查找区间</span></span><br><span class="line">            high = mid<span class="number">-1</span>;        <span class="comment">//继续在前半区间进行查找</span></span><br><span class="line">        <span class="keyword">else</span> low = mid+<span class="number">1</span>;       <span class="comment">//继续在后半区间进行查找  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//顺序表中不存在待查元素</span></span><br><span class="line">&#125;<span class="comment">//Search_Bin</span></span><br></pre></td></tr></table></figure></p>
<p><strong>递归算法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查找不到时返回0</span></span><br><span class="line">    mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==ST.elem[mid],key) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;ST.elem[mid].key)</span><br><span class="line">        <span class="built_in">Search_Bin</span>(SSTable ST,KeyType key,<span class="keyword">int</span> low,<span class="keyword">int</span> high);<span class="comment">//递归，在前半区间进行查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Search_Bin</span>(SSTable ST,KeyType key,<span class="keyword">int</span> mid,<span class="keyword">int</span> high);<span class="comment">//递归，在后半区间进行查找        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><blockquote>
<p>索引顺序查找 </p>
</blockquote>
<h1 id="数表的查找"><a href="#数表的查找" class="headerlink" title="数表的查找"></a>数表的查找</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>定义</strong>：<br>二叉排序树或是空树，或是满足如下性质的二叉树：</p>
<ul>
<li>若其 <strong>左子树</strong> 非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若其 <strong>右子树</strong> 非空，则右子树上所有结点的值均大于等于根结点的值</li>
<li>其左右子树本身又各是一棵二叉排序树</li>
</ul>
<p>对二叉排序树中序遍历，值递增</p>
<p><strong>二叉排序树的存储结构</strong>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">    InfoType otherinfo;<span class="comment">//其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;<span class="comment">//定义二叉排序树</span></span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>二叉排序树递归查找</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iT||key==T-&gt;data.key) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild,key);<span class="comment">//在左子树中继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild,key);<span class="comment">//在右子树中继续查找</span></span><br><span class="line">&#125;<span class="comment">//SearchBST</span></span><br></pre></td></tr></table></figure></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>若二叉排序树为空，则插入结点作为根节点插入到空树中</p>
<p>否则，继续在其左、右子树上查找</p>
<ul>
<li>树中已有，不再插入</li>
<li>树中没有<ul>
<li>查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li>
</ul>
</li>
</ul>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除后仍然保持是二叉排序树</p>
<p>三种情况：</p>
<ul>
<li>在叶子结点</li>
<li>有左孩子或右孩子</li>
<li>左右孩子都有</li>
</ul>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 (AVL)"></a>平衡二叉树 (AVL)</h2><p>一棵平衡二叉树或者空树，或者具有下列性质的二叉树：</p>
<ul>
<li>左子树与右子树的高度之差的绝对值 <strong>小于等于1</strong>；</li>
<li>左子树和右子树也是平衡二叉树</li>
</ul>
<p>为了方便起见，给每个结点附加一个数字，给出 <strong>该结点左子树与右子树的高度差</strong>，这个数字称为结点的 <strong>平衡因子</strong>（BF）</p>
<script type="math/tex; mode=display">平衡因子 = 节点左子树的深度 - 节点右子树的深度</script><h3 id="失衡二叉排序树的分析与调整"><a href="#失衡二叉排序树的分析与调整" class="headerlink" title="失衡二叉排序树的分析与调整"></a>失衡二叉排序树的分析与调整</h3><p>平衡调整的四种类型：<br><strong>LL型</strong></p>
<p><strong>LR型</strong></p>
<p><strong>RL型</strong></p>
<p><strong>RR型</strong></p>
<h1 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h1><h2 id="散列表基本概念"><a href="#散列表基本概念" class="headerlink" title="散列表基本概念"></a>散列表基本概念</h2><blockquote>
<p>基本思想：记录的存储位置与关键字之间存在对应关系</p>
</blockquote>
<p>优点：查找效率高</p>
<p>缺点：空间效率低</p>
<h2 id="散列表的若干术语"><a href="#散列表的若干术语" class="headerlink" title="散列表的若干术语"></a>散列表的若干术语</h2><p><strong>散列方法（杂凑法）</strong><br>选取某个函数，依该函数按关键字 <strong>计算元素的存储位置</strong>，并按此存放</p>
<p>查找时，<strong>由同一个函数对给定值k计算地址</strong>，将k与地址单元中元素关键码进行比对，确定查找是否成功</p>
<p><strong>散列函数（杂凑函数）</strong>：散列方法中使用的 <strong>转换函数</strong></p>
<p><strong>散列表（杂凑表）</strong>：按上述思想构造的表</p>
<p>散列函数：H(key)=k</p>
<p><strong>冲突</strong>：不同的关键码映射到同一个散列地址</p>
<p><strong>同义词</strong>：具有相同函数值的多个关键字</p>
<h2 id="散列表的构造方法"><a href="#散列表的构造方法" class="headerlink" title="散列表的构造方法"></a>散列表的构造方法</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p><strong>Hash(key)=a·key + b</strong></p>
<p>优点：以关键码key的某个线性函数值为散列地址，不会产生冲突</p>
<p>缺点：要占用连续空间，空间效率低</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p><strong>Hash(key)= key mod p</strong></p>
<p>技巧：设表长为m，<strong>取p&leqslant;m 且为质数</strong></p>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><h3 id="开地址法"><a href="#开地址法" class="headerlink" title="开地址法"></a>开地址法</h3><p>基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>基本思想：相同散列地址的记录链成一单链表</p>
<p><img style="transform=scale(0.7)" src="/2021/08/08/5-%E6%9F%A5%E6%89%BE/pic1.png"></p>
<p>优点：非同义词不会冲突，无“聚集”现象</p>
<h2 id="几点结论"><a href="#几点结论" class="headerlink" title="几点结论"></a>几点结论</h2><ul>
<li>散列表技术具有很好的平均性能，优于一些传统的技术</li>
<li>链地址法优于开地址法</li>
<li>除留余数法作散列函数优于其他类型函数</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.通用函数</title>
    <url>/2021/07/04/5-%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。</p>
<p><strong>一元ufunc</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abs、fabs</td>
<td style="text-align:left">计算整数、浮点数或复数的绝对值，对于非复数值，可以用更快的fabs</td>
</tr>
<tr>
<td style="text-align:left">sqrt</td>
<td style="text-align:left">计算各元素的平方根，相当于arr ** 0.5</td>
</tr>
<tr>
<td style="text-align:left">square</td>
<td style="text-align:left">计算元素的平方，相当于arr ** 2</td>
</tr>
<tr>
<td style="text-align:left">exp</td>
<td style="text-align:left">计算各元素的指数$e^x$</td>
</tr>
<tr>
<td style="text-align:left">log、log10</td>
<td style="text-align:left">分别为自然对数、以10为底的对数</td>
</tr>
<tr>
<td style="text-align:left">sign</td>
<td style="text-align:left">计算各元素的正负号：1（正），0（零），-1（负）</td>
</tr>
<tr>
<td style="text-align:left">ceil</td>
<td style="text-align:left">计算各元素的ceiling值，即大于等于该值的最小整数</td>
</tr>
<tr>
<td style="text-align:left">floor</td>
<td style="text-align:left">计算各元素的floor值，即小于等于该值的最大整数</td>
</tr>
<tr>
<td style="text-align:left">rint</td>
<td style="text-align:left">将各元素值四舍五入到最接近的整数，保留dtype</td>
</tr>
<tr>
<td style="text-align:left">modf</td>
<td style="text-align:left">将数组的小数和整数部分以两个独立数组的形式返回</td>
</tr>
<tr>
<td style="text-align:left">isnan</td>
<td style="text-align:left">返回一个表示“哪些值是NaN”的布尔型数组</td>
</tr>
<tr>
<td style="text-align:left">isfinite、isinf</td>
<td style="text-align:left">分别返回一个元素“哪些元素是有穷的”或“哪些元素是无穷的”的布尔型数组</td>
</tr>
<tr>
<td style="text-align:left">cos、cosh、sin、sinh、tan、tanh</td>
<td style="text-align:left">普通型和双曲型三角函数</td>
</tr>
<tr>
<td style="text-align:left">arccos、arccosh、arcsin、arcsinh…</td>
<td style="text-align:left">反三角函数</td>
</tr>
<tr>
<td style="text-align:left">logical_not</td>
<td style="text-align:left">计算各元素not x的真值，相当于~arr</td>
</tr>
</tbody>
</table>
</div>
<p><strong>二元ufunc</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add</td>
<td style="text-align:left">将数组中对应的元素相加</td>
</tr>
<tr>
<td style="text-align:left">subtract</td>
<td style="text-align:left">从第一个数组中减去第二个数组中的元素</td>
</tr>
<tr>
<td style="text-align:left">multiply</td>
<td style="text-align:left">数组元素相乘</td>
</tr>
<tr>
<td style="text-align:left">divide、floor_divide</td>
<td style="text-align:left">除法或向下圆整除法（丢弃余数）</td>
</tr>
<tr>
<td style="text-align:left">power</td>
<td style="text-align:left">对第一个数组中的元素A，根据第二个数组中的相应元素B，计算$A^B$</td>
</tr>
<tr>
<td style="text-align:left">maximum、fmax</td>
<td style="text-align:left">元素级的最大值计算，fmax将忽略NaN</td>
</tr>
<tr>
<td style="text-align:left">minmum、fmin</td>
<td style="text-align:left">元素级的最小值计算，fmin将忽略NaN</td>
</tr>
<tr>
<td style="text-align:left">mod</td>
<td style="text-align:left">元素级的求模运算（除法的余数）</td>
</tr>
<tr>
<td style="text-align:left">copysign</td>
<td style="text-align:left">将第二个数组中的符号复制给第一个数组中的值</td>
</tr>
<tr>
<td style="text-align:left">greater、greater_equal、less、less_equal、equal、not_equal</td>
<td style="text-align:left">执行元素级的比较运算符，相当于中缀运算符&gt;、&gt;=、&lt;、&lt;=、==、!=</td>
</tr>
<tr>
<td style="text-align:left">logical_and、loagical_or、logical_xor</td>
<td style="text-align:left">执行元素级的真值逻辑运算，相当于中缀运算符&amp;、&#124; 、^</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>5.向量空间</title>
    <url>/2021/06/21/5.%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><blockquote>
<p>{n维向量；+，数乘}</p>
</blockquote>
<h2 id="向量空间的子空间"><a href="#向量空间的子空间" class="headerlink" title="向量空间的子空间"></a>向量空间的子空间</h2><p>W是n维向量的非空集合，且</p>
<p>(1) $\forall\alpha,\beta\in W\;\Rightarrow\;\alpha+\beta\in W$<br><br>(2) $\forall\alpha\in W,\forall k\;\Rightarrow\;k\alpha\in W$</p>
<p>则称W是n维向量空间的子空间</p>
<h2 id="向量空间的基和维数"><a href="#向量空间的基和维数" class="headerlink" title="向量空间的基和维数"></a>向量空间的基和维数</h2><p>$\quad$如果向量空间V中的向量$\alpha_1\alpha_2\cdots\alpha_m$<br><br>满足：<br>$\qquad$(1)$\alpha_1\alpha_2\cdots\alpha_m$线性无关;<br><br>$\qquad$(2)V中任意向量$\beta$均可由$\alpha_1\alpha_2\cdots\alpha_m$线性表示，即<br><br>$\qquad\quad x_1\alpha_1+x_2\alpha_2+\cdots+x_m\alpha_m=\beta$</p>
<p>$\qquad$则称$\alpha_1\alpha_2\cdots\alpha_m$是向量空间V的基$\;\longrightarrow\;$其实就是向量组里极大无关组的概念</p>
<p>$\qquad$m称为向量空间的维数，称V是m维向量空间</p>
<h2 id="过渡矩阵"><a href="#过渡矩阵" class="headerlink" title="过渡矩阵"></a>过渡矩阵</h2><p>如果$\;\alpha_1,\alpha_2,\alpha_3\;$与$\;\beta_1,\beta_2,\beta_3\;$是$R^3$的两个基，<br></p>
<p>设<br>$<br>\beta_1={\large c}_{11}\alpha_1+{\large c}_{21}\alpha_2+{\large c}_{31}\alpha_3$</p>
<p>$\beta_2={\large c}_{12}\alpha_1+{\large c}_{22}\alpha_2+{\large c}_{32}\alpha_3$</p>
<p>$\beta_3={\large c}_{13}\alpha_1+{\large c}_{23}\alpha_2+{\large c}_{33}\alpha_3$<br><br><br>$<br>\begin{aligned}<br>即\;\;<br>[\beta_1\;\beta_2\;\beta_3]<br>&amp;=[\alpha_1\;\alpha_2\;\alpha_3]<br>\begin{bmatrix}<br>{\large c}_{11}&amp;{\large c}_{12}&amp;{\large c}_{13}\\<br>{\large c}_{21}&amp;{\large c}_{22}&amp;{\large c}_{23}\\<br>{\large c}_{31}&amp;{\large c}_{32}&amp;{\large c}_{33}<br>\end{bmatrix}\\<br>\\<br>&amp;=[\alpha_1\;\alpha_2\;\alpha_3]C<br>\end{aligned}<br>$<br><br><br>称矩阵C为由基$\;\alpha_1,\alpha_2,\alpha_3\;$到基$\;\beta_1,\beta_2,\beta_3\;$的过渡矩阵</p>
<h3 id="坐标变换公式"><a href="#坐标变换公式" class="headerlink" title="坐标变换公式"></a>坐标变换公式</h3><p>设$\;\alpha_1,\alpha_2,\alpha_3\;$与$\;\beta_1,\beta_2,\beta_3\;$是$R^3$的两个基<br>且$(\beta_1\;\beta_2\;\beta_3)=(\alpha_1\;\alpha_2\;\alpha_3)C$<br><br>若向量$\gamma$在这两个基下的坐标分别是</p>
<p>$(x_1,x_2,x_3)^T\;与\;(y_1,y_2,y_3)^T$</p>
<p>即<br>$\gamma=x_1\alpha_1+x_2\alpha_2+x_3\alpha_3=(\alpha_1\;\alpha_2\;\alpha_3)<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3<br>\end{bmatrix}$</p>
<p>$\gamma=y_1\beta_1+y_2\beta_2+y_3\beta_3=(\beta_1\;\beta_2\;\beta_3)<br>\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}$</p>
<p>那么<br>$<br>\qquad\begin{aligned}<br>(\alpha_1\;\alpha_2\;\alpha_3)<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3<br>\end{bmatrix}<br>&amp;=<br>(\beta_1\;\beta_2\;\beta_3)<br>\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}\\<br>&amp;=(\alpha_1\;\alpha_2\;\alpha_3)<br>C\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}<br>\end{aligned}<br>$<br><br></p>
<hr>
<p>$\therefore\;\;<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3<br>\end{bmatrix}=<br>C\begin{bmatrix}<br>y_1\\<br>y_2\\<br>y_3<br>\end{bmatrix}<br>\longrightarrow$坐标变换公式<br><br>$\; x=Cy$</p>
<p>向量空间是属于n维向量中的内容，虽然目前知道了一些基本概念，但对n维空间理解的并不好，因此单独拿出来，后面进行单独的理解学习，并对笔记进行扩充</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>6.CSS浮动</title>
    <url>/2021/07/20/6-CSS%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div style="width: 200px;height: 200px;"><div style="float: left;width: 100px;height: 100px;background: rgba(0,0,0,.1);"></div><div style="float: right;width: 100px;height: 100px;background: rgba(0,0,0,.3);"></div><div style="float: left;width: 100px;height: 100px;background: rgba(0,0,0,.5);"></div><div style="float: right;width: 100px;height: 100px;background: rgba(0,0,0,.7);"></div></div>

<h1 id="浮动的用法"><a href="#浮动的用法" class="headerlink" title="浮动的用法"></a>浮动的用法</h1><p><strong>float</strong> 属性用于创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘</p>
<p>语法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">float</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left">元素不浮动（默认）</td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">元素向左浮动</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">元素向右浮动</td>
</tr>
</tbody>
</table>
</div>
<h1 id="浮动的特性"><a href="#浮动的特性" class="headerlink" title="浮动的特性"></a>浮动的特性</h1><p>1.浮动元素会脱离标准流（脱标）</p>
<p>2.浮动的元素会一行内显示并且元素顶部对齐</p>
<p>3.浮动的元素会具有行内块元素的特性</p>
<hr>
<p>设置了浮动（float）的元素 <strong>最重要</strong> 的特性：</p>
<p>1.脱离标准流的控制（浮）移动到指定位置（动），（俗称脱标）</p>
<p>2.浮动的盒子不再保留原先位置</p>
<h1 id="浮动布局的注意点"><a href="#浮动布局的注意点" class="headerlink" title="浮动布局的注意点"></a>浮动布局的注意点</h1><p><strong>1.浮动和标准流的父盒子搭配</strong><br>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</p>
<p><strong>2.一个元素浮动了，理论上其余的兄弟元素也要浮动</strong><br>一个元素里面有多个子盒子，如果其中一个盒子浮动了 ，那么其他兄弟也应该浮动，否则会出现错误。</p>
<p>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。</p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>如果 <strong>父类盒子没有高度</strong>，由于子盒子浮动不占有位置，最后父级盒子高度为0，那么就会影响下面的标准流盒子，从而影响排版。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1.<strong>额外标签法</strong> 也称为隔离法，是W3C推荐的做法。</p>
<p>2.<strong>父级</strong> 添加overflow属性</p>
<p>3.<strong>父级</strong> 添加after伪元素</p>
<p>4.<strong>父级</strong> 添加双伪元素</p>
<p>策略：<strong>闭合浮动</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">clear</span>: 属性值 &#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">不允许有左侧浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td style="text-align:left">both</td>
<td style="text-align:left">同时清除左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
</div>
<p>实际工作中几乎只用 <strong>clear: both;</strong></p>
<h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><p>额外标签法就是在浮动元素末尾添加一个空的标签。例如&lt;div style=”clear: both”&gt;&lt;/div&gt;,或者其他标签（如&lt;br/&gt;等）。</p>
<ul>
<li>优点：通俗易懂，书写方便</li>
<li>缺点：添加许多无意义的标签，结构化较差<br><strong>注意:这个新的空标签必须是块级元素</strong></li>
</ul>
<h3 id="父级添加overflow"><a href="#父级添加overflow" class="headerlink" title="父级添加overflow"></a>父级添加overflow</h3><p>可以给 <strong>父级</strong> 添加overflow属性，将其属性值设置为hidden、auto或scroll</p>
<ul>
<li>优点：代码简洁</li>
<li>缺点：无法显示溢出部分</li>
</ul>
<h3 id="after伪元素法"><a href="#after伪元素法" class="headerlink" title=":after伪元素法"></a>:after伪元素法</h3><p>:after方式是额外标签的升级版，也是<strong>给父元素添加</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;<span class="comment">/*IE6、7专有*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优点：没有增加标签，结构更简单</li>
<li>缺点：不照顾低版本浏览器</li>
<li>代表网站：百度、淘宝网、网易等</li>
</ul>
<h3 id="双伪元素清除浮动"><a href="#双伪元素清除浮动" class="headerlink" title="双伪元素清除浮动"></a>双伪元素清除浮动</h3><p>也是<strong>给父元素添加</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before,.clearfix:after &#123;</span><br><span class="line">    content:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优点：代码更简洁</li>
<li>缺点：不照顾低版本浏览器</li>
<li>代表网站：小米、腾讯等</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>6.线性代数（numpy）</title>
    <url>/2021/07/05/6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88numpy%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="矩阵乘法-三种"><a href="#矩阵乘法-三种" class="headerlink" title="矩阵乘法(三种)"></a>矩阵乘法(三种)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">y = np.array([[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">x.dot(y)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.</span></span><br><span class="line">np.dot(x,y) </span><br></pre></td></tr></table></figure>
<pre><code>array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.</span></span><br><span class="line">x@y</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
</code></pre><h2 id="np-linalg"><a href="#np-linalg" class="headerlink" title="np.linalg"></a>np.linalg</h2><p>这里面有一组标准的矩阵分解运算以及诸如求逆和行列式之类的</p>
<p><strong>常用的线性代数的函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">diag</td>
<td style="text-align:left">以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一堆数组转换为方阵（非对角线元素为0）</td>
</tr>
<tr>
<td style="text-align:left">dot</td>
<td style="text-align:left">矩阵乘法</td>
</tr>
<tr>
<td style="text-align:left">trace</td>
<td style="text-align:left">计算对角线元素的和</td>
</tr>
<tr>
<td style="text-align:left">det</td>
<td style="text-align:left">计算矩阵行列式</td>
</tr>
<tr>
<td style="text-align:left">eig</td>
<td style="text-align:left">计算方阵的特征值和特征向量</td>
</tr>
<tr>
<td style="text-align:left">inv</td>
<td style="text-align:left">计算方阵的逆</td>
</tr>
<tr>
<td style="text-align:left">pinv</td>
<td style="text-align:left">计算矩阵的Moore-Penrose伪逆</td>
</tr>
<tr>
<td style="text-align:left">qr</td>
<td style="text-align:left">计算QR分解</td>
</tr>
<tr>
<td style="text-align:left">svd</td>
<td style="text-align:left">计算奇异值分解(SVD)</td>
</tr>
<tr>
<td style="text-align:left">solve</td>
<td style="text-align:left">解线性方程组Ax = b,其中A为一个方阵</td>
</tr>
<tr>
<td style="text-align:left">lstsq</td>
<td style="text-align:left">计算Ax=b的最小二乘解</td>
</tr>
</tbody>
</table>
</div>
<p><strong>例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [4, 5, 6],
       [9, 4, 5]])
</code></pre><ul>
<li>np.diag</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(A)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 5, 5])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.diag(np.diag(A))</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 0, 0],
       [0, 5, 0],
       [0, 0, 5]])
</code></pre><ul>
<li>np.trace</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.trace(A)</span><br></pre></td></tr></table></figure>
<pre><code>11
</code></pre><ul>
<li>np.linalg.det</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.det(A)</span><br></pre></td></tr></table></figure>
<pre><code>-17.999999999999996
</code></pre><ul>
<li>np.linalg.inv</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.inv(A)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.05555556, -0.11111111,  0.16666667],
       [-1.88888889,  1.22222222, -0.33333333],
       [ 1.61111111, -0.77777778,  0.16666667]])
</code></pre><ul>
<li>np.linalg.eig</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eig(A)</span><br></pre></td></tr></table></figure>
<pre><code>(array([12.76913689, -2.36514612,  0.59600923]),
 array([[-0.28796344, -0.47551397,  0.10554127],
        [-0.67379758, -0.38580557, -0.83390437],
        [-0.68049532,  0.79059505,  0.54172368]]))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eigvals(A)</span><br></pre></td></tr></table></figure>
<pre><code>array([12.76913689, -2.36514612,  0.59600923])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eig(A)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.28796344, -0.47551397,  0.10554127],
       [-0.67379758, -0.38580557, -0.83390437],
       [-0.68049532,  0.79059505,  0.54172368]])
</code></pre><ul>
<li>np.linalg.solve</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">np.linalg.solve(A,B)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.22222222, -1.44444444,  1.55555556])
</code></pre><p>简单的使用了一下Numpy中关于线性代数的函数,也发现了一些问题，就是求行列式的值存在精度丢失，目前接触到的应用大概就这么多，当然后面会阅读一些文档对这一部分内容进行扩充</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>6.特征值与特征向量</title>
    <url>/2021/06/22/6.%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="向量的内积与正交矩阵"><a href="#向量的内积与正交矩阵" class="headerlink" title="向量的内积与正交矩阵"></a>向量的内积与正交矩阵</h1><h2 id="向量的内积"><a href="#向量的内积" class="headerlink" title="向量的内积"></a>向量的内积</h2><blockquote>
<p>设$\alpha=(a_1,a_2,\cdots,a_n)^T$ ,$\beta=(b_1,b_2,\cdots,b_n)$<br><br>令$[\alpha,\beta]=\large\sum\limits_{k=1}^{n}a_kb_k$<br><br>称为向量$\;\alpha\;$和$\;\beta\;$的内积</p>
</blockquote>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>$[\alpha,\beta]=[\beta,\alpha]$</li>
<li>$[\alpha+\beta,\gamma]=[\alpha,\gamma]+[\beta,\gamma]$</li>
<li>$[k\alpha,\beta]=k[\alpha,\beta]$</li>
<li>$[\alpha,\alpha]\geqslant0\;且\;[\alpha,\alpha]=0\;\Leftrightarrow\;\alpha=0$</li>
<li>柯西不等式$\;[\alpha,\beta]^2\leqslant[\alpha,\alpha][\beta,\beta]$<br><br>当且仅当$\;\alpha,\beta\;$线性相关时取等</li>
</ol>
<p>如果$\;[\alpha,\beta]=0\;$称$\;\alpha\;$与$\;\beta\;$正交</p>
<p><strong>柯西不等式的证明：</strong></p>
<p>$<br>\begin{aligned}<br>&amp;a. 若\;\alpha,\beta\;线性无关,\;\forall x\in R都有x\alpha+\beta\neq 0\\<br>&amp;\quad\; [x\alpha+\beta,x\alpha+\beta]\\<br>&amp;=[\alpha,\alpha]x^2+2[\alpha,\beta]x+[\beta,\beta]&gt;0\\<br>&amp;作为x的二次函数，对\forall x，f(x)&gt;0\\<br>&amp;故\;\;[2[\alpha,\beta]]^2-4[\alpha,\alpha][\beta,\beta]&lt;0\\<br>&amp;\therefore\;[\alpha,\beta]^2&lt;||\alpha||\cdot||\beta||\\<br>\end{aligned}<br>$</p>
<p>$<br>\begin{aligned}<br>&amp;b. 若\;\alpha,\beta\;线性相关\\<br>&amp;当\;\alpha=0（或\;\beta=0）\\<br>&amp;\qquad[\alpha,\beta]^2=||\alpha||\cdot||\beta||\\<br>&amp;当\beta=k\alpha\neq0\\<br>&amp;\qquad[\alpha,\beta]^2\\<br>&amp;=[\alpha,k\alpha]^2\\<br>&amp;=k^2[\alpha,\alpha]^2\\<br>&amp;=[\alpha,\alpha]\cdot[k\alpha,k\alpha]\\<br>&amp;=||\alpha||\cdot||\beta||<br>\end{aligned}<br>$</p>
<h2 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h2><blockquote>
<p>$||\alpha||=\sqrt{[\alpha,\alpha]}=\sqrt{\sum\limits_{k=1}^n{\large a}_k^2}$</p>
</blockquote>
<p>如果$||\alpha||=1\;$称$\;\alpha\;$为单位向量<br><br>$\displaystyle\frac{1}{||\alpha||}\alpha\;\longrightarrow$单位化<br><br></p>
<hr>
<p>定理：若n维向量$\alpha_1,\alpha_2,\cdots,\alpha_r$是一组两两正交的非零向量，<br>则$\alpha_1,\alpha_2,\cdots,\alpha_r$线性无关。</p>
<p>证：设$k_1\alpha_1+k_2\alpha_2+\cdots+k_r\alpha_r=0$</p>
<p>用$\alpha_1$对等式两边作内积</p>
<p>$\quad[\alpha_1,k_1\alpha_1+k_2\alpha_2+\cdots+k_r\alpha_r]=[\alpha_1,0]$</p>
<p>$\quad k_1[\alpha_1,\alpha_1]+\cdots+k_r[\alpha_1,\alpha_r]=0$</p>
<p>$\quad$因$\;\alpha_1\neq0,[\alpha_1,\alpha_1]&gt;0$<br>$\quad$而$\;[\alpha_1,\alpha_i]=0,i\geqslant2$</p>
<p>$\quad\therefore\;k_1[\alpha_1,\alpha_1]=0\;$必有$k_1=0$</p>
<p>$\quad$同理$\;k_2=0,\cdots,k_r=0$</p>
<h2 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h2><p>设$\alpha_1,\alpha_2,\alpha_3\;$线性无关</p>
<p>令$\quad\beta_1=\alpha_1$</p>
<p>$\quad\beta_2=\alpha_2-\displaystyle\frac{[\alpha_2\;\beta_1]}{[\beta_1\;\beta_1]}\beta_1$</p>
<p>$\quad\beta_3=\alpha_3-\displaystyle\frac{[\alpha_3\;\beta_1]}{[\beta_1\;\beta_1]}\beta_1-\displaystyle\frac{[\alpha_3\;\beta_2]}{[\beta_2\;\beta_2]}\beta_2$</p>
<p>则$\;\beta_1\;\beta_2\;\beta_3\;$两两正交<br><br><br>再单位化<br>$\qquad\gamma_1=\displaystyle\frac{\beta_1}{||\beta_1||}$,<br>$\gamma_2=\displaystyle\frac{\beta_2}{||\beta_2||}$,<br>$\gamma_3=\displaystyle\frac{\beta_3}{||\beta_3||}$</p>
<p>这样其实就相当于构建直角坐标系</p>
<h2 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h2><blockquote>
<p>设$A$是n阶矩阵，满足<br>$AA^T=A^TA=E$,<br>则称$A$为正交矩阵</p>
</blockquote>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>$A$是正交矩阵$\;\Leftrightarrow\;A^T=A^{-1}$</p>
</li>
<li><p>$A=(\alpha_1\;\alpha_2\;\alpha_3)$是正交矩阵<br>$\quad\Leftrightarrow\;\alpha_1,\alpha_2,\alpha_3\;$都是单位向量，且两两正交<br><br>证：<br>$<br>\begin{aligned}<br>A^TA<br>&amp;=\begin{bmatrix}<br> \alpha_1^T\\<br> \alpha_2^T\\<br> \alpha_3^T<br>\end{bmatrix}<br>[\alpha_1\;\alpha_2\;\alpha_3]\\<br>&amp;=\begin{bmatrix}    \alpha_1^T\alpha_1&amp;\alpha_1^T\alpha_2&amp;\alpha_1^T\alpha_3\\    \alpha_2^T\alpha_1&amp;\alpha_2^T\alpha_2&amp;\alpha_2^T\alpha_3\\<br>\alpha_3^T\alpha_1&amp;\alpha_3^T\alpha_2&amp;\alpha_3^T\alpha_3<br>\end{bmatrix}<br>=\begin{bmatrix}<br> 1&amp;0&amp;0\\<br> 0&amp;1&amp;0\\<br> 0&amp;0&amp;1<br>\end{bmatrix}\\<br>&amp;=E<br>\end{aligned}<br>$<br><br></p>
</li>
<li>如果$A$是正交矩阵，则$|A|$=1或-1<br><br></li>
<li>若$A,B$都是正交矩阵，则$AB$也是正交矩阵<br><br>证：<br>$(AB)(AB)^T=A(BB^T)A^T=AA^T=E$</li>
</ol>
<h3 id="规范正交基"><a href="#规范正交基" class="headerlink" title="规范正交基"></a>规范正交基</h3><p>设$e_1,e_2,\cdots,e_n$是向量空间的一个基，<br><br>如果<br>$\qquad[e_i,e_j]=<br>\begin{cases}<br>    1\qquad i=j\\<br>     0\qquad i\neq j<br>\end{cases}<br>$</p>
<p>$\qquad$则称$e_1,e_2,\cdots,e_n$为规范正交基。</p>
<p><strong>例</strong></p>
<p>$<br>A=\begin{bmatrix}<br>    1&amp;0&amp;0&amp;-2\\<br>    0&amp;1&amp;0&amp;1<br>\end{bmatrix}<br>$</p>
<p>$Ax=0\;$基础解系</p>
<p>$\eta_1=(0,0,1,0)^T,\eta_2=(2,-1,0,1)^T$</p>
<p>解空间的基：$\eta_1,\eta_2$</p>
<p>解空间维数：2</p>
<p>规范正交基：</p>
<p>$(0,0,1,0)^T,{\large\frac{1}{\sqrt{6}}}(2,-1,0,1)^T$</p>
<h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><blockquote>
<p>设A是n阶矩阵，<span class="mark">$\alpha$是n维非0列向量</span>，满足<br>$\qquad A\alpha=\lambda\alpha$<br><br>则称:<br>$\lambda$是矩阵$A$的特征值<br><br>$\alpha$是矩阵$A$对应于特征值$\lambda$的特征向量.</p>
</blockquote>
<p>$A\alpha=\lambda\alpha\;$这个等式个人直观理解：特征向量$\alpha$经过A矩阵变换后等于特征向量$\alpha$的$\lambda$倍</p>
<ol>
<li>如果$\alpha$是$A$对应于特征值$\lambda$的特征向量，<br><br>那么只要$k\neq0$,则$k\alpha$仍是$A$对应于特征值$\lambda$的特征向量<br><br>$\because\;$如果$\;A\alpha=\lambda\alpha,\;\alpha\neq0$<br><br>$\quad$那么$A(k\alpha)=kA\alpha=k(\lambda\alpha)=\lambda(k\alpha)$<br><br></li>
<li>若$\alpha_1,\alpha_2$都是矩阵$A$关于特征值$\lambda$的特征向量，<br><br>则$\;\forall k_1,k_2$，当$k_1\alpha_1+k_2\alpha_2\neq0$时，<br>$k_1\alpha_1+k_2\alpha_2$仍是$A$对应于$\lambda$的特征向量<br><br>由$A\alpha_1=\lambda\alpha_1,A\alpha_2=\lambda\alpha_2$<br><br><br>$<br>\begin{aligned}<br>得到： A(k_1\alpha_1+k_2\alpha_2)<br>&amp;=k_1A\alpha_1+k_2A\alpha_2\\<br>&amp;=k_1(\lambda\alpha_1)+k_2(\lambda\alpha_2)\\<br>&amp;=\lambda(k_1\alpha_1+k_2\alpha_2)\\<br>\end{aligned}<br>$</li>
</ol>
<h2 id="求解步骤和原理"><a href="#求解步骤和原理" class="headerlink" title="求解步骤和原理"></a>求解步骤和原理</h2><p>$\quad A\alpha=\lambda\alpha$</p>
<p>$\Rightarrow(\lambda E-A)\alpha=0$</p>
<p>$\quad\alpha\;$是$\;(\lambda E-A)x=0$的非零解</p>
<p>$\rightarrow\;|\lambda E-A|=0$</p>
<p>(1) 由$\;|\lambda E-A|=0\;$求特征值$\;\lambda_i$<br><br>$\quad$共n个(含重根)<br><br>(2) 由$\;(\lambda_iE-A)x=0\;$求基础解系<br><br>$\quad$即$\lambda_i$线性无关的特征向量</p>
<p><strong>例</strong><br>求<br>$<br>A=\begin{bmatrix}<br>    0&amp;2&amp;-2\\<br>     2&amp;4&amp;4\\<br>     -2&amp;4&amp;-3<br>\end{bmatrix}<br>$<br>特征值，特征向量</p>
<p>解：由特征多项式<br><br>$\quad\;<br>\begin{aligned}|\lambda E-A|<br>&amp;=\left|\begin{array}{ccc}<br>    \lambda&amp;-2&amp;2\\<br>    -2&amp;\lambda-4&amp;-4\\<br>     2&amp;-4&amp;\lambda+3<br>\end{array}\right|\\<br>&amp;=\left|\begin{array}{ccc}<br>    \lambda&amp;-2&amp;2-2\lambda\\<br>    -2&amp;\lambda-4&amp;0\\<br>     2&amp;-4&amp;\lambda-1<br>\end{array}\right|\\<br>&amp;=\left|\begin{array}{ccc}<br>    \lambda+4&amp;-10&amp;0\\<br>    -2&amp;\lambda-4&amp;0\\<br>     2&amp;-4&amp;\lambda-1<br>\end{array}\right|\\<br>&amp;=(\lambda-1)(\lambda^2-36)<br>\end{aligned}$<br><br><br>$\therefore\;A的特征值为\;1,\pm6$<br><br></p>
<ol>
<li>当$\;\lambda=1\;时,由\;(E-A)x=0$<br><br>$E-A=\begin{bmatrix}<br> 1&amp;-2&amp;2\\<br> -2&amp;-3&amp;-4\\<br> 2&amp;-4&amp;4<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br> 1&amp;0&amp;2\\<br> 0&amp;1&amp;0\\<br> 0&amp;0&amp;0<br>\end{bmatrix}$<br><br><br>$\qquad\therefore\;\alpha_1=(-2,0,1)^T$<br><br><br></li>
<li>当$\;\lambda=6\;时，由(6E-A)x=0$<br><br>$6E-A=\begin{bmatrix}<br> 6&amp;-2&amp;2\\<br> -2&amp;2&amp;-4\\<br> 2&amp;-4&amp;9<br>\end{bmatrix}<br>\stackrel{把第一行写成0,0,0} { \huge\longrightarrow }<br>\begin{bmatrix}<br> 0&amp;0&amp;0\\<br> -2&amp;2&amp;4\\<br> 2&amp;-4&amp;9<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br> 1&amp;-1&amp;2\\<br> 0&amp;-2&amp;5\\<br> 0&amp;0&amp;0<br>\end{bmatrix}$<br><br><br>$\qquad\therefore\;\alpha_2=(1,5,2)^T$<br><br><br></li>
<li>当$\lambda=-6时，由(-6E-A)x=0$<br><br>$-6E-A=\begin{bmatrix}<br> -6&amp;-2&amp;2\\<br> -2&amp;-10&amp;-4\\<br> 2&amp;-4&amp;-3<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br> 1&amp;1&amp;0\\<br> 0&amp;2&amp;1\\<br> 0&amp;0&amp;0<br>\end{bmatrix}$<br><br>$\quad\therefore\;\alpha_3=(-1,1,-2)^T$</li>
</ol>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><ol>
<li>设$A$是n阶矩阵<br><br>(1)$\;\sum\lambda_i=\sum {\large a}_{ii}=trA\;\rightarrow\;tr为矩阵的迹$<br><br>(2)$\;\prod\lambda_i=|A|$<br><br></li>
<li>$A$可逆$\;\Leftrightarrow\;$$A$的n个特征值全不为0<br><br></li>
<li>矩阵$A$对应于不同特征值的特征向量的特征向量是线性无关的<br><br><strong>证</strong>:$\quad$设$\lambda_1,\lambda_2,\cdots,\lambda_s$是矩阵$A$的S个不同的特征值，对应的特征向量分别是$\alpha_1,\alpha_2,\cdots,\alpha_s$<br><br>$\;$用数学归纳法<br><br>$\;那么,当S=1时，因\alpha_1\neq0,命题正确$<br><br>$\;假设S=k-1(k\geqslant2)时,结论成立$<br><br>$\;$当$S=k$时，<br>$x_1\alpha_1+x_2\alpha_2+\cdots+x_{k-1}\alpha_{k-1}+x_k\alpha_k=0\qquad(1)$<br><br>$\;用A左乘上式，有$<br><br>$\;x_1\lambda_1\alpha_1+x_2\lambda_2\alpha_2+\cdots+x_{k-1}\lambda_{k-1}\alpha_{k-1}+x_k\lambda_k\alpha_k=0\quad(2)$<br><br>$\;用\lambda_k乘(1)又有$<br><br>$\;x_1\lambda_k\alpha_1+x_2\lambda_k\alpha_2+\cdots+x_{k-1}\lambda_k\alpha_{k-1}+x_k\lambda_k\alpha_k=0\;\,\,\quad(3)$<br><br>$\;$(2)-(3):<br><br>$\;x_1(\lambda_1-\lambda_k)\alpha_1+x_2(\lambda_2-\lambda_k)\alpha_2+\cdots+x_{k-1}(\lambda_{k-1}-\lambda_k)\alpha_{k-1}=0$<br><br>$\;又因为\alpha_1,\alpha_2,\cdots,\alpha_{k-1}线性无关$<br><br>$\;所以x_1(\lambda_1-\lambda_k)=0,x_2(\lambda_2-\lambda_k)=0,\cdots,x_{k-1}(\lambda_{k-1}-\lambda_k)=0$<br><br>$\;因特征值\lambda_i\neq\lambda_j,从而\\<br>\quad x_1=0,x_2=0,\cdots,x_{k-1}=0$<br><br>$\;代入(1)式，得\\<br>\qquad x_k\alpha_k=0$<br><br>$\;因\;\alpha\neq0,\quad得\;x_k=0$<br><br>$\;故\alpha_1,\alpha_2,\cdots,\alpha_k线性无关$<br><br>所以当$S=k$时，命题成立<br><br>由数学归纳法可知对一切自然数，命题均成立。<br><br></li>
<li>若$\;A\alpha=\lambda\alpha,\alpha\neq0$<br><br>$(A+kE)\alpha=(\lambda+k)\alpha$<br><br></li>
<li>由$\;A\alpha=\lambda\alpha$<br><br>有$\;A^2\alpha=A(\lambda\alpha)=\lambda A\alpha=\lambda^2\alpha$<br><br>$\;\Rightarrow\;A^n\alpha^n=\lambda^n\alpha$<br><br></li>
<li>由$A\alpha=\lambda\alpha,A$可逆<br><br>可得到$A^{-1}\alpha=\displaystyle\frac{1}{\lambda}\alpha$<br><br>$\qquad\quad A^*\alpha=\displaystyle\frac{|A|}{\lambda}\alpha$</li>
</ol>
<h1 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h1><blockquote>
<p>设$A,B$都是n阶矩阵，如果存在可逆矩阵P,使得<br><br>$\qquad P^{-1}AP=B$<br><br>就称矩阵$A$相似于矩阵$B$，$B$是$A$的相似矩阵<br><br>记成$A\sim B$</p>
</blockquote>
<h2 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h2><ol>
<li>$A\sim B$<br><br></li>
<li>如果$A\sim B$,则$B\sim A$.<br><br></li>
<li>如果$A\sim B,B\sim C$则$\;A\sim C$.<br><br></li>
<li>如果$A\sim B$,那么<br><br>(1) $A^2\sim B^2$<br><br>(2) $A+kE\sim B+kE$<br><br>(3) 如果$A$可逆，则$\;A^{-1}\sim B^{-1}$<br><br>(4)如果$A_1\sim B_1,A_2\sim B_2$<br><br>$\quad$则$\;diag(A_1,A_2)\sim diag(B_1,B_2)$</li>
</ol>
<h2 id="两个矩阵相似的必要条件"><a href="#两个矩阵相似的必要条件" class="headerlink" title="两个矩阵相似的必要条件"></a>两个矩阵相似的必要条件</h2><p>如果$A\sim B$,</p>
<ol>
<li>$|\lambda E-A|=|\lambda E-B|\;\Rightarrow\lambda_A=\lambda_B$<br><br></li>
<li>$r(A)=r(B)$<br><br></li>
<li>$|A|=|B|$<br><br></li>
<li>$trA=trB\;\longrightarrow\;即\sum {\large a}_{ii}=\sum {\large b}_{ii}$</li>
</ol>
<h2 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h2><h3 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h3><p>$A\sim\land$$\;\Leftrightarrow\;$存在可逆矩阵$P$,使得$P^{-1}AP=\land$<br></p>
<p><strong>证</strong>:下面以三阶矩阵为例</p>
<p>首先将$P$按列分块<br><br>得到<br>$A(\alpha_1,\alpha_2,\alpha_3)=(\alpha_1,\alpha_2,\alpha_3)\;diag(a_1,a_2,a_3)$<br><br>即<br>$(A\alpha_1,A\alpha_2,A\alpha_3)=(a_1\alpha_1,a_2\alpha_2,a_3\alpha_3)$<br><br>$\therefore A\alpha_1=a_1\alpha_1\quad A\alpha_2=a_2\alpha_2\quad A\alpha_3=a_3\alpha_3$<br><br>$\qquad\downarrow$<br><br>不难发现，这就是特征值的定义形式<br>$\therefore A的特征值为:a_1,a_2,a_3\;\longrightarrow\;\land$<br><br>$\quad A的特征向量为:\alpha_1,\alpha_2,\alpha_3\rightarrow\; P$<br><br>$\therefore P$可逆$\;\Rightarrow\;|\alpha_1\;\alpha_2\;\alpha_3|\neq0\quad\alpha_1,\alpha_2,\alpha_3$线性无关<br><br>反之，若$A$有三个无关的特征向量$\;\alpha_1,\alpha_2,\alpha_3\;$,满足$\;A\alpha_i=\lambda_i\alpha_i\;(i=1,2,3)$</p>
<p>则有</p>
<p>$(A\alpha_1,A\alpha_2,A\alpha_3)$</p>
<p>$\begin{aligned}<br>&amp;=(\lambda_1\alpha_1,\lambda_2\alpha_2,\lambda_3\alpha_3)\\<br>&amp;=(\alpha_1,\alpha_2,\alpha_3)\;diag(\lambda_1,\lambda_2,\lambda_3)<br>\end{aligned}<br>$<br><br>即得到$\;AP=P\land$<br><br>$\therefore\;P^{-1}AP=\land=diag(\lambda_1,\lambda_2,\lambda_3)$<br><br>其实这就很容易看出此问题最终还是转化为特征值特征向量问题<br></p>
<p>定理:$A\sim\land\Longleftrightarrow$ $A$有n个线性无关的特征向量<br><br>如果$A$有n个不同的特征值，则$A\sim\land$</p>
<h3 id="求-A-n-的方法"><a href="#求-A-n-的方法" class="headerlink" title="求$A^n$的方法"></a>求$A^n$的方法<br></h3><p>$\because P^{-1}A^nP=\land^n$<br><br>$\therefore A^n=P\land^n P^{-1}$</p>
<p><strong>方法虽然不难，但是需要耐心和仔细！！</strong></p>
<h1 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h1><blockquote>
<p>若$A$矩阵的元素都是实数，且A的转置等于它本身，则称$A$为是对称矩阵</p>
</blockquote>
<h2 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h2><ol>
<li>若$A$是n阶实对称矩阵,则$A$的特征值都是<strong>实数</strong><br><br></li>
<li>$\lambda_1$与$\lambda_2$是$A$不同的特征值，$\alpha_1,\alpha_2$分别是属于$\lambda_1$与$\lambda_2$的特征向量，则$\alpha_1$与$\alpha_2$正交<br><br><br><strong>证</strong> 2：<br>$由A\alpha_1=\lambda_1\alpha_1,A\alpha_2=\lambda_2\alpha_2,\lambda_1\neq\lambda_2$ $\;\rightarrow\;[\alpha_1,\alpha_2]=\alpha_1^T\alpha_2=\alpha_2^T\alpha_1$<br><br>$<br>\begin{aligned}<br>\qquad\lambda_1\alpha_2^T\alpha_1<br>&amp;=\alpha_2^T A\alpha_1\;\rightarrow\;用\alpha_2^T来乘\\<br>&amp;=\alpha_2^T A^T\alpha_1\\<br>&amp;=(A\alpha_2)^T\alpha_1\\<br>&amp;=(\lambda_2\alpha_2)^T\alpha_1\\<br>&amp;=\lambda_2\alpha_2^T\alpha_1<br>\end{aligned}<br>$<br><br>$\quad\therefore\;(\lambda_1-\lambda_2)\alpha_2^T\alpha_1=0$<br><br>$\quad\therefore\;\alpha_2^T\alpha_1=0$<br><br></li>
<li>对任意一个n阶实对称矩阵$A$,总存在n阶 <strong>正交矩阵</strong> $\;Q$，使得<br><br>$\qquad\qquad Q^{-1}AQ=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>$\qquad$证明用数学归纳法<br><br>大体思路是：因为要证明的$Q$是正交矩阵，所以可以构造出来一组规范正交基，将$A\alpha_i$表示出来，从而就能构造出$AP=PB$这种形式，下面只需要说明$B$这个矩阵能够进行相似对角化，且是通过正交矩阵相似对角化，其中不要忘记使用正交矩阵的性质$A^{-1}=A^T$。<br><br></li>
<li>n=1成立<br><br></li>
<li>假设n-1成立<br><br>那么n时<br><br>$A\alpha_1=\lambda_1\alpha_1,将\alpha_1扩展到R^n，取一组单位正交基\alpha_1,\alpha_2,\cdots,\alpha_n$<br><br>$由A\alpha_1=\lambda_1\alpha_1 \;\rightarrow\; 因为A\alpha_1是空间里的一个向量，那么A\alpha_2\cdots也能用规范正交基表示$<br><br>$可得A\alpha_2=b_{12}\alpha_1+b_{22}\alpha_2+\cdots+b_{n2}\alpha_n\quad\rightarrow\;正交基的系数用字母代替，不需要具体表示$<br><br>$\qquad\qquad\qquad\cdots$<br><br>$\qquad A\alpha_2=b_{1n}\alpha_1+b_{2n}\alpha_2+\cdots+b_{nn}\alpha_n$<br><br>将上式用矩阵表示，并用分块矩阵的知识将矩阵分成四块<br><br>$A(\alpha_1,\alpha_2,\cdots,\alpha_n)=(\alpha_1,\alpha_2,\cdots,\alpha_n)<br>\begin{bmatrix}<br> \lambda_1&amp;b\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>$令(\alpha_1,\alpha_2,\cdots,\alpha_n)=Q_1$<br>$得到AQ_1=Q_1<br>\begin{bmatrix}<br> \lambda_1&amp;b\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>$即Q_1^{-1}AQ_1=<br>\begin{bmatrix}<br> \lambda_1&amp;b\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>两边同时转置(注意正交矩阵的性质:$\;Q_1^{-1}=Q^T$)<br><br>$[Q_1^{-1}AQ_1]^T=Q_1^{-1}AQ_1=<br>\begin{bmatrix}<br> \lambda_1&amp;0\\<br>  b^T&amp;B^T\\<br>\end{bmatrix}\;\rightarrow这是一个对称矩阵<br>$<br><br>$\therefore\;b=b^T=0,B=B^T,即B是n-1阶实对称矩阵$<br><br>$\therefore\;Q_1^{-1}AQ_1=<br>\begin{bmatrix}<br> \lambda_1&amp;0\\<br>  0&amp;B\\<br>\end{bmatrix}<br>$<br><br>因为B是个n-1阶实对称矩阵，所以按归纳假设B一定可以用正交矩阵相似对角化<br><br>现在假设这个正交矩阵为$P$<br><br>$那么可得到\;P^{-1}BP=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>$<br>然后令Q_2=<br>\begin{bmatrix}<br> 1&amp;0\\<br> 0&amp;P\\<br>\end{bmatrix}\;\rightarrow\;这个分块矩阵的构造可通过矩阵变换的思想理解<br>$<br><br>其实这里也可以用相似矩阵的性质：<br>如果$A_1\sim B_1,A_2\sim B_2$<br><br>$\quad$则$\;diag(A_1,A_2)\sim diag(B_1,B_2)$<br><br><br>$那么Q_2^{-1}Q_1^{-1}AQ_1Q_2=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>$令Q=Q_1Q_2,则Q^{-1}=Q_2^{-1}Q_1^{-1}$<br><br>$因为Q_1，Q_2是正交矩阵,所以Q是正交矩阵\;\rightarrow\;正交矩阵的性质$<br><br>$\therefore\;Q^{-1}AQ=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$<br><br>即n时结论成立<br><br>那么可得到结论成立<br>   </li>
</ol>
<h2 id="求解是对称矩阵相似对角化的步骤"><a href="#求解是对称矩阵相似对角化的步骤" class="headerlink" title="求解是对称矩阵相似对角化的步骤"></a>求解是对称矩阵相似对角化的步骤</h2><ul>
<li>求特征值  </li>
<li>求特征向量  </li>
<li>改造特征向量  <ul>
<li>$\lambda_i\neq\lambda_j$只需单位化  </li>
<li>$\lambda_i=\lambda_j$<ul>
<li>$[\alpha_i,\alpha_j]=0$只需单位化  </li>
<li>$[\alpha_i,\alpha_j] \neq0$施密特正交化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>特征值与特征向量$\;\rightarrow\;$相似对角化$\;\rightarrow\;$实对称矩阵相似对角化$\;\rightarrow\;$二次型的正交变换法</p>
<p>线性代数最核心的就是矩阵和行列式，由此衍生出其他的东西，之间其实联系还是很紧密的。而这一章核心就是特征值与特征向量，其实特征值可以理解为特征向量经过矩阵变换后的伸缩倍数，还有一些工具像施密特正交化，也给了一些其他概念，比如向量的内积(通过内积来理解柯西不等式感觉挺不错)，正交矩阵，相似矩阵，实对称矩阵，而这一章通过这些概念工具就能够让一些矩阵相似对角化。虽然清楚这些概念，但是对于特征值这个特征的理解总感觉缺少了什么，以前学习微分方程的时候有特征方程这个概念，究竟这两个特征的本质是否是同一个概念，后面继续进行学习研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>7.CSS 定位</title>
    <url>/2021/07/20/7-CSS%E7%9A%84%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="定位的组成"><a href="#定位的组成" class="headerlink" title="定位的组成"></a>定位的组成</h1><p><strong>定位:</strong> 将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子</p>
<p><strong>定位 = 定位模式 + 边偏移</strong></p>
<p>定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置</p>
<p><strong>1、定位模式</strong><br>定位模式决定元素的定位方式，它通过CSS 的 <strong>position</strong> 属性来设置，其值可以分为四个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">语义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">static</td>
<td style="text-align:left">静态定位</td>
</tr>
<tr>
<td style="text-align:left">relative</td>
<td style="text-align:left">相对定位</td>
</tr>
<tr>
<td style="text-align:left">absolute</td>
<td style="text-align:left">绝对定位</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">固定定位</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2、边偏移</strong><br>边偏移就是定位的盒子移动到最终位置，有top、bottom、left和right4个属性 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">边偏移属性</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">top: 80px</td>
<td style="text-align:left">顶端偏移量</td>
</tr>
<tr>
<td style="text-align:left">bottom</td>
<td style="text-align:left">bottom: 80px</td>
<td style="text-align:left">底部偏移量</td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">left: 80px</td>
<td style="text-align:left">左侧偏移量</td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">right: 80px</td>
<td style="text-align:left">右侧偏移量</td>
</tr>
</tbody>
</table>
</div>
<h1 id="静态定位（了解）"><a href="#静态定位（了解）" class="headerlink" title="静态定位（了解）"></a>静态定位（了解）</h1><p>静态定位就是元素的默认定位方式，无定位的意思<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; positon: static; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>静态定位按照标准流特性摆放位置，它没有边偏移</li>
<li>静态定位在布局时很少用到</li>
</ul>
<h1 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h1><p>相对定位是元素在移动位置的时候，是相对于他原来位置来说的<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: relative; &#125;</span><br></pre></td></tr></table></figure><br><strong>特点:</strong></p>
<ul>
<li>它是相对于原来的位置移动的</li>
<li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它</li>
</ul>
<h1 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h1><p>相对定位是元素在移动位置的时候，是相对于它祖先元素来说的<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure><br><strong>特点:</strong></p>
<ul>
<li>如果 <strong>没有祖先元素</strong> 或者 <strong>祖先元素没有定位</strong>，则以浏览器为准定位（Document文档）</li>
<li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li>
<li>绝对定位不在占有原来的位置（脱标）</li>
</ul>
<h1 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h1><p><strong>意思：</strong> 子集是绝对定位的话，父级要用相对定位</p>
<ul>
<li>自己相对定位，不会占有位置，可以放到父盒子里面的任何地方，不会影响其他兄弟盒子</li>
<li>父盒子需要加定位限制子盒子在父盒子内显示</li>
<li>父盒子布局时，需要占有位置，因此父盒子只能是相对定位</li>
</ul>
<h1 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h1><p>固定定位是元素固定于浏览器可视区的位置。主要适用场景：可以在浏览器页面滚动时元素的位置不会改变</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: fixed;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点:</strong><br>1.以浏览器的可视窗口为参照点移动元素</p>
<ul>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动</li>
</ul>
<p>2.固定定位不占有原来位置</p>
<p>固定定位也是脱标的，其实固定定位也可以看作是一种特殊的绝对定位</p>
<h2 id="固定定位小技巧"><a href="#固定定位小技巧" class="headerlink" title="固定定位小技巧"></a>固定定位小技巧</h2><p>固定在版心右侧位置</p>
<p><strong>小算法:</strong></p>
<p>1、让固定定位的盒子left:50%，走到浏览器可视区（也可以看作版心）的一半位置</p>
<p>2、让固定定位的盒子margin-left:版心宽度的一半距离</p>
<h1 id="粘性定位-sticky（了解）"><a href="#粘性定位-sticky（了解）" class="headerlink" title="粘性定位 sticky（了解）"></a>粘性定位 sticky（了解）</h1><p>粘性定位可以被认为是相对定位和绝对定位的混合。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: sticky; <span class="attribute">top</span>:<span class="number">10px</span>; &#125;</span><br></pre></td></tr></table></figure><br>特点：</p>
<p>1.以浏览器的可视窗口为参照点移动元素（固定定位特点）</p>
<p>2.粘性定位占有原先的位置（相对定位的特点）</p>
<p>3.必须添加top、left、right、bottom其中的一个才有效</p>
<p>跟页面滚动搭配使用，兼容性较差，IE不支持。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">定位模式</th>
<th style="text-align:left">是否脱标</th>
<th style="text-align:left">移动位置</th>
<th style="text-align:left">是否常用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">static静态定位</td>
<td style="text-align:left">否</td>
<td style="text-align:left">不能使用边偏移</td>
<td style="text-align:left">很少</td>
</tr>
<tr>
<td style="text-align:left">relative相对定位</td>
<td style="text-align:left">否（占有位置）</td>
<td style="text-align:left">相对于自身位置移动</td>
<td style="text-align:left">常用</td>
</tr>
<tr>
<td style="text-align:left">absolute绝对定位</td>
<td style="text-align:left">是（不占有位置）</td>
<td style="text-align:left">带有定位的父级</td>
<td style="text-align:left">常用</td>
</tr>
<tr>
<td style="text-align:left">fixed固定定位</td>
<td style="text-align:left">是（不占有位置）</td>
<td style="text-align:left">浏览器可视区</td>
<td style="text-align:left">常用</td>
</tr>
<tr>
<td style="text-align:left">sticky粘性定位</td>
<td style="text-align:left">否（占有位置）</td>
<td style="text-align:left">浏览器可视区</td>
<td style="text-align:left">当前阶段少</td>
</tr>
</tbody>
</table>
</div>
<h1 id="定位叠放次序-z-index"><a href="#定位叠放次序-z-index" class="headerlink" title="定位叠放次序 z-index"></a>定位叠放次序 z-index</h1><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以用z-index来控制盒子的前后次序（z轴）<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">z-index</span>: <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>数值可以是正整数、负数或0，默认是auto，数值越大，盒子越靠上</li>
<li>如果属性值是相同，按照书写顺序，后来居上</li>
<li>数字后面不能加单位</li>
<li>只有定位的盒子才有z-index属性</li>
</ul>
<h1 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h1><h2 id="绝对定位的盒子居中"><a href="#绝对定位的盒子居中" class="headerlink" title="绝对定位的盒子居中"></a>绝对定位的盒子居中</h2><p>加了绝对定位的盒子不能通过margin:0 auto水平居中，但是可以通过以下计算方法实现水平和垂直居中。</p>
<ul>
<li>left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。</li>
<li>margin-left: 盒子自身宽度的一半。</li>
</ul>
<h2 id="定位特殊性"><a href="#定位特殊性" class="headerlink" title="定位特殊性"></a>定位特殊性</h2><p>绝对定位和固定定位也和浮动类似。</p>
<ol>
<li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度。</li>
<li>块级元素添加绝对或者固定定位，如果不给宽度或高度，默认大小是内容的大小。</li>
</ol>
<h2 id="脱标的盒子不会触发外边距塌陷"><a href="#脱标的盒子不会触发外边距塌陷" class="headerlink" title="脱标的盒子不会触发外边距塌陷"></a>脱标的盒子不会触发外边距塌陷</h2><p>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题。</p>
<h2 id="绝对定位（固定定位）会完全压住盒子"><a href="#绝对定位（固定定位）会完全压住盒子" class="headerlink" title="绝对定位（固定定位）会完全压住盒子"></a>绝对定位（固定定位）会完全压住盒子</h2><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p>
<p>但是绝对定位（固定定位）会压住下面标准流的所有内容。</p>
<p>浮动之所以不会压住文字，是因为浮动产生的目的最初是为了作文字环绕效果的。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>7.统计方法与排序（numpy）</title>
    <url>/2021/07/07/7-%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%92%E5%BA%8F%EF%BC%88numpy%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h1><p><strong>基本数组统计方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sum</td>
<td style="text-align:left">对数组中全部或某轴向的元素求和。零长度的数组的sum为0</td>
</tr>
<tr>
<td style="text-align:left">mean</td>
<td style="text-align:left">算术平均数。零长度的数组的mean为NaN</td>
</tr>
<tr>
<td style="text-align:left">std、var</td>
<td style="text-align:left">分别为标准差和方差，自由度可调（默认为n）</td>
</tr>
<tr>
<td style="text-align:left">min、max</td>
<td style="text-align:left">最大值和最小值</td>
</tr>
<tr>
<td style="text-align:left">argmin、argmax</td>
<td style="text-align:left">分别为最大和最小元素的索引</td>
</tr>
<tr>
<td style="text-align:left">cumsum</td>
<td style="text-align:left">所有元素的累计和</td>
</tr>
<tr>
<td style="text-align:left">cumprod</td>
<td style="text-align:left">所有元素的累计积</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.54723045,  0.58597431, -0.96045403, -1.702082  ],
       [ 1.06630288, -1.0836272 ,  2.29730989, -0.30115381],
       [-0.95468451,  1.05624793,  1.01693306,  0.09056162],
       [-0.36292065,  0.19475411, -0.01906396, -1.24974648],
       [-1.90823323, -0.31973005,  1.06666693,  0.81091118]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.mean()</span><br></pre></td></tr></table></figure>
<pre><code>-0.06116322299092232
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.mean(arr)</span><br></pre></td></tr></table></figure>
<pre><code>-0.06116322299092232
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>-1.2232644598184463
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<pre><code>2.2973098855173615
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>
<pre><code>-1.9082332261211672
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.std()</span><br></pre></td></tr></table></figure>
<pre><code>1.0584749116858456
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.var()</span><br></pre></td></tr></table></figure>
<pre><code>1.1203691386683585
</code></pre><p>mean和sum这类函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.mean(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-0.65594804,  0.49470794,  0.30226452, -0.35924424, -0.08759629])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-2.70676596,  0.4336191 ,  3.40139188, -2.35150948])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.mean(<span class="number">1</span>)<span class="comment">#计算行的平均值</span></span><br></pre></td></tr></table></figure>
<pre><code>array([-0.65594804,  0.49470794,  0.30226452, -0.35924424, -0.08759629])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">sum</span>(<span class="number">0</span>)<span class="comment">#计算每列的和</span></span><br></pre></td></tr></table></figure>
<pre><code>array([-2.70676596,  0.4336191 ,  3.40139188, -2.35150948])
</code></pre><p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr= np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.cumprod(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]], dtype=int32)
</code></pre><p>当然可以使用布尔型数组，布尔值会被强制转换为1和0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]])</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1,  2,  3],
       [-1, -2, -3]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(arr&gt;<span class="number">0</span>).<span class="built_in">sum</span>()<span class="comment">#这样就得到了数组中大于零的元素个数</span></span><br></pre></td></tr></table></figure>
<pre><code>3
</code></pre><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]])</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [6, 4, 3],
       [2, 3, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.sort()</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [3, 4, 6],
       [2, 3, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="number">0</span>)<span class="comment">#按0轴排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [2, 3, 6],
       [3, 4, 7]])
</code></pre>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>8.CSS网页布局及用户界面样式</title>
    <url>/2021/07/20/8-CSS%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E5%8F%8A%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h1><p><strong>网页布局的核心本质就是利用CSS摆盒子</strong></p>
<p><strong>网页布局的第一准则:</strong><br>多个块级元素纵向排列用标准流，多个块级元素横向排列用浮动。</p>
<p><strong>网页布局的第二准则:</strong><br>先设置盒子大小，后设置盒子位置。</p>
<h2 id="传统网页布局的三种方式"><a href="#传统网页布局的三种方式" class="headerlink" title="传统网页布局的三种方式"></a>传统网页布局的三种方式</h2><p>网页布局的本质————用CSS来摆放盒子</p>
<p>CSS提供了三种传统布局方式：</p>
<ul>
<li>标准流（最基本）</li>
<li>浮动</li>
<li>定位</li>
</ul>
<h2 id="常见的网页布局"><a href="#常见的网页布局" class="headerlink" title="常见的网页布局"></a>常见的网页布局</h2><table style="width: 370px;background-color: #ecedf8;text-align: center;">
  <tr>
    <td style="width: 370px;height: 65px;border:1px dashed;border-collapse: collapse;">top</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 25px;border:1px dashed;border-collapse: collapse;">banner</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 145px;border:1px dashed;border-collapse: collapse;">main</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 90px;border:1px dashed;border-collapse: collapse;">footer</td>
  </tr>
</table>

<p><table style="width: 370px;background-color: #ecedf8;text-align: center;">
  <tr>
    <td style="width: 370px;height: 65px;border:1px dashed;border-collapse: collapse;">top</td>
  </tr>
   <tr>
    <td style="width: 370px;height: 25px;border:1px dashed;border-collapse: collapse;">banner</td>
  </tr>
   <tr>
    <td style="float:left;width: 115px;height: 145px;border:1px dashed;line-height: 145px;border-top:0;border-bottom:0;">left</td>
    <td style="float:right;width: 195px;height: 145px;border:0;border-right:1px dashed;line-height: 145px;">right</td>
  </tr>
   <tr>
    <td style="height: 90px;border:1px dashed;border-collapse: collapse;">footer</td>
  </tr>
</table></p>
<div style="width: 100%;overflow:auto;">
    <div style="width: 500px;height: 420px;border:1px solid;text-align:center;">
    <div style="float:left;width: 480px;height: 25px;line-height:25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 10px 0px;">top</div>
    <div style="float:left;width: 360px;height: 80px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 70px 0px;line-height: 80px">banner</div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px 70px;"></div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 25px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 70px 0px 5px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px 70px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 80px;height: 130px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 5px 0px;"></div>
    <div style="float:left;width: 480px;height: 90px;background-color: #ecedf8;border:1px dashed;border-collapse: collapse;margin:10px 10px 0px;line-height:90px;">footer</div>
    </div>
</div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过CSS浮动、定位可以让每个盒子排列成为网页。</p>
<p>一个完整的网页，是标准流、浮动、定位一起完成的布局的，每个都有自己专门的用法。</p>
<p><strong>1.标准流</strong><br>可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。<br><strong>2.浮动</strong><br>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。<br><strong>3.定位</strong><br>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</p>
<h1 id="CSS-用户界面样式"><a href="#CSS-用户界面样式" class="headerlink" title="CSS 用户界面样式"></a>CSS 用户界面样式</h1><h2 id="鼠标样式-cursor"><a href="#鼠标样式-cursor" class="headerlink" title="鼠标样式 cursor"></a>鼠标样式 cursor</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123; <span class="attribute">cursor</span>: pointer; &#125;</span><br></pre></td></tr></table></figure>
<p>设置或检索在对象上移动的鼠标指针来采用何种系统预定义的光标形状</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">default</td>
<td style="text-align:left">默认</td>
</tr>
<tr>
<td style="text-align:left">pointer</td>
<td style="text-align:left">小手</td>
</tr>
<tr>
<td style="text-align:left">move</td>
<td style="text-align:left">移动</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">文本</td>
</tr>
<tr>
<td style="text-align:left">not-allowed</td>
<td style="text-align:left">禁止</td>
</tr>
</tbody>
</table>
</div>
<h2 id="轮廓线"><a href="#轮廓线" class="headerlink" title="轮廓线"></a>轮廓线</h2><p>给表单添加 outline: 0;或者outline: none;样式之后，就可以去掉默认的蓝色边框。</p>
<h2 id="防止拖拽文本域-resize"><a href="#防止拖拽文本域-resize" class="headerlink" title="防止拖拽文本域 resize"></a>防止拖拽文本域 resize</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span> &#123; <span class="attribute">resize</span>: none &#125;</span><br></pre></td></tr></table></figure>
<h1 id="vertical-align-属性应用"><a href="#vertical-align-属性应用" class="headerlink" title="vertical-align 属性应用"></a>vertical-align 属性应用</h1><p>CSS的vertical-align属性使用场景：经常用于设置图片或者表单（行内块元素）和文字垂直对齐<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: baseline | top | middle | bottom</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">baseline</td>
<td style="text-align:left">默认，元素放置在父元素的基线上</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">把顶端元素与行中最高元素的顶端对齐</td>
</tr>
<tr>
<td style="text-align:left">middle</td>
<td style="text-align:left">把此元素放置在父元素的中间</td>
</tr>
<tr>
<td style="text-align:left">bottom</td>
<td style="text-align:left">把元素的顶端与行中最低的元素顶端对齐</td>
</tr>
</tbody>
</table>
</div>
<h1 id="溢出文字用省略号"><a href="#溢出文字用省略号" class="headerlink" title="溢出文字用省略号"></a>溢出文字用省略号</h1><h2 id="单行文字溢出用省略号"><a href="#单行文字溢出用省略号" class="headerlink" title="单行文字溢出用省略号"></a>单行文字溢出用省略号</h2><p>1.单行文本溢出显示省略号—必须满足三个条件<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1.先强制一行内显示文本 */</span></span><br><span class="line"><span class="attribute">white-space</span>: nowrap; （默认 <span class="attribute">normal</span> 自动换行）</span><br><span class="line"><span class="comment">/* 2.超出的部分隐藏 */</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="comment">/* 3.文字用省略号替代超出的部分 */</span></span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure></p>
<h2 id="多行文本溢出显示省略号"><a href="#多行文本溢出显示省略号" class="headerlink" title="多行文本溢出显示省略号"></a>多行文本溢出显示省略号</h2><p>多行文本溢出显示省略号，有较大兼容性问题，适合于webkit浏览器或移动端（移动端大部分是webkit内核）<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="comment">/* 弹性伸缩盒子模型显示 */</span></span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line"><span class="comment">/* 限制在一个块元素显示的文本的行数 */</span></span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line">-webkit-box-crient: vertical;</span><br></pre></td></tr></table></figure></p>
<h1 id="CSS-初始化"><a href="#CSS-初始化" class="headerlink" title="CSS 初始化"></a>CSS 初始化</h1><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS初始化</p>
<p><strong>简单理解:</strong> CSS初始化是指重设浏览器的样式（也称为CSS reset）</p>
<p>每个网页都必须首先进行CSS 初始化</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>7.二次型</title>
    <url>/2021/06/23/7.%E4%BA%8C%E6%AC%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><ol>
<li>二次型的矩阵表示<br>$f(x_1,x_2,x_3)$<br><br>$\begin{aligned}<br>&amp;=x_1^2+5x_2^2-4x_3^2-2x_1x_2+6x_2x_3\\<br>&amp;=[x_1\;x_2\;x_3]<br>\begin{bmatrix}<br> 1&amp;-1&amp;0\\<br> -1&amp;5&amp;3\\<br> 0&amp;3&amp;-4<br>\end{bmatrix}<br>\begin{bmatrix}<br> x_1\\<br> x_2\\<br> x_3<br>\end{bmatrix}\\<br>&amp;=x^TAx<br>\end{aligned}<br>$<br><br>其中$A$是对称矩阵，即$A^T=A$<br><br>此矩阵称为二次型矩阵<br><br></li>
<li>标准形<blockquote>
<p>二次型只有平方项<br><br>例如，$x_1^2+x_2^2-4x_3^2$<br><br></p>
</blockquote>
</li>
<li>规范形<blockquote>
<p>标准型里面平方项系数只有$\pm1或0$<br><br>例如，$x_1^2-x_2^2+x_4^2$<br><br></p>
</blockquote>
</li>
<li>正惯性指数p，负惯性指数q，符号差<blockquote>
<p>p,q就是标准形系数正负个数<br><br>符号差就是p-q<br><br>例$x_1^2+x_2^2-4x_3^2\quad$</p>
<p>正惯性指数=2，负惯性指数=1,符号差=1<br><br></p>
</blockquote>
</li>
<li>二次型的秩<blockquote>
<p>$r(f)=r(A)$<br><br></p>
</blockquote>
</li>
<li>坐标变换<br>即$x=Cy$<br><br>这里可以参照向量空间坐标变换公式，注意$|C|\neq0$<br><br></li>
<li>合同<blockquote>
<p>如果$C^TAC=B$,其中$C$可逆矩阵<br><br>称矩阵A和B合同，记作$A\simeq B$</p>
</blockquote>
</li>
</ol>
<h2 id="标准形"><a href="#标准形" class="headerlink" title="标准形"></a>标准形</h2><p>方法：<br>1.配方法；2.正交变换法</p>
<h3 id="配方法"><a href="#配方法" class="headerlink" title="配方法"></a>配方法</h3><ul>
<li><strong>例</strong> ：化二次型<br>$\quad f=x_1^2+2x_2^2+5_3^2+2x_1x_2+2x_1x_3+6x_2x_3$成标准形，并写出所用坐标变换。<br><br>解：<br>$\begin{aligned}<br>f<br>&amp;=x_1^2+2x_1x_2+2x_1x_3+2x_2^25x_3^2+6x_2x_3\\<br>&amp;=[x_1^2+2x_1(x_2+x_3)+(x_2+x_3)^2]\\<br>&amp;\quad -(x_2+x_3)^2+2x_2^2+5x_3^2+6x_2x_3\\<br>\\<br>&amp;=(x_1+x_2+x_3)^2+x_2^2+4x_2x_3+4x_3^2\\<br>&amp;=(x_1+x_2+x_3)^2+(x_2+x_3)^2<br>\end{aligned}<br>$<br><br>令<br>$<br>\begin{cases}<br>y_1=x_1+x_2+x_3\\<br>y_2=x_2+x_3\\<br>y_3=x_3<br>\end{cases}<br>$<br><br>即<br>$<br>\begin{cases}<br>x_1=y_1-y_2+y_3\\<br>x_2=y_2-2y_3\\<br>x_3=y_3<br>\end{cases}<br>$<br><br>坐标变换公式<br>$x=Cy$<br><br>$C=<br>\begin{bmatrix}<br>  1&amp;-1&amp;1\\<br>  0&amp;1&amp;-2\\<br>  0&amp;0&amp;1<br>\end{bmatrix}<br>$<br><br>得$f=y_1^2+y_2^2$</li>
</ul>
<h3 id="正交变换法"><a href="#正交变换法" class="headerlink" title="正交变换法"></a>正交变换法</h3><blockquote>
<p>定理：任意一个二次型$f=x^TAx$，其中$A^T=A$,总存在正交变换$x=py$,(其中$P$是正交矩阵)，使二次型化为标准形<br><br>$\quad x^TAx=y^T\land y=\lambda_1y_1^2+\cdots+\lambda_n y_n^2$<br><br>($\lambda$是A的特征值)</p>
</blockquote>
<ul>
<li><strong>证</strong>：<br>首先要知道二次型中$A$是实对称矩阵<br><br>因为实对称矩阵，$Q^{-1}AQ=\land$<br><br>$Q$是正交矩阵(则$Q^T=Q^{-1}$)<br><br>所以$Q^TAQ=\land$<br><br>若令$x=Qy$,则<br><br>$<br>\begin{aligned}<br>x^TAx<br>&amp;=(Qy)^TA(Qy)\\<br>&amp;=y^TQ^TAQy\\<br>&amp;=y^T\land y\\<br>&amp;=\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2<br>\end{aligned}<br>$</li>
</ul>
<p><strong>例</strong>：将二次型<br>$f=x_1^2+x_2^2+x_3^2+4x_1x_2+4x_1x_3+4x_2x_3$<br>用正交变换化成标准形，并写出所用坐标变换。</p>
<p><strong>解</strong>：二次型矩阵为<br>$<br>A=<br>\begin{bmatrix}<br>1&amp;2&amp;2\\<br>2&amp;1&amp;2\\<br>2&amp;2&amp;1<br>\end{bmatrix}<br>$</p>
<p>由特征多项式<br>$<br>\begin{aligned}<br>|\lambda E-A|<br>&amp;=\left|\begin{array}{ccc}<br>\lambda-1&amp;-2&amp;-2\\<br>-2&amp;\lambda-1&amp;-2\\<br>-2&amp;-2&amp;\lambda-1<br>\end{array}\right|\\<br>&amp;=(\lambda-5)(\lambda+1)^2<br>\end{aligned}<br>$</p>
<p>$\therefore A$的特征值为5，-1，-1</p>
<p>$\lambda=5$时，由$(5E-A)x=0$<br><br>得<br>$<br>\begin{bmatrix}<br>4&amp;-2&amp;-2\\<br>-2&amp;4&amp;-2\\<br>-2&amp;-2&amp;4<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br>1&amp;0&amp;-1\\<br>0&amp;1&amp;-1\\<br>0&amp;0&amp;0<br>\end{bmatrix}<br>$</p>
<p>$得到\alpha_1=(1,1,1)^T$</p>
<p>$\lambda=-1$时，由$(-E-A)x=0$</p>
<p>得<br>$<br>\begin{bmatrix}<br>-2&amp;-2&amp;-2\\<br>-2&amp;-2&amp;-2\\<br>-2&amp;-2&amp;-2<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br>1&amp;1&amp;1\\<br>0&amp;0&amp;0\\<br>0&amp;0&amp;0<br>\end{bmatrix}<br>$</p>
<p>得$\alpha_2=(-1,1,0)^T，\alpha_3=(-1,0,1)^T$</p>
<p>因为这两个向量不垂直</p>
<p>$\therefore 将\alpha_2,\alpha_3$施密特正交化</p>
<p>$\beta_2=\alpha_2=\begin{bmatrix}-1\\1\\0\end{bmatrix}$</p>
<p>$<br>\beta_3=\alpha_3-\displaystyle\frac{ [\alpha_3\;\beta_2] }{ [\beta_2\;\beta_3] }\beta_2<br>=\frac12\begin{bmatrix}-1\\ -1\\2\end{bmatrix}<br>$</p>
<p>单位化</p>
<p>$<br>\gamma_1=\displaystyle\frac{1}{\sqrt{3} }\begin{bmatrix}1\\1\\1\end{bmatrix},<br>\gamma_2=\displaystyle\frac{1}{\sqrt{2} }\begin{bmatrix}-1\\1\\0\end{bmatrix},$<br>$\gamma_3=\displaystyle\frac{1}{\sqrt{6} }\begin{bmatrix}-1\\ -1\\2\end{bmatrix}$</p>
<p>令<br>$<br>\;P=(\gamma_1\;\gamma_2\;\gamma_3)<br>=\begin{bmatrix}<br>\displaystyle\frac{1}{\sqrt{3} }&amp;-\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp;\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp; 0 &amp;\displaystyle\frac{2}{\sqrt{6} }<br>\end{bmatrix}<br>$</p>
<p>那么，二次型$x^TAx$经正交变换</p>
<p>$<br>\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=<br>\begin{bmatrix}<br>\displaystyle\frac{1}{\sqrt{3} }&amp;-\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp;\displaystyle\frac{1}{\sqrt{2} }&amp;-\displaystyle\frac{1}{\sqrt{6} }\\<br>\displaystyle\frac{1}{\sqrt{3} }&amp; 0 &amp;\displaystyle\frac{2}{\sqrt{6} }<br>\end{bmatrix}<br>\begin{bmatrix}y_1\\y_2\\y_3\end{bmatrix}<br>$</p>
<p>化为标准形</p>
<p>$f=x^TAx=y^T\land y=5y_1^2-y_2^2-y_3^2$</p>
<p>二次型求规范形的求解步骤其实可以参照前面实对称矩阵相似对角化求解步骤</p>
<p><strong>推论：</strong></p>
<p>任意一个n元二次型$f=x^TAx$都存在坐标变换$x=Cz$使$f$化为规范形</p>
<ul>
<li><strong>例</strong>:<br>$f=y_1^2+3y_2^2-2y_3^2$<br><br>令<br>$\begin{cases}<br>y_1=z_1\\<br>y_2=\displaystyle\frac{1}{\sqrt{3} }z_2\\<br>y_3=\displaystyle\frac{1}{\sqrt{2} }z_3<br>\end{cases}<br>$<br><br>那么$f=z_1^2+z_2^2-z_3^2$</li>
</ul>
<p>变成规范形步骤：</p>
<p>(配方法，正交变换法)$\;\rightarrow\;$标准形$\;\rightarrow\;$规范形</p>
<h2 id="惯性定理"><a href="#惯性定理" class="headerlink" title="惯性定理"></a>惯性定理</h2><blockquote>
<p>对一个二次型$x^TAx$,经坐标变换化为标准形，其正惯性指数和负惯性指数都是唯一确定的</p>
</blockquote>
<p>即二次型的规范形是唯一的</p>
<ul>
<li><strong>证</strong>：<br>大体思路：既然要证唯一性，那么就假设其不唯一，也就是能被两个不同的规范形表示，<br>那么如果证明出来这两个规范形整数项必定相等，则结论成立，这里就需要反证法，推出矛盾<br><br>设$r(C^TAC)=r(A)=r(f)=r$<br><br>如果经坐标变换$x=Py\;$和$\;x=Qz$<br><br>二次型$x^TAx$化成规范形，分别为<br><br>$f=y_1^2+y_2^2+\cdots+y_s^2-y_{s+1}^2-\cdots-y_r^2 \; (I)$<br><br>$f=z_1^2+z_2^2+\cdots+z_t^2-z_{t+1}^2-\cdots-z_r^2 \; (II)$<br><br><strong>反证法</strong><br>如果$s &lt; t$的话$\;\rightarrow\;$也就是说$(I)$的正数项和$(II)$的正数项不相等<br><br>$\qquad$由$\;y=P^{-1}x$和$\;z=Q^{-1}x$<br><br>不妨设<br><br>$\qquad y_i=c_{i1}x_1+c_{i2}x_2+\cdots+c_{in}x_n\qquad$<br><br>$\qquad z_i=d_{i1}x_1+d_{i2}x_2+\cdots+d_{in}x_n\qquad$<br><br>其中($i=1,2,\cdots,n$)<br><br><br>在这两个n元线性方程组中选择，选择$(I)$中的系数为正的项和$(II)$中系数为负的项<br><br>即$y_1—y_s,z_{t+1}—z_n$，令他们为0,构造齐次方程组,这样取就是为了推出矛盾<br><br>即<br>$<br>\begin{cases}<br>y_1=0\\<br>\cdots\\<br>y_s=0\\<br>z_{t+1}=0\\<br>\cdots\\<br>z_{n}=0<br>\end{cases}<br>$<br><br>也就是<br>$<br>\begin{cases}<br>c_{11}x_1+c_{12}x_2+\cdots c_{1n}x_n=0\\<br>\qquad\cdots\cdots\\<br>c_{s1}x_1+c_{s2}x_2+\cdots c_{sn}x_n=0\\<br>&amp;(1)\\<br>d_{(t+1)1}x_1+d_{(t+1)2}x_2+\cdots d_{(t+1)n}x_n=0\\<br>\qquad\cdots\cdots\\<br>d_{n1}x_1+d_{n2}x_2+\cdots d_{nn}x_n=0<br>\end{cases}<br>$<br><br>方程个数<br>$s+(n-t)=n+s-t&lt; n$<br><br>方程组(1)必有非零解<br><br>设$\;\eta=(k_1,k_2,\cdots,k_n)^T$是(1)的非零解<br><br>将该解代入两个n元线性方程组，可以得到$y_i,z_i$的值用$y^o_i,z^o_i表示$<br><br>因为$P,Q$均为可逆矩阵，$\eta\neq0$<br><br>$\therefore\;y^o=P^{-1}\eta=(0,\cdots,0,y_{s+1}^o,\cdots,y_n^o)^T\neq0$<br><br>$\quad\;z^o=Q^{-1}\eta=(z_1^o,\cdots,z_t^o,0,\cdots,0)^T\neq0$<br><br>把$\eta$代入$(I)$和$(II)$,有<br><br>$f(\eta)=-(y_{s+1}^o)^2-\cdots-(y_r^o)^2&lt; 0$<br><br>$f(\eta)=(z_1^o)^2+\cdots+(z_t^o)^2&gt;0$<br><br>矛盾<br><br>$\because s,t$地位相等<br><br>$\therefore\;s=t$</li>
</ul>
<p>由惯性定理推出:</p>
<p>实对称矩阵$A$和$B$合同</p>
<p>$\Leftrightarrow p_A=p_B,q_A=q_B\;$<br>(p为正惯性指数，q为负惯性指数)</p>
<h1 id="二次型的正定性"><a href="#二次型的正定性" class="headerlink" title="二次型的正定性"></a>二次型的正定性</h1><h2 id="正定矩阵"><a href="#正定矩阵" class="headerlink" title="正定矩阵"></a>正定矩阵</h2><blockquote>
<p>设二次型$f(x)=x^TAx$<br><br>如果$\forall x=(x_1,x_2,\cdots,x_n)^T\neq0$,<br><br>恒有$f(x)&gt;0$，则称$f$为正定二次型，二次型矩阵$A$称为正定矩阵</p>
</blockquote>
<p>正定的话，平方项系数要严格大于零，也就是说正惯性指数为n</p>
<p>二次型经坐标变换，其正定性不变</p>
<p>$x^TAx$正定</p>
<p>$\Leftrightarrow\;$p(正惯性指数)=n</p>
<p>$\Leftrightarrow\;A\simeq E$,即存在可逆矩阵$C,$</p>
<p>$C^TAC=E(或写成A=C^TEC，E可省略)$</p>
<p>$\Leftrightarrow\;A$特征值全大于0</p>
<p>$\Leftrightarrow\;A$的顺序主子式 <strong>全</strong> 大于0</p>
<p>$x^TAx$正定的必要条件$a_{ii}&gt;0$</p>
<p><strong>例</strong>：判断二次型</p>
<p>$2x_1^2+5x_2^2+5x_3^2+4x_1x_2-4x_1x_3-8x_2x_3$</p>
<p>是否是正定二次型。</p>
<p><strong>解</strong>：</p>
<ul>
<li>顺序主子式<br>二次型矩阵<br><br>$A$=$<br>\left|\begin{array}{ccc}<br>2&amp;2&amp;-2\\<br>2&amp;5&amp;-4\\<br>-2&amp;-4&amp;5<br>\end{array}\right|<br>$<br><br>$\Delta_1=2&gt;0，\Delta_2=\left|\begin{array}{ccc}2&amp;2\\2&amp;5\end{array}\right|=6&gt;0$<br><br>$\Delta_3=|A|=10&gt;0$<br><br>$\therefore\;f\;$是正定二次型</li>
</ul>
<hr>
<ul>
<li>特征值<br>由特征多项式<br><br>$<br>\begin{aligned}<br>|\lambda E-A|<br>&amp;=\left|\begin{array}{ccc}<br>\lambda-2&amp;-2&amp;2\\<br>-2&amp;\lambda-5&amp;4\\<br>2&amp;4&amp;\lambda-5<br>\end{array}\right|\\<br>&amp;=(\lambda-1)^2(\lambda-10)<br>\end{aligned}<br>$<br><br>$A$的特征值：1,1,10$\quad$全大于零<br><br>$\therefore\;f\;$是正定二次型</li>
</ul>
<hr>
<ul>
<li>配方法$^*$<br><br>$<br>\begin{aligned}<br>f<br>&amp;=2x_1^2+5x_2^2+5x_3^2+4x_1x_2-4x_1x_3-8x_2x_3\\<br>&amp;=2[x_1^2+2x_1(x_2-x_3)+(x_2-x_3)^2]\\<br>&amp;\quad -2(x_2-x_3)^2+5x_2^2+5x_3^2-8x_2x_3\\<br>&amp;=(x_1+x_2-x_3)^2+3x_2^2+3x_3^2-4x_2x_3\\<br>&amp;=(x_1+x_2-x_3)^2+3(x_2-\frac23x_3)^2+\frac53x_3^2<br>\end{aligned}<br>$<br><br>$p=3,q=0$<br><br>$\therefore\;f\;$是正定二次型</li>
</ul>
<h2 id="半正定，负定，半负定矩阵"><a href="#半正定，负定，半负定矩阵" class="headerlink" title="半正定，负定，半负定矩阵"></a>半正定，负定，半负定矩阵</h2><p>根据正定可以类比出</p>
<p>半正定$f\geqslant0$</p>
<p>负定$f&lt;0$</p>
<p>半负定$f\leqslant0$</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>9.元素的显示与隐藏</title>
    <url>/2021/07/20/9-%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="元素显示与隐藏"><a href="#元素显示与隐藏" class="headerlink" title="元素显示与隐藏"></a>元素显示与隐藏</h1><p>本质：让一个元素在页面中隐藏或者显示出来</p>
<ol>
<li>display 显示隐藏</li>
<li>visibility 显示隐藏</li>
<li>overflow 溢出显示隐藏</li>
</ol>
<h2 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h2><p><strong>display</strong> 属性用于设置一个元素应如何显示</p>
<ul>
<li>display: none; 隐藏对象</li>
<li>display: block; 除了转换为块级元素之外，同时还有显示元素的意思</li>
</ul>
<p><strong>display 隐藏元素后，不在占有原来的位置</strong></p>
<h2 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h2><p><strong>visibility</strong> 属性用于指定一个元素应可见还是隐藏</p>
<ul>
<li>visibility: visible; 元素可见</li>
<li>visibility: hidden; 元素隐藏</li>
</ul>
<p><strong>visibility隐藏元素后，继续占有原来的位置</strong></p>
<h2 id="overflow-溢出"><a href="#overflow-溢出" class="headerlink" title="overflow 溢出"></a>overflow 溢出</h2><p><strong>overflow</strong> 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度）时</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">visible</td>
<td style="text-align:left">不见且内容也不添加滚动条</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td style="text-align:left">scroll</td>
<td style="text-align:left">不管有无超出内容，总是显示滚动条</td>
</tr>
<tr>
<td style="text-align:left">auto</td>
<td style="text-align:left">超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意:</strong> 如果有定位的盒子，请慎用overflow:hidden 因为它会隐藏多余的部分</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM</title>
    <url>/2021/09/16/BOM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>BOM（Browser  Object Model）即<strong>浏览器对象模型</strong>，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是windows</p>
<p><strong>window 对象是浏览器的顶级对象</strong>，它具有双重角色</p>
<ol>
<li>它是JS访问浏览器窗口的一个接口</li>
<li>它是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等。</li>
</ol>
<span id="more"></span>
<h1 id="Window对象常见事件"><a href="#Window对象常见事件" class="headerlink" title="Window对象常见事件"></a>Window对象常见事件</h1><h2 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>window.onload 是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件CSS文件等），就调用的处理函数</p>
<p><strong>注意：</strong></p>
<ol>
<li>有了window.onload 就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数</li>
<li><strong>window.onload 传统注册方式只能写一次</strong>，如果有多个，会以最后一个window.onload 为准</li>
<li>如果<strong>使用 addEventListener 则没有限制</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>DOMContentLoaded 事件</strong>触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p>
<p>如果页面的图片很多的话，从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验，此时<strong>DOMContentLoaded 事件</strong>比较合适。</p>
<h2 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.resize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ol>
<li>只要窗口大小发生变化，就会触发这个事件</li>
<li>我们经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕的宽度</li>
</ol>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout() 定时器"></a>setTimeout() 定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.setTimeout(调用函数,[延迟的毫秒数]);</span><br></pre></td></tr></table></figure>
<p>setTimeout()方法用于设置一个定时器，该定时器在定时器<strong>到期后执行调用函数</strong></p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>window 可省略</strong></li>
<li>这个调用函数可以<strong>直接写函数，或者写函数名</strong></li>
<li>延迟的毫秒数省略默认是0，如果写，必须是<strong>毫秒</strong></li>
</ol>
<p><strong>setTimeout()</strong> 这个调用函数我们称为<strong>回调函数 callback</strong> </p>
<p>普通函数就是按照代码顺序直接调用，而这个函数，需要<strong>等待时间</strong> ，时间到了才去调用这个函数，因此称为回调函数</p>
<p><strong>element.onclick=function(){}</strong> 或者 <strong>element.addEventListener(“click”,fn);</strong> 里面的函数也是回调函数</p>
<h2 id="停止-setTimeout-定时器"><a href="#停止-setTimeout-定时器" class="headerlink" title="停止 setTimeout()定时器"></a>停止 setTimeout()定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.clearTimeout(timeout)</span><br></pre></td></tr></table></figure>
<p><strong>clearTimeout()方法</strong>取消了先前通过调用setTimeout() 建立的定时器</p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>window可省略</strong></li>
<li>里面的参数就是<strong>计时器的标识符</strong></li>
</ol>
<h2 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval() 定时器"></a>setInterval() 定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.setInterval(回调函数,[间隔毫秒数]);</span><br></pre></td></tr></table></figure>
<p>setinterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。</p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>window可省略</strong></li>
<li>这个调用函数可以<strong>直接写函数，或者写函数名</strong></li>
<li>间隔的毫秒数省略默认是0，如果写，必须是毫秒。表示每个多少毫秒就自动调用这个函数</li>
<li>因为定时器可能有很多，所以我们<strong>经常给定时器赋值一个标识符</strong></li>
</ol>
<h2 id="停止-setInetval-计时器"><a href="#停止-setInetval-计时器" class="headerlink" title="停止 setInetval() 计时器"></a>停止 setInetval() 计时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.clearInterval(timeout)</span><br></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的<strong>最终指向的是那个调用它的对象</strong></p>
<ol>
<li>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</li>
</ol>
<h1 id="JS-执行队列"><a href="#JS-执行队列" class="headerlink" title="JS 执行队列"></a>JS 执行队列</h1><h2 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h2><p>JavaScript语言的一大特点就是<strong>单线程</strong>，也就是说，<strong>同一时间只能做一件事</strong>。这是因为JavaScript这门脚本语言诞生的使命所致 ——JavaScript是为处理页面中用户交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行，应该先进行添加，之后再删除</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p><strong>同步</strong></p>
<p>做一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p>
<p><strong>异步</strong></p>
<p>在做这件事的同时，还可以去处理其他事情。</p>
<p><strong>同步任务</strong></p>
<p>同步任务都在主线程上执行，形成一个<strong>执行栈</strong></p>
<p><strong>异步任务</strong></p>
<p>JS的异步任务是通过回调函数实现的</p>
<p>一般而言，异步任务有以下三种类型</p>
<ol>
<li>普通时间，如 onclick、resize等</li>
<li>资源加载，如 load、erroe等</li>
<li>定时器，包括 setInterval、setTimeout 等</li>
</ol>
<p>异步任务相关<strong>回调函数</strong>添加到<strong>任务队列</strong>中（任务队列也称为消息队列）</p>
<h2 id="JS-执行机制"><a href="#JS-执行机制" class="headerlink" title="JS 执行机制"></a>JS 执行机制</h2><ol>
<li>先执行<strong>执行栈中的同步任务</strong></li>
<li>异步任务（回调函数）放到任务队列中。</li>
<li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取<strong>任务队列</strong>中的异步任务，于是被读取的异步任务结束等待状态，开始执行</li>
</ol>
<pre class="mermaid">graph TD
A[执行栈]---A1["console.log(1)<br><br>setTimeout(fn,0)<br><br>console.log(2)"]-->A2["主车道"]
B[任务队列]---B1["&emsp;&emsp;&emsp;fn&emsp;&emsp;&emsp;"]-->B2["应急车道"]</pre>

<h1 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符（Uniform Resourse Locator,URL）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<p>URL的一般语法格式为：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">protocol:<span class="regexp">//</span>host[:port]<span class="regexp">/path/</span>[?query]<span class="comment">#fragment</span></span><br><span class="line">http:<span class="regexp">//</span>www.itcast.cn/index.html?name=andy&amp;age=<span class="number">10</span><span class="comment">#link</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocol</td>
<td>通信协议 常用的http、ftp、maito等</td>
</tr>
<tr>
<td>host</td>
<td>主机（域名）</td>
</tr>
<tr>
<td>port</td>
<td>端口号 可选，省略使用方案的默认端口 如http的默认端口为80</td>
</tr>
<tr>
<td>path</td>
<td>路径 由零个或多个’/‘符号隔开的字符，一般用来表示主机上的一个目录或文件地址</td>
</tr>
<tr>
<td>query</td>
<td>参数 以键值对的形式，通过&amp;符号分隔开来</td>
</tr>
<tr>
<td>fragment</td>
<td>片段 #后面内容常用于连接 锚点</td>
</tr>
</tbody>
</table>
</div>
<h2 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th>location对象属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>location.href</td>
<td>获取或者设置 整个URL</td>
</tr>
<tr>
<td>location.host</td>
<td>返回主机（域名）</td>
</tr>
<tr>
<td>location.port</td>
<td>返回端口号 如果未写返回空字符串</td>
</tr>
<tr>
<td>location.pathname</td>
<td>返回路径</td>
</tr>
<tr>
<td>location.search</td>
<td>返回参数</td>
</tr>
<tr>
<td>location.hash</td>
<td>返回片段 #后面内容 常用于链接 锚点</td>
</tr>
<tr>
<td>location.assign</td>
<td>跟href一样，可以跳转页面（也称为重定向页面）</td>
</tr>
<tr>
<td>location.replace</td>
<td>替换当前页面，因为不记录历史，所以不能后退界面</td>
</tr>
<tr>
<td>location.reload</td>
<td>重新加载页面，相当于刷新按钮或者f5 如果参数为true强制刷新 ctrl+f5</td>
</tr>
</tbody>
</table>
</div>
<h1 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h1><p>navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是<strong>userAgen</strong>t，该属性可以返回由客户机发送<strong>服务器的uer-agent 头部的值</strong></p>
<p>下面前端代码可以判断用户终端打开页面，实现跳转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">&quot;&quot;</span>; <span class="comment">//手机</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">&quot;&quot;</span>; <span class="comment">//电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h1><p>于浏览器历史记录进行交互，该对象包含用户（在浏览器窗口中）访问过的URL</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>history对象方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>back()</td>
<td>可以后退功能</td>
</tr>
<tr>
<td>forward()</td>
<td>前进功能</td>
</tr>
<tr>
<td>go(参数)</td>
<td>前进后退功能 参数如果是1前进1个页面 如果是-1后退一个页面</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基本结束</title>
    <url>/2021/07/23/CSS%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="154acc6670c3fccef6b5070cdeefb85ec2bfb1ab3262f6db66ad7844de5f0ea2">b932aaa1676845656e99a89ce5708d0a6d629f27376e686be0b7b81e242a554ca974cb7c0d19940d116aac2233fcde8c0eaaa3f436a53ab205c47dd54ff1d66cf3e524aec81cb572511195ff71a4c0e06e620fff646ae43ba520c1ae0f329c5dffba1e93b59f84a0c2e570805a0ed6ceb0b9ed142ef2b3b0e86f5b7c752329902963b266d8ecf12d7ce1be312d2bb6f9595f2b670482e5713110f82d2a2f865ca301078ffccbd1b588c0c1f26f4500ba867d1fde9951ff463ee5b992cc3f349d0d89b4caa0eb3460a8f1be637f6bc948af3229c57d9f719e0c0f45513e595a66df62e9da096655e355d51cdd32e2b3efd3308c1a2de4424c9e3e5f059bf33fa7a46d57972a8d440a32545d2ffa75a01f81c0af8979df87c4f26acc1d4182e2bad9cba8141bd49abfc20b5003ffd4cc257503ab6e6b033d9b7c0fd3b43c0fdc002b171748afd46465acc9c815726462deaab4dbb33bddef490b9c7ebd92c8fb6456f0514904c9ad8113f340dde00d732685885b2e385d031b479fe63577c4d1b23f5f8078b36cc740f42088e90928138f9009a40b4395864efa7a7c5bf260aaab586cdb5038261e732af4f590172a80da25ce2428968f4fb65d633565835c234e7af59c42688b6eee0a4af2bff261222e1db6e70c76de745169f21cb5f30ea07413b269bb6a5ee1db52c340716ce9bba780efec8c127d342e1cea8d9d512a0bad41dac05c1df697104b9b854bd2ee01ed388fcde9dd7e4b38c3eb175b252561738ae0951d66dad00017b3d289893ecedae8b0348ed5b8930c0d7d513ec5c5e2196be2e420b1b5765866346d897c46a35f5c7c75072171f6f05b0cd323c78f65bf566c218ed41b55ed0ab2627667a1fdc45e6b41eec9caeabead248b2511153f28354bc8e19bd4ba1e4f1704ea51360102836f9df69029f028da1f12148a752505951c45259c797f9de8d5e0b401388cee0a94db8142e48bd4c1b2366d5daaeb0fbb84b9a3f52f8bdedfdb35d196cff2348974898e43eea53d0f72e00324ac63e35678c1dbf387e26b0b339cc7586da82bf06dc4656343e1fd19432f90c8907a2f1b95a2a00c8621042b2008d6082630487f88b9d12f302398c16481dcef16ec9f191c35874ebf618b60d18d79773f906c8fd84e7216a0b72331f904acd594fc517029fb180ca3c98e7e86ece146ee0e0a4159fa9a6c04391f627d55b33897436374d348461462ef4f789ae835f58f6d15c5b1485b4aa5f45886cb6f36e960736961adf0e01bf40b7b0b027714074332d028120d2411d6cad85e08781323b8fa863b8a57ff2ae12df3a956da80abf1628af630961f7dd35630d958297b031fcef9a82584b1360332c9893e060e7c0db98bf9f223c1427dc94e0c78755f9ca67efb5c4c2e705a84a723e4552585b3177540098fa3dc14892f17359d695d21c22f9d7d275b35e6473ad3fe70ea3551d11c51279e50781b228df2bcd877ca1c98ec59e4be884a2b10172bfeb4745bd761ff636361b64117450f5354ceb458e18d94ae3c1f09cdbcb44806c07dbf4fd1dc6038867cf3f5e2ab5c15efa9c3b81f79c14e9b1ea0727b5646192aafe64b9368b4286304ed2c7e06f4f7e7bbdba109d3f0e21a401af9f92b78c706cb442726281fa0c2db860f43c3d95a73a22e8eb1f576a9291601e5ff37b0d155fbaccc523e9667b8ca9f57f82f5b5baea5ab6973aae819048c2379affe2d5a1ec62dfb5c76f2c693d191f357be27e7089fe9ee260a3822403441185a1c5c20a06d1878d50c0773bf45fbdf78b6d482037c3dab78c229f25b39eb21cc12de02f033836efdefc45fd83e53703d7d7be02a900e45c320f31fee52916d2aca92dfd5ebf07d7e8cee2ef14511d347eee5dbc8f10227e67c2d8065d736d9c84c3d89cab53af17d2dc36122ff644ca23213f13c6086a9cc4894a688d8dc565efe7b08e9871a0a4fe8f747e7f142f5d477c4e8704cb751934f44ddc981f34d4c0fb88226daa062e23a28d80533ea919232eeb851864988b2bba4fac817d208375c848ff4f0aeebff6a0b2c99bdb54301fc5f4bb27f1756a45ec8fe3b54e544a4ce764632bc019bc10bf6ed3d84cf00032c9ce42063fa3a5962bdabcd17ba2193f8186d638e942a6263c17fa85a67edff0f77166febbd88a4bb40eed61d3fdcbd7e01b40629cf64ec2612ed79e12fc538a1b99dd14728e8c0c6e6826fe7a4fa97d8ad5b1b46d117d7f15eec4a1c36c17f5c8c95b4df05fd0ec4d9fb28686bc585cdcafcb2a7718016c50c542c910944972a775f0d55b5a1c11b0ab4d1b0a78cf452a87af4530e484a41c50da2b767fba5fd311689b649f0027ecd9989e561d936ff78ca4e9852934b66e81b108bbecc5f27244fa8f0e196148af554db5eb1751ea9890a128401032bab179b1ef650bcdb2c65dcc445fbded5097c422968fb09191a7cb706debad66f67b83fdf295fa936b1474168cd4f83ed9c3d87</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM 基础</title>
    <url>/2021/09/07/DOM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>文档对象模型</strong>（Document Object Model,简称 <strong>DOM</strong>），是W3C组织推荐的处理可扩展标记语言（HTML或XML）的标准<strong>程序接口</strong></p>
<h1 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h1><pre class="mermaid">graph TD 
a[文档] --- b[根元素]
b --- c1[元素: &lt head &gt]
c1 --- d1[元素: &lttitle&gt]
d1 --- e1[ 文本: ''标题'']
b --- c2[元素: &lt body &gt]
c2 --- d2[元素: &lta&gt]
c2 --- d3[元素: &lth1&gt]
d2 --- e2[文本: ''链接'']
d2 --- e3[属性: href]
d3 --- e4[文本: ''标题'']</pre>

<span id="more"></span>
<h1 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h1><h2 id="根据ID获取"><a href="#根据ID获取" class="headerlink" title="根据ID获取"></a>根据ID获取</h2><p><strong>getElementById()方法</strong></p>
<ul>
<li>文档页面从上往下加载，所以要把script写在标签的下面</li>
<li><p>参数id是大小写敏感的字符串</p>
</li>
<li><p>返回的是一个元素对象</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;<span class="selector-tag">time</span>&quot;&gt;<span class="number">2019</span>-<span class="number">9</span>-<span class="number">9</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="selector-tag">var</span> timier = document<span class="selector-class">.GetElementById</span>(&#x27;<span class="selector-tag">time</span>&#x27;);</span><br><span class="line">	console<span class="selector-class">.log</span>(timer);</span><br><span class="line">	console<span class="selector-class">.dir</span>(timer);//打印返回元素对象 更好的查看里面的属性和方法</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="根据标签名获取"><a href="#根据标签名获取" class="headerlink" title="根据标签名获取"></a>根据标签名获取</h2><p><strong>getElemtsByTagName()方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ol = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;ol&#x27;</span>);</span><br><span class="line">ol.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="H5新增获取方式"><a href="#H5新增获取方式" class="headerlink" title="H5新增获取方式"></a>H5新增获取方式</h2><p><strong>getElementsByClassName(‘类名’)方法</strong></p>
<p>根据类名获得某些元素集合</p>
<p><strong>querySelector（‘选择器’）方法</strong></p>
<p>返回指定选择器的<strong>第一个</strong>元素对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstBox = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#nav&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;li&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>querySelectorAll(‘选择器’)方法</strong></p>
<p>返回指定选择器的<strong>所有</strong>元素对象</p>
<h2 id="获取特殊元素"><a href="#获取特殊元素" class="headerlink" title="获取特殊元素"></a>获取特殊元素</h2><p><strong>获取body元素</strong></p>
<p>document.body</p>
<p><strong>获取html元素</strong></p>
<p>document.documentElement</p>
<h1 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h1><h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul>
<li>事件源：事件被触发的对象</li>
<li>事件类型：如何触发该事件</li>
<li>事件处理程序：通过一个函数赋值的方式完成</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">button</span> id=&quot;btn&quot;&gt;点击&lt;/<span class="selector-tag">button</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="selector-tag">var</span> btn = document<span class="selector-class">.getElementById</span>(&#x27;btn&#x27;);</span><br><span class="line">	btn<span class="selector-class">.onclick</span> = function() &#123;</span><br><span class="line">    	alert(&#x27;完成&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">鼠标事件</th>
<th style="text-align:left">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onclick</td>
<td style="text-align:left">鼠标点击左键触发</td>
</tr>
<tr>
<td style="text-align:left">onmouseover</td>
<td style="text-align:left">鼠标经过触发</td>
</tr>
<tr>
<td style="text-align:left">onmouseout</td>
<td style="text-align:left">鼠标离开触发</td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:left">获得鼠标焦点触发</td>
</tr>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:left">失去鼠标焦点触发</td>
</tr>
<tr>
<td style="text-align:left">onmousemove</td>
<td style="text-align:left">鼠标移动触发</td>
</tr>
<tr>
<td style="text-align:left">onmouseup</td>
<td style="text-align:left">鼠标弹起触发</td>
</tr>
<tr>
<td style="text-align:left">onmousedown</td>
<td style="text-align:left">鼠标按下触发</td>
</tr>
</tbody>
</table>
</div>
<h1 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h1><h2 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a>改变元素内容</h2><p><strong>element.innerText() 方法</strong></p>
<p>从起始位置到终止位置的内容，但<strong>不识别html标签，同时空格和换行也会去掉</strong></p>
<p><strong>element.innerHTML()  方法</strong></p>
<p>起始到终止位置的全部内容，<strong>包括html标签，同时保留空格和换行</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    div.innerText = <span class="string">&#x27;2019-6-6&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见元素"><a href="#常见元素" class="headerlink" title="常见元素"></a>常见元素</h2><p>scr、href、title、alt等</p>
<h2 id="表单元素的属性操作"><a href="#表单元素的属性操作" class="headerlink" title="表单元素的属性操作"></a>表单元素的属性操作</h2><p>利用DOM可以操作如下表单元素的属性：</p>
<p>type、value、checked、selected、disabled</p>
<h2 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> element.style 行内样式操作</span><br><span class="line"><span class="number">2.</span> element.className 类名样式操作</span><br></pre></td></tr></table></figure>
<p>行内样式操作适合 <strong>样式较少</strong> 的时候</p>
<p>类名样式操作适合 <strong>样式较多</strong> 的时候</p>
<h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><ol>
<li><p><strong>获取属性值</strong></p>
<ul>
<li><p>element.属性：获取属性值</p>
</li>
<li><p>element.getAttribute(‘属性’);</p>
<p><strong>区别：</strong></p>
</li>
<li><p>element.属性：获取内置属性值（元素本身自带的属性）</p>
</li>
<li><p>element.getAttribute(‘属性’)：主要获得自定义的属性（标准） </p>
</li>
</ul>
</li>
<li><p><strong>设置属性值</strong></p>
<ul>
<li>element.属性 = ‘值’</li>
<li>element.setAttribute(‘属性’,’值’)：主要针对自定义属性</li>
</ul>
</li>
<li><p><strong>移除属性</strong></p>
<p>element.removeAttribute(‘index’)</p>
</li>
</ol>
<h2 id="h5自定义属性"><a href="#h5自定义属性" class="headerlink" title="h5自定义属性"></a>h5自定义属性</h2><p>H5规定自定义属性data-开头做为属性名且赋值</p>
<p>data-index=”2”</p>
<p><strong>获取自定义属性方法</strong></p>
<p>兼容性获取：element.getAttribute(‘data-index’);</p>
<p>H5新增element.dataset.index或者element.dataset[‘index’];</p>
<h1 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h1><p>获取元素的两种方式</p>
<ol>
<li>利用DOM提供的方法获取元素<ul>
<li>document.getElementById()</li>
<li>document.getElementByTagName()</li>
<li>document.querySelector()</li>
<li>缺点：逻辑性不强、繁琐</li>
</ul>
</li>
<li>利用节点层级关系获取元素<ul>
<li>利用父子兄节点关系获取元素</li>
<li>逻辑性强，但是兼容性稍差</li>
</ul>
</li>
</ol>
<h2 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h2><p>节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性</p>
<ul>
<li>元素节点 nodeType 为 1</li>
<li>属性节点 nodeType 为 2</li>
<li>文本节点 nodeType 为 3<strong>（文本节点包括文字、空格、换行等）</strong></li>
</ul>
<p>在实际开发中，节点操作主要操作的是<strong>元素节点</strong></p>
<h2 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h2><h3 id="父级节点"><a href="#父级节点" class="headerlink" title="父级节点"></a>父级节点</h3><p>node.parentNode</p>
<ul>
<li>parentNode 属性可返回某节点的父节点，注意是<strong>最近的一个父节点</strong></li>
<li>如果指定的节点没有父节点则返回null</li>
</ul>
<h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p><strong>获取所有子节点</strong></p>
<ul>
<li><p>parentNode.<strong>childNodes</strong> <strong>（标准，不常用）</strong></p>
<p>parentNode.childNodes得到的是集合</p>
<p><strong>注意：</strong> 返回值里面包含了所有子节点，包含元素节点，文本节点等</p>
<p>如果只想要获取里面的元素节点，则需要专门处理，所以<strong>不提倡使用</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; ul.childNodes.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ul.childeNodes[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//此时ul.childeNodes[i]是元素节点</span></span><br><span class="line">        <span class="built_in">console</span>.log(ul.childNodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>parentNode.<strong>children</strong> <strong>（不标准,常用）</strong></p>
<p>该方法可用于获取所有的<strong>子元素节点</strong></p>
</li>
</ul>
<p><strong>获取第一个最后一个子节点</strong></p>
<ul>
<li><p>parentNode.<strong>firstChild</strong></p>
</li>
<li><p>parentNode.<strong>lastChild</strong></p>
</li>
</ul>
<p>这是<strong>包含所有的节点</strong>的</p>
<ul>
<li>parentNode.<strong>firstElementChild</strong></li>
<li>parentNode.<strong>lastElementChild</strong></li>
</ul>
<p>只是包含<strong>元素节点</strong></p>
<p><strong>实际开发的写法</strong></p>
<p><strong>parentNode.children[i];</strong></p>
<p>最后一个子元素：parentNode.children<strong>[parentNode.children.length-1];</strong></p>
<h3 id="兄弟结点"><a href="#兄弟结点" class="headerlink" title="兄弟结点"></a>兄弟结点</h3><p>node.<strong>nextElementSibling</strong></p>
<p>nextElementSibling 返回当前元素下一个兄弟元素节点，找不到返回null</p>
<p>node.<strong>previousElementSibling</strong></p>
<p>previousElementSibling 返回当前元素上一个兄弟节点，找不到返回null</p>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><strong>document.createElement(‘tagName’)</strong></p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>node.<strong>appendChild(child)</strong></p>
<p>node.appendChild() 方法将一个节点添加到指定父节点的子节点列表<strong>末尾</strong></p>
<p>node.<strong>insertBefore(child,指定元素)</strong></p>
<p>node.insertBefore() 方法将一个节点添加父节点的指定子节点<strong>前面</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建节点元素节点</span></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 添加节点 node.appendChild(child) node 父级 child 子集 </span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.appendChild(li);</span><br><span class="line"><span class="comment">//3. 添加节点 node.insertBefore(child,指定元素)</span></span><br><span class="line"><span class="keyword">var</span> lili = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">ul.insertBefore(lili,ul.childre[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//4. 想要添加一个新元素：1.创建元素；2.添加元素</span></span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>node.<strong>removeChild(child)</strong></p>
<p>node.removeChild() 方法从DOM 中删除一个子节点，返回删除的节点</p>
<h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><p>node.<strong>cloneNode();</strong></p>
<p><strong>注意：</strong></p>
<p>1.如果括号为<strong>空或false</strong>，则是<strong>浅拷贝</strong>，即只复制节点本身，不克隆里面的子节点</p>
<p>2.如果括号参数为 <strong>true</strong>，则是<strong>深度拷贝</strong>，会复制节点本身以及里面的所有子节点</p>
<h2 id="三种创建元素的区别"><a href="#三种创建元素的区别" class="headerlink" title="三种创建元素的区别"></a>三种创建元素的区别</h2><ul>
<li><p><strong>document.write()</strong></p>
</li>
<li><p><strong>document.innerHTML()</strong></p>
</li>
<li><p><strong>document.createElement()</strong></p>
</li>
</ul>
<p>1.<strong>document.wirte()</strong> 是直接将内容写入页面的内容流，但是<strong>文档流执行完毕，则它会导致页面全部重绘</strong> </p>
<p>2.innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘</p>
<p>3.innerHTML 创建多个元素效率更高（<strong>不要拼接字符串，采用数组形式拼接</strong>），结构稍微复杂</p>
<p>4.createElement() 常见多个元素效率稍低一点点，但是结构更清晰</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol>
<li>document.write</li>
<li>innerHTML</li>
<li>createElement</li>
</ol>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ol>
<li>appendChild</li>
<li>innerBefore</li>
</ol>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ol>
<li>removeChild</li>
</ol>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>修改dom元素的属性，dom元素的内容、属性、表单的值等</p>
<ol>
<li>修改元素属性：src、href、title等</li>
<li>修改普通元素内容：innerHTML、innerText</li>
<li>修改表单元素：value、type、disabled等</li>
<li>修改元素样式：style、className</li>
</ol>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>主要获取查询dom元素</p>
<ol>
<li>DOM提供的API方法：getElementById、getElementByTagName <strong>不推荐</strong></li>
<li>H5提供的新方法：querySelector、querySelectorAll <strong>推荐</strong></li>
<li>利用节点操作元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）<strong>推荐</strong></li>
</ol>
<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><p>主要针对自定义属性</p>
<ol>
<li>setAttribute：设置DOM的属性值</li>
<li>getAttribute：得到DOM的属性值</li>
<li>removeAttribute 移除属性</li>
</ol>
<h2 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h2><p>给元素注册事件，采取 事件源.事件类型 = 事件处理程序</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">鼠标事件</th>
<th style="text-align:left">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onclick</td>
<td style="text-align:left">鼠标点击左键触发</td>
</tr>
<tr>
<td style="text-align:left">onmouseover</td>
<td style="text-align:left">鼠标经过触发</td>
</tr>
<tr>
<td style="text-align:left">onmouseout</td>
<td style="text-align:left">鼠标离开触发</td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:left">获得鼠标焦点触发</td>
</tr>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:left">失去鼠标焦点触发</td>
</tr>
<tr>
<td style="text-align:left">onmousemove</td>
<td style="text-align:left">鼠标移动触发</td>
</tr>
<tr>
<td style="text-align:left">onmouseup</td>
<td style="text-align:left">鼠标弹起触发</td>
</tr>
<tr>
<td style="text-align:left">onmousedown</td>
<td style="text-align:left">鼠标按下触发</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件高级</title>
    <url>/2021/09/13/DOM%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="注册事件（绑定事件）"><a href="#注册事件（绑定事件）" class="headerlink" title="注册事件（绑定事件）"></a>注册事件（绑定事件）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>给元素添加事件，称为注册事件或者绑定事件</p>
<p>注册事件有两种方式：<strong>传统方式</strong>和<strong>方法监听注册方式</strong></p>
<span id="more"></span>
<p><strong>传统注册方式</strong></p>
<ul>
<li>利用 on 开头的事件 onclick</li>
<li><p>&lt;button onclick=”alert(‘hello’)”&gt; &lt;/button&gt;</p>
</li>
<li><p>btn.onclick = function() {}</p>
</li>
<li>特点：注册事件的<strong>唯一性</strong></li>
<li>同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会<strong>覆盖前面注册的处理函数</strong></li>
</ul>
<p><strong>方法监听注册方式</strong></p>
<ul>
<li>w3c标准 推荐方式</li>
<li>addEventListener()它是一个方法</li>
<li>特点：同一个元素同一个事件可以注册多个监听器</li>
<li>按注册顺序依次执行</li>
</ul>
<h2 id="addEventListener-事件监听方式"><a href="#addEventListener-事件监听方式" class="headerlink" title="addEventListener 事件监听方式"></a>addEventListener 事件监听方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventTarget.addEventListener(<span class="string">&#x27;type&#x27;</span>,listener[,useCapture])</span><br></pre></td></tr></table></figure>
<p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数</p>
<ul>
<li><strong>type：</strong> 事件类型<strong>字符串</strong>，比如’click’、’mouseover’, <strong>注意这里不要带on</strong> </li>
<li><strong>listener：</strong> 事件处理函数，事件发生时，会调用该监听函数</li>
<li><strong>useCapture：</strong> 可选参数，是一个布尔值，默认是false</li>
</ul>
<h1 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h1><p>让事件完成一次之后就不再进行</p>
<p><strong>1.传统方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventTarget.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2.方法监听注册方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventTarget.removeEventListener(type,listener[,useCapture]);</span><br></pre></td></tr></table></figure>
<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p> <strong>事件流</strong>描述的是从页面中接收事件的顺序</p>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即<strong>DOM 事件流</strong></p>
<p>DOM 事件流分为3个阶段：</p>
<ol>
<li>捕获阶段</li>
<li>当前目标阶段</li>
<li>冒泡阶段</li>
</ol>
<ul>
<li>事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程，可以想象把一颗石头投入水中，泡泡会一直从水底冒出水面。</li>
<li>事件捕获：由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程</li>
</ul>
<p><strong>注意</strong></p>
<p>1.JS代码中只能执行<strong>捕获</strong>或者<strong>冒泡</strong>其中的一个阶段</p>
<p>2.onclick 和 attachEvent 只能得到<strong>冒泡阶段</strong></p>
<p>3.addEventListener(type,listener[,usecapture])第三个参数如果是true，表示在事件<strong>捕获阶段</strong>调用事件处理程序；如果是false（不写默认就是false），表示在事件<strong>冒泡阶段</strong>调用事件处理程序</p>
<h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventTarget.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;</span><br><span class="line">eventTarget.addEventListeners(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 这个event就是事件对象，能写成 e 或evt，因为这个数是形参所以可以变化</span></span><br></pre></td></tr></table></figure>
<p>事件对象解释：事件发生后，<strong>跟事件相关的一系列信息数据的集合</strong>都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法</p>
<h2 id="事件对象的常见属性和方法"><a href="#事件对象的常见属性和方法" class="headerlink" title="事件对象的常见属性和方法"></a>事件对象的常见属性和方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>事件对象属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>e.target</td>
<td>返回触发时间的对象               标准</td>
</tr>
<tr>
<td>e.type</td>
<td>返回时间的类型，比如 click mouseover 不带on</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>该方法阻止默认事件（默认行为） 标准   <br>比如不让链接跳转</td>
</tr>
<tr>
<td>e.stopPropagation()</td>
<td>阻止冒泡  标准</td>
</tr>
</tbody>
</table>
</div>
<h1 id="事件委托（代理，委托）"><a href="#事件委托（代理，委托）" class="headerlink" title="事件委托（代理，委托）"></a>事件委托（代理，委托）</h1><p>事件冒泡本身的特性，会带来坏处，也会带来好处</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>不是给每个子节点单独设置事件监听器</strong>，而是事件监听器<strong>设置在其父节点</strong>上，然后利用<strong>冒泡原理影响设置每个子节点</strong></p>
<p><strong>作用</strong></p>
<p>只操作了一次DOM，不用使用循环，提高了程序的性能</p>
<h1 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h1><p><strong>event</strong>对象代表时间的状态，跟事件相关的一系列信息的集合</p>
<p>鼠标事件对象 <strong>MouseEvent</strong> 和键盘事件对象 <strong>KeyboardEvent</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>鼠标事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>e.clientX</td>
<td>返回鼠标相对于浏览器窗口可视区的 X 坐标</td>
</tr>
<tr>
<td>e.clientY</td>
<td>返回鼠标相对于浏览器窗口可视区的 Y 坐标</td>
</tr>
<tr>
<td>e.pageX</td>
<td>返回鼠标相对于文档页面的 X 坐标</td>
</tr>
<tr>
<td>e.pageY</td>
<td>返回鼠标相对于文档页面的 Y 坐标</td>
</tr>
<tr>
<td>e.screenX</td>
<td>返回鼠标相对于电脑屏幕的 X 坐标</td>
</tr>
<tr>
<td>e.screenY</td>
<td>返回鼠标相对于电脑屏幕的 Y 坐标</td>
</tr>
</tbody>
</table>
</div>
<h1 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h1><p>事件除了使用鼠标触发，还可以使用键盘出发</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>onkeyup</td>
<td>某个键盘按键被<strong>松开</strong>时触发</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被<strong>按下</strong>时触发</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键被<strong>按下</strong>时触发  <strong>但不识别功能键 比如 ctrl shift 箭头等</strong></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题(C语言实现)</title>
    <url>/2021/11/03/Leetcode%E5%88%B7%E9%A2%98-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br><span class="line">解释：因为 nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> == 9 ，返回 <span class="comment">[0, 1]</span> 。</span><br></pre></td></tr></table></figure>
<p>这一题思路其实很容易想到二重循环来进行暴力破解</p>
<span id="more"></span>
<p><strong>暴力破解</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> *result=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">            &#123;</span><br><span class="line">                 result=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">                 result[<span class="number">0</span>]=i;</span><br><span class="line">                 result[<span class="number">1</span>]=j;</span><br><span class="line">                 *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：88 ms</p>
<p>内存消耗：6.4 MB</p>
<p>当然还有优化方法，通过二分查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//结构体用来保存数值和在原始数组中的下标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nums</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a,<span class="keyword">const</span> <span class="keyword">void</span>*b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(struct Nums*)a).num-(*(struct Nums*)b).num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(struct Nums *N,<span class="keyword">int</span> low,<span class="keyword">int</span> numsSize,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> high=numsSize<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (N[mid].num==x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (N[mid].num&gt;x) high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Nums</span> <span class="title">N</span>[<span class="title">numsSize</span>];</span></span><br><span class="line">    <span class="comment">//将原始数组和下标信息复制到结构体数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        N[i].num=nums[i];</span><br><span class="line">        N[i].pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(N,numsSize,<span class="keyword">sizeof</span>(struct Nums),cmp);<span class="comment">//C库函数，对数组进行排序</span></span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p=search(N,i+<span class="number">1</span>,numsSize,target-N[i].num);</span><br><span class="line">        <span class="keyword">if</span> (p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> *result=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">            result[<span class="number">0</span>]=N[i].pos;</span><br><span class="line">            result[<span class="number">1</span>]=N[p].pos;</span><br><span class="line">            *returnSize=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：8 ms</p>
<p>内存消耗：6.5 MB</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>三、Class 与 Style 绑定</title>
    <url>/2021/10/05/Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下笔记均来自<a href="https://cn.vuejs.org/">Vue</a>官网教程，为了方便记忆，自己进行了整理</p>
</blockquote>
<h2 id="3-1-绑定-HTML-Class"><a href="#3-1-绑定-HTML-Class" class="headerlink" title="3.1. 绑定 HTML Class"></a>3.1. 绑定 HTML Class</h2><h3 id="3-1-1-对象语法"><a href="#3-1-1-对象语法" class="headerlink" title="3.1.1. 对象语法"></a>3.1.1. 对象语法</h3><p><strong>html部分：</strong></p>
<p><code>v-bind:class</code> <strong>可以传递一个js对象</strong>，来动态的切换class：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面<code>active</code> 是否执行取决于 <code>isActive</code> 是否为真值。</p>
<p><code>v-bind</code>动态绑定的 class 也可以和普通 class 的共存</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static&quot;</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>js部分：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    <span class="attr">isActive</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终渲染成</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<span id="more"></span>
<p><strong>直接绑定到一个样式对象通常更好：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-数组语法"><a href="#3-1-2-数组语法" class="headerlink" title="3.1.2. 数组语法"></a>3.1.2. 数组语法</h3><p><code>v-bind:class</code> <strong>也可以传递一个js数组，</strong>以应用一个 class 列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 当然也可以在里面使用三元表达式切换 class</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-用在组件上"><a href="#3-1-3-用在组件上" class="headerlink" title="3.1.3. 用在组件上"></a>3.1.3. 用在组件上</h3><h2 id="3-2-绑定内联样式-Sytle"><a href="#3-2-绑定内联样式-Sytle" class="headerlink" title="3.2. 绑定内联样式 Sytle"></a>3.2. 绑定内联样式 Sytle</h2><h3 id="3-2-1-对象语法"><a href="#3-2-1-对象语法" class="headerlink" title="3.2.1. 对象语法"></a>3.2.1. 对象语法</h3><p><code>v-bind:style</code> <strong>可以传递一个js对象</strong>。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#x27;red&#x27;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>直接绑定到一个样式对象通常更好：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &#x27;red&#x27;,</span><br><span class="line">    fontSize: &#x27;13px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-数组语法"><a href="#3-2-2-数组语法" class="headerlink" title="3.2.2. 数组语法"></a>3.2.2. 数组语法</h3><p><code>v-bind:style</code> <strong>也可以传递一个js数组，</strong> 通过这种方法可以在一个元素上绑定多个样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-自动添加前缀"><a href="#3-2-3-自动添加前缀" class="headerlink" title="3.2.3. 自动添加前缀"></a>3.2.3. 自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加 <strong>浏览器引擎前缀 </strong>的 CSS property 时，如 <code>transform</code>，<strong>Vue.js 会自动侦测并添加相应的前缀</strong>。</p>
<h3 id="3-2-4-多重值"><a href="#3-2-4-多重值" class="headerlink" title="3.2.4. 多重值"></a>3.2.4. 多重值</h3><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样写<strong>只会渲染数组中最后一个被浏览器支持的值</strong>。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>PC端网页特效</title>
    <url>/2021/09/20/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="元素偏移量-offset-系列"><a href="#元素偏移量-offset-系列" class="headerlink" title="元素偏移量 offset 系列"></a>元素偏移量 offset 系列</h1><h2 id="offset-概述"><a href="#offset-概述" class="headerlink" title="offset 概述"></a>offset 概述</h2><p>通过offset系列相关属性可以<strong>动态地</strong>得到该元素的位置（偏移）、大小等。</p>
<ul>
<li>获得元素距离带有定位父元素的位置</li>
<li>获得元素自身的大小（宽度高度）</li>
<li>注意：返回的数值都不带单位</li>
</ul>
<span id="more"></span>
<p>offset 系列常用属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>offset系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.offsetParent</td>
<td>返回作为该元素带有定位的父级元素 如果父级都没有定位则返回body</td>
</tr>
<tr>
<td>element.offsetTop</td>
<td>返回元素<strong>相对带有定位父元素</strong>上方的偏移</td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>返回元素<strong>相对带有定位父元素</strong>左边框的偏移</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>返回<strong>自身</strong>包括padding、边框、内容区的宽度，返回数值<strong>不带单位</strong></td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>返回<strong>自身</strong>包括padding、边框、内容区的高度，返回数值<strong>不带单位</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="offset-与-style-的区别"><a href="#offset-与-style-的区别" class="headerlink" title="offset 与 style 的区别"></a>offset 与 style 的区别</h2><p><strong>offset</strong></p>
<ul>
<li>offset 可以得到任意样式表中的样式值</li>
<li>offset 系列获得的数值是没有单位的</li>
<li>offsetWidth 包含padding+border+width</li>
<li>offsetWidth 等属性是只读属性，只能获取不能赋值</li>
<li><strong>所以想要获取元素大小位置，用offset更合适</strong></li>
</ul>
<p><strong>style</strong></p>
<ul>
<li>style 只能得到行内样式表中的样式值</li>
<li>style.width 获得的是带有单位的字符串</li>
<li>style.width 获得不包含padding和border的值</li>
<li>style.width 是可读写属性，可以获取也可以赋值</li>
<li><strong>所以想要给元素更改值，需要用style改变</strong></li>
</ul>
<h1 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h1><p>使用 client 系列的相关属性来获取元素可视区的相关信息，通过 client 系列的相关属性可以动态的得到该元素的边框大小，元素大小等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>client 系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.clientTop</td>
<td>返回元素上边框的大小</td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>返回元素左边框的大小</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回<strong>自身</strong>包括padding、内容区的宽度，不含边框，返回<strong>数值不带单位</strong></td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>返回<strong>自身</strong>包括padding、内容区的高度，不含边框，返回<strong>值不带单位</strong></td>
</tr>
</tbody>
</table>
</div>
<h1 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h1><p>立即执行函数：不需要调用，立马能够自己执行的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)() 或 (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;()); </span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)(<span class="number">1</span>)<span class="comment">//第二个小括号可以看作是调用函数</span></span><br></pre></td></tr></table></figure>
<p>立即执行函数<strong>最大的作用就是独立创建了一个作用域</strong>，避免了命名冲突问题 </p>
<h1 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h1><h2 id="元素-scroll-系列属性"><a href="#元素-scroll-系列属性" class="headerlink" title="元素 scroll 系列属性"></a>元素 scroll 系列属性</h2><p>使用scroll系列的相关属性可以动态的得到</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>scroll系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.scrollTop</td>
<td>返回被卷去的上侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>返回被卷去的左侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身实际的宽度，不含边框，返回值不带单位</td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>返回自身实际的高度，不含边框，返回值不带单位</td>
</tr>
</tbody>
</table>
</div>
<p>window.pageYOffset</p>
<p>window.pageXOffset</p>
<h1 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h1><div class="table-container">
<table>
<thead>
<tr>
<th>三大系列大小对比</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>element.offserWidth</td>
<td>返回自身包括padding、边框、内容区的宽度，返回值不带单位</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身实际的宽度，不含边框，返回值不带单位</td>
</tr>
</tbody>
</table>
</div>
<p>他们主要用法：</p>
<ol>
<li>offset系列经常用于获得元素位置 <strong>offsetLeft、offsetTop</strong></li>
<li>client经常用于获取元素大小 <strong>clientWidth、clientHeight</strong></li>
<li>scroll经常用于获取滚动条距离 <strong>scrollTop、scrollLeft</strong></li>
<li><strong>注意页面滚动的距离通过 window.pageXOffset 获得</strong></li>
</ol>
<h1 id="mouseenter-和-mouseover-的区别"><a href="#mouseenter-和-mouseover-的区别" class="headerlink" title="mouseenter 和 mouseover 的区别"></a>mouseenter 和 mouseover 的区别</h1><h2 id="mouseenter-鼠标事件"><a href="#mouseenter-鼠标事件" class="headerlink" title="mouseenter 鼠标事件"></a>mouseenter 鼠标事件</h2><ul>
<li>当鼠标移动到元素上时就会触发 mouseenter 时间</li>
<li>类似 mouseover ，它们两者之间的差别是：mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter 只会经过自身盒子触发，<strong>之所以这样，就是因为mouseenter不会冒泡</strong></li>
</ul>
<h1 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h1><h2 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h2><p><strong>核心原理：</strong>通过定时器setinterval()不断移动盒子位置</p>
<p>实现步骤：</p>
<ol>
<li>获得盒子当前位置</li>
<li>让盒子在当前位置加上1个移动距离</li>
<li>利用定时器不断重复这个操作</li>
<li>加一个结束定时器的条件</li>
<li>注意此元素需要添加定位，才能使用element.style.left</li>
</ol>
<h2 id="动画函数简单封装"><a href="#动画函数简单封装" class="headerlink" title="动画函数简单封装"></a>动画函数简单封装</h2><p>注意函数需要传递2个参数，<strong>动画对象</strong>和<strong>移动到的距离</strong></p>
<h1 id="常见网页特效案例"><a href="#常见网页特效案例" class="headerlink" title="常见网页特效案例"></a>常见网页特效案例</h1><h2 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h2><p>防止轮播图按钮连续点击造成播放过快</p>
<p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发</p>
<p><strong>核心思路：</strong> 利用回调函数，添加一个变量来控制，锁住函数和解锁函数</p>
<p>开始设置一个变量 var flag = true;</p>
<p>if(flag){flag=false;do something}   关闭水龙头</p>
<p>利用回调函数 动画执行完毕，flag=true  打开水龙头</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2021/10/31/axios/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>功能特点：</p>
<ul>
<li>在浏览器中发送XMLHttpRequests 请求</li>
<li>在 node.js 中发送 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>···········</li>
</ul>
<span id="more"></span>
<h1 id="axios-请求方式"><a href="#axios-请求方式" class="headerlink" title="axios 请求方式"></a>axios 请求方式</h1><ul>
<li><code>axios(config)</code></li>
<li><code>axios.request(config)</code></li>
<li><code>axios.get(url[,config])</code></li>
<li><code>axios.delete(url[,config])</code></li>
<li><code>axios.head(url[,config])</code></li>
<li><code>axios.post(url[,data[,config]])</code></li>
<li><code>axios.put(url[,data[,config]])</code></li>
<li><code>axios.patch(url[,data[config]])</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  <span class="comment">//专门针对get请求的参数拼接</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="attr">page</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">      <span class="attr">page</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其实就是把请求的几个数据封装在数组中</p>
<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><h2 id="常见配置选项"><a href="#常见配置选项" class="headerlink" title="常见配置选项"></a>常见配置选项</h2><p><strong>请求地址</strong></p>
<p><code>url:&#39;/user&#39;</code></p>
<p><strong>请求类型</strong></p>
<p><code>method:&#39;get&#39;</code></p>
<p><strong>请根路径</strong></p>
<p><code>baseURL:&#39;http://www.mt.com/api&#39;</code></p>
<p><strong>请求前的数据处理</strong></p>
<p><code>trasformRequest:[function(data)&#123;&#125;]</code></p>
<p><strong>请求后的数据处理</strong></p>
<p><code>transformResponse: [function(data)&#123;&#125;]</code></p>
<p><strong>自定义的请求头</strong></p>
<p><code>headers:&#123;&#39;x-Requested&#39;:&#39;XMLHttpRequest&#39;&#125;</code></p>
<p><strong>URL查询对象</strong></p>
<p><code>params:&#123;id:12&#125;</code></p>
<p> ······················</p>
<h1 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h1><p>由于第三方插件存在停止维护等问题，我们在使用的时候需要降低它和应用之间的耦合度</p>
<p>所以说这里要对axios进行模块化封装</p>
<p>创建一个network文件夹专门储存网络相关的东西</p>
<p>在其下建立一个文件request.js，里面对axios进行一些封装</p>
<p><strong>1、使用回调函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    instance(config)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            success(res)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            failure(err);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request&#x27;</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>2、改进：转递一个对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    instance(config.baseConfig)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            config.success(res)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            config.failure(err);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request&#x27;</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">baseConfig</span>: &#123;···&#125;,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;···&#125;,</span><br><span class="line">  <span class="function"><span class="title">failure</span>(<span class="params">err</span>)</span> &#123;···&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>3、使用Promise</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            <span class="attr">baseURL</span>: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">            <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">        instance(config)</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(res);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request&#x27;</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>4、最简单的方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于axios返回的是Promise对象，所以说这里可以直接将它进行返回</p>
<h1 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h1><p>axios 提供了拦截器，用于我们在发送每次请求或者得到相应结果后，进行对应的处理</p>
<p><strong>1、请求拦截：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong></p>
<ol>
<li>比如config中的一些信息不符合服务器的要求</li>
<li>比如每次发送网络请求时，都希望在界面显示一个请求图标</li>
<li>某些网络请求（ 比如登录(token) ），必须携带一些特殊的信息</li>
</ol>
<p><strong>2、响应拦截：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> res.data;</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/10/24/Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在了解异步编程之前，我们先了解一下回调函数</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数就是一个通过函数指针调用的函数</p>
<p>或者说是就是一个被作为参数传递的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.onload = <span class="function">() =&gt;</span> callback(script);</span><br><span class="line">  <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadScript(<span class="string">&#x27;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js&#x27;</span>, <span class="function"><span class="params">script</span> =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`Cool, the script <span class="subst">$&#123;script.src&#125;</span> is loaded`</span>);</span><br><span class="line">  alert( _ ); <span class="comment">// 所加载的脚本中声明的函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们发现这里<code>loadScript</code>的第二个参数<code>callback</code>其实是一个函数，这个 <code>callback</code> 也就是回调函数</p>
<span id="more"></span>
<p>这被称为“基于回调”的异步编程风格。异步执行某项功能的函数应该提供一个 <code>callback</code> 参数用于在相应事件完成时调用</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><ul>
<li>fs 文件操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).readFile(<span class="string">&#x27;./index.html&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据库操作</p>
</li>
<li><p>AJAX</p>
</li>
<li>定时器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是<strong>异步编程</strong>的一种解决方案</p>
<p>以前使用的是单纯的回调函数</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>首先我们要明确，<strong>Promise就是将生产者代码和消费者代码联系在一起的特殊的JavaScript对象</strong></p>
<p>生产者代码（producing code）：会做一些事，并且会需要一些时间。例如，通过网络加载数据的代码，它就像一位 “歌手”</p>
<p>消费者代码（consuming code）：想要在生产者代码完成工作的第一时间就能够获得其工作成果。许多函数可能都需要这个结果。这些就是 “粉丝”</p>
<h3 id="Promise的对象构造器语法"><a href="#Promise的对象构造器语法" class="headerlink" title="Promise的对象构造器语法"></a>Promise的对象构造器语法</h3><p><strong>生产者</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// executor (producing code)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>它的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调。我们的代码仅在 executor 的内部。</p>
<h3 id="消费者：then，catch，finally"><a href="#消费者：then，catch，finally" class="headerlink" title="消费者：then，catch，finally"></a>消费者：then，catch，finally</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//handle a successful result</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">erro</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//handle an error</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>.then</code>的第一个和第二个参数都是一个<strong>函数</strong>，第一个<strong>接受结果</strong>，第二个接受error</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>如果只对error感兴趣，那么我们可以使用 <code>null</code> 作为第一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="literal">null</span>,errorHandlingFunction)</span><br></pre></td></tr></table></figure>
<p>或者我们可以使用<code>.catch</code>，二者是一样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.catch(errorHandlingFunction)</span><br></pre></td></tr></table></figure>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p><code>.finally(f)</code> 调用与 <code>.then(f, f)</code> 类似，在某种意义上，<code>f</code> 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject。</p>
<p><code>finally</code> 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）。</p>
<p>像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 做一些需要时间的事儿，然后调用 resolve/reject */</span></span><br><span class="line">&#125;)</span><br><span class="line">  <span class="comment">// 在 promise 为 settled 时运行，无论成功与否</span></span><br><span class="line">  .finally(<span class="function">() =&gt;</span> stop loading indicator)</span><br><span class="line">  <span class="comment">// 所以，加载指示器（loading indicator）始终会在我们处理结果/错误之前停止</span></span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> show result, <span class="function"><span class="params">err</span> =&gt;</span> show error)</span><br></pre></td></tr></table></figure>
<p>也就是说，<code>finally(f)</code> 其实并不是 <code>then(f,f)</code> 的别名。它们之间有一些细微的区别：</p>
<ol>
<li><p><code>finally</code> 处理程序（handler）没有参数。在 <code>finally</code> 中，我们不知道 promise 是否成功。没关系，因为我们的任务通常是执行“常规”的定稿程序（finalizing procedures）。</p>
</li>
<li><p><code>finally</code> 处理程序将结果和 error 传递给下一个处理程序。</p>
<p>例如，在这儿结果被从 <code>finally</code> 传递给了 <code>then</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;result&quot;</span>), <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> alert(<span class="string">&quot;Promise ready&quot;</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> alert(result)); <span class="comment">// &lt;-- .then 对结果进行处理</span></span><br></pre></td></tr></table></figure>
<p>在这儿，promise 中有一个 error，这个 error 被从 <code>finally</code> 传递给了 <code>catch</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> alert(<span class="string">&quot;Promise ready&quot;</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> alert(err));  <span class="comment">// &lt;-- .catch 对 error 对象进行处理</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这非常方便，因为 <code>finally</code> 并不是意味着要处理 promise 的结果。所以它将结果传递了下去。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h4 id="支持链式调用，可以解决回调地狱问题"><a href="#支持链式调用，可以解决回调地狱问题" class="headerlink" title="支持链式调用，可以解决回调地狱问题"></a>支持链式调用，可以解决回调地狱问题</h4><p><strong>回调地狱</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">asyncFunc1(opt,<span class="function">(<span class="params">...args1</span>)=&gt;</span>&#123;</span><br><span class="line">    asyncFunc2(opt,<span class="function">(<span class="params">...args2</span>)=&gt;</span>&#123;</span><br><span class="line">        asyncFunc3(opt,<span class="function">(<span class="params">...args3</span>)=&gt;</span>&#123;</span><br><span class="line">            asynFunc4(opt,<span class="function">(<span class="params">...args4</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//some operationg</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这中嵌套的异步任务有很多缺点</p>
<ul>
<li>不便于阅读，嵌套太多</li>
<li>不便于异常处理</li>
</ul>
<p>所以我们可以用一种方法，让这种嵌套调用改变为链式调用的这种线性关系，而Promise对象就是这样</p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p><strong>直接使用 <code>setTimeout()</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = rand(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>使用 <code>Promise</code> 对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//resolve 解决 函数类型的数据</span></span><br><span class="line"><span class="comment">// reject 拒绝 函数类型的数据</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//读取1 - 100的一个随机数 </span></span><br><span class="line">        <span class="keyword">let</span> n = rand(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">30</span>) &#123;</span><br><span class="line">            resolve(n);</span><br><span class="line">        <span class="comment">// 将 promise 对象的状态设置为成功，可以传递参数，参数就是后面</span></span><br><span class="line">       </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            reject(n);</span><br><span class="line">         <span class="comment">// 将 promise 对象的状态设置为失败</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用then方法</span></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//成功使用第一个</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>,value);</span><br><span class="line">&#125;,<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//失败使用第二个</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;fail&quot;</span>,value); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-三种状态"><a href="#Promise-三种状态" class="headerlink" title="Promise 三种状态"></a>Promise 三种状态</h2><p><strong>pending</strong>：<strong>等待状态</strong>，比如正在进行网络请求，或者定时器没有到时间</p>
<p><strong>fulfil</strong>：<strong>满足状态</strong>，当我们主动回调了resolve时，就处于该状态，并且会回调<code>.then()</code></p>
<p><strong>reject</strong>：<strong>拒绝状态</strong>，当我们主动回调了reject时，就处于该状态，并且会回调<code>.catch()</code></p>
<p><strong>sync==&gt;同步</strong></p>
<p><strong>async==&gt;异步</strong></p>
<h2 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>); <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">// (**)</span></span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">// (***)</span></span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里就是返回值一直被传入到下一个<code>.then</code>处理程序（handler）</p>
<h3 id="返回-promise"><a href="#返回-promise" class="headerlink" title="返回 promise"></a>返回 promise</h3><p><code>.then(handler)</code> 中所使用的处理程序（handler）可以创建并返回一个 promise</p>
<p>在这种情况下，其他 handler 将等待它完成后再获得其结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// (*)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">// (**)</span></span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>返回promise的特点就是在消费者代码最后的返回值，都是一个生产者代码，这样就可以让我们能够构建异步行为链</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>end</title>
    <url>/2021/06/24/end/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>线性代数的内容已经基本结束，但是后面还会对于一些细节进行扩充，并结合一些几何知识进行分析，当然今后也会结合线性代数这一工具来学习高数等知识，并对其用处进行深入研究……</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2021/10/22/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/15/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>vue-router</title>
    <url>/2021/10/19/vue-router/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="认识路由"><a href="#认识路由" class="headerlink" title="认识路由"></a>认识路由</h1><ul>
<li>路由是一个网络工程里面的术语</li>
<li>路由（routing）就是通过互联的网络把信息从<strong>源地址</strong>传输到<strong>目的地址</strong>的活动</li>
</ul>
<p>我们生活中用到的路由器就提供了两种机制：路由和转送</p>
<ul>
<li><p>路由是决定数据包从<strong>来源</strong>到<strong>目的地</strong>的路径</p>
</li>
<li><p>转送将<strong>输入端</strong>的数据转移到合适的<strong>输出端</strong></p>
</li>
</ul>
<p>路由中有一个非常重要的概念叫<strong>路由表</strong></p>
<ul>
<li>路由表本质上就是一个映射表，决定了数据包的指向。</li>
</ul>
<span id="more"></span>
<h1 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h1><blockquote>
<p>后端处理<strong>URL</strong>和<strong>页面</strong>之间的<strong>映射</strong>关系</p>
</blockquote>
<p>早期的网站开发整个HTML页面是由服务器来渲染的</p>
<ul>
<li>服务器直接生产渲染好对应的HTML页面，返回给客户端进行展示</li>
</ul>
<p>但是，一个网站，这么多页面服务器如何处理呢？</p>
<ul>
<li>一个页面有自己对应的网址，也就是URL</li>
<li><strong>URL会发送到服务器</strong>，服务器会通过正则对该URL进行匹配，并且最后交给一个Controller进行处理</li>
<li>Controller进行各种处理，最终生成的HTML或者数据，返回给前端</li>
<li>这就完成了一个IO操作</li>
</ul>
<p>上面的这种操作就是后端路由</p>
<p>后端路由的<strong>缺点</strong>：</p>
<ul>
<li>一种情况是整个页面的模块都是由后端人员来编写和维护的</li>
<li>另一种情况是前端开发人员如果开发页面，需要通过PHP和Java等语言来编写页面代码</li>
<li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起，编写和维护都是非常糟糕的事情</li>
</ul>
<h1 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h1><blockquote>
<p>浏览器中显示网页的大部分内容，都是由前端写的 js 代码在浏览器中执行，最终渲染出来的</p>
</blockquote>
<p>随着Ajax的出现，有了前后端分离的开发模式</p>
<p><strong>后端只提供API来返回数据</strong>，<strong>前端通过Ajax获取数据</strong>，并且可以通过JavaScript将数据渲染到页面中</p>
<p>这样做最大的优点是前后端责任的清晰，后端不需要进行任何处理，依然使用之前的一套API即可</p>
<p>目前很多的网站依然采用这种模式开发</p>
<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><blockquote>
<p>前端路由就是<strong>URL和页面的映射关系由前端进行管理</strong></p>
</blockquote>
<p>核心就是改变URL，但是页面不进行整体的刷新</p>
<p>这样就减轻了向服务器请求的次数，虽然消耗本地电脑的性能，但是由于现在个人电子设备算力快速发展，所以不需要担心，而这也是非常可取的方案。</p>
<h2 id="单页面复应用阶段"><a href="#单页面复应用阶段" class="headerlink" title="单页面复应用阶段"></a>单页面复应用阶段</h2><blockquote>
<p>整个页面只有一个html页面</p>
</blockquote>
<p>我们可以通过搭建一个 vue-cli，然后通过vue-router实现单页面复应用。 </p>
<p>其实 <strong>SPA</strong> 最主要的特点就是在前后端分离的基础上<strong>加了一个前端路由</strong></p>
<p>也就是前端来维护一套路由规则</p>
<h1 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue-router"></a>安装vue-router</h1><p>通过<code>npm install vue-router --save</code> 进行安装</p>
<h1 id="vue-router-实现原理"><a href="#vue-router-实现原理" class="headerlink" title="vue-router 实现原理"></a>vue-router 实现原理</h1><p>首先来看一下vue-router是如何定义的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">cosnt router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[···],<span class="comment">//创建路由实例，并且传入路由映射配置</span></span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;<span class="comment">//在Vue实例中挂载创建的路由实例</span></span><br><span class="line">    router</span><br><span class="line">    ···</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>因为是一个插件，所以可以通过<code>Vue.use()</code>将路由功能注入到Vue实例中，在使用的时候，我们全局要用到 <code>vue-router</code> 的 <code>router-view</code> 和 <code>router-link</code> 组件，以及 <code>this.$router/$route</code>  这样的实例对象</p>
<ul>
<li><code>&lt;router-link&gt;</code>：vue-router内置组件，它会被渲染成一个 <code>&lt;a&gt;</code>  标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;router-view&gt;</code>：该标签会根据当前的路径，动态渲染出不同的组件</li>
</ul>
<p>网页的其他内容，比如顶部的标题/导航，或者底部的一些版权信息等会和 <code>&lt;router-view&gt;</code>处于同一个等级</p>
<p>在路由切换时，切换的是 <code>router-view</code> 挂载的组件，其他内容不会发生改变。</p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h2 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h2><p>路由中通常会定义很多不同的页面</p>
<p>但是，页面这么多代码放在一个js文件中，这个页面必然非常的大。</p>
<p>一次性从服务器请求下来这个页面，可能会需要花费很长时间</p>
<p><strong>这时候我们就需要用到路由的懒加载</strong></p>
<p>路由懒加载的主要作用： <strong>将路由对应的组件打包成一个个的js代码块</strong></p>
<p>只有在这个路由被访问到的时候，才加载对应的组件</p>
<h3 id="懒加载的方式"><a href="#懒加载的方式" class="headerlink" title="懒加载的方式"></a>懒加载的方式</h3><p>方式一：结合Vue的异步组件和Webpack的代码分析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure(</span><br><span class="line">        [<span class="string">&#x27;../components/Home.vue&#x27;</span>],<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="built_in">require</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方式二：AMD写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;../components/About.vue&#x27;</span>],resolve)</span><br></pre></td></tr></table></figure>
<p><strong>方式三</strong>：在ES6中，我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="认识嵌套路由"><a href="#认识嵌套路由" class="headerlink" title="认识嵌套路由"></a>认识嵌套路由</h1><p>嵌套路由也就是路由界面中的路由，也就是说可以存在子路由</p>
<ul>
<li>比如在 <code>home</code> 页面中，我们希望通过<code>/homr/news</code>和<code>/hom/message</code> 访问一些内容</li>
<li>一个路径映射一个组件，访问这两个路径也会分别渲染两个组件</li>
</ul>
<p><strong>routes中的代码内容：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Home,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;首页&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,<span class="attr">redirect</span>: <span class="string">&#x27;news&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>, <span class="attr">component</span>: HomeNews &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>,<span class="attr">component</span>: HomeMessage &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>在home中通过vue-view显示子组件内容：</strong> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/message&quot;</span>&gt;</span>消息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，实现嵌套路由有两个步骤：</p>
<ul>
<li>创建对应的子组件，并且在路由映射中配置对应的子路由</li>
<li>在父组件内部使用 <code>&lt;router-view&gt;</code> 标签</li>
</ul>
<p><code>URL：协议://主机:端口/路径?查询</code></p>
<p><code>scheme://host:port/path?query#fragment</code></p>
<p>meta: 元数据</p>
<h1 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h1><h2 id="params-的类型："><a href="#params-的类型：" class="headerlink" title="params 的类型："></a>params 的类型：</h2><ul>
<li>配置路由格式： <strong>/router/:id</strong></li>
<li>传递的方式：在path后面跟上对应的值</li>
<li>传递后形成的路径</li>
</ul>
<p>query的类型</p>
<ul>
<li>配置路由格式：<strong>/router，</strong>也就是普通配置</li>
<li>传递的方式：对象中使用<strong>query的key作为传递方式</strong></li>
<li>传递后形成的路径：<strong>/router?id=123,/router？id=abc</strong></li>
</ul>
<h1 id="全局守卫导航"><a href="#全局守卫导航" class="headerlink" title="全局守卫导航"></a>全局守卫导航</h1><p><strong>全局守卫</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* must call `next` */</span></span><br><span class="line">    <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><code>keep-alive</code></h1><p><code>keep-alive</code> 是 Vue 内置的一个组件，可以<strong>使被包含的组件保留状态，避免重新渲染</strong>。</p>
<p><code>router-view</code> 也是一个组件，如果直接被包在 <code>keep-alive</code> 里面，所有路径匹配到的视图组件都会被缓存。</p>
<h1 id="TabBar实现思路"><a href="#TabBar实现思路" class="headerlink" title="TabBar实现思路"></a>TabBar实现思路</h1>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex</title>
    <url>/2021/10/27/vuex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Vuex-的概念和作用"><a href="#Vuex-的概念和作用" class="headerlink" title="Vuex 的概念和作用"></a>Vuex 的概念和作用</h1><p>Vuex就是一个储存组件状态的容器</p>
<ul>
<li>它采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化</li>
<li>Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能</li>
</ul>
<span id="more"></span>
<p><strong>状态管理又是什么？</strong></p>
<ul>
<li>其实可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面</li>
<li>然后，将这个对象放在顶层的 Vue 实例中，让其他组件可以使用</li>
<li>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？</li>
</ul>
<h2 id="单页面的状态管理"><a href="#单页面的状态管理" class="headerlink" title="单页面的状态管理"></a>单页面的状态管理</h2><pre class="mermaid">flowchart LR
a((View))-.->b((Action))
b-.->c((state))
c-.->a</pre>

<p><strong>State</strong>：状态，可以姑且当作就是data中的属性</p>
<p><strong>View</strong>：视图层，可以针对State的变化，显示不同的信息。</p>
<p><strong>Action</strong>：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变</p>
<h1 id="单界面到多界面的状态管理切换"><a href="#单界面到多界面的状态管理切换" class="headerlink" title="单界面到多界面的状态管理切换"></a>单界面到多界面的状态管理切换</h1><p>store文件中的index.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.安装插件</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;···&#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123;···&#125;,</span><br><span class="line">    <span class="attr">getters</span>: &#123;···&#125;,</span><br><span class="line">    <span class="attr">modules</span>: &#123;···&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<h2 id="Vuex-状态管理图例"><a href="#Vuex-状态管理图例" class="headerlink" title="Vuex 状态管理图例"></a>Vuex 状态管理图例</h2><pre class="mermaid">flowchart 
a(Vue components)--> |Dispatch| b((Actions))
d-->|Render|a
b<-.->BA("Backend(后端) API")
subgraph one [Vuex]
b-->|Commit| c((Mutations))-->|Mutate| d((State))
end

Devtools <-.->c</-.-></-.-></pre>



<h1 id="State-单一状态树"><a href="#State-单一状态树" class="headerlink" title="State 单一状态树"></a>State 单一状态树</h1><p>生活中，我们有很多信息被分散到很多地方进行管理，所以我们需要到对应的地方才能去打印，盖章各种资料信息</p>
<p>这样就很低效，而且不方便管理，而且维护起来也并不容易（需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了）</p>
<p>如果状态信息保存到多个Store对象中，那么之后的管理和维护等就会变得特别困难</p>
<p>而单一状态树就是在一个地方（$store）管理应用层级的全部状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">students</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;hh&quot;</span>, <span class="attr">age</span>: <span class="number">11</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;ww&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;nn&quot;</span>, <span class="attr">age</span>: <span class="number">33</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">info</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">1.98</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>我们可以看到state里面就存储着各种状态信息</p>
<p>调用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.state.counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="getters基本使用"><a href="#getters基本使用" class="headerlink" title="getters基本使用"></a>getters基本使用</h1><p>getters中定义的可以返回值或者函数，然后通过$store.getters····可以获取到</p>
<p><strong>返回函数：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;       </span><br><span class="line">   <span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123; $store.getters.moreAgeStu(12) &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<p><strong>返回值：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">        <span class="function"><span class="title">moreAgeStuLength</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getters.moreAgeStu(<span class="number">12</span>).length</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123; $store.getters.moreAgeStuLength &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<h1 id="mutations-传递参数"><a href="#mutations-传递参数" class="headerlink" title="mutations 传递参数"></a>mutations 传递参数</h1><p>在通过mutation更新数据的时候，有可能我们希望携带一些<strong>额外的参数</strong></p>
<ul>
<li>参数被称为是mutation的载荷（Payload）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">   addtion(state) &#123; state.counter++ &#125;,</span><br><span class="line">   subtraction(state) &#123; state.counter-- &#125;,</span><br><span class="line">   addCount(state, count) &#123; state.counter += count &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数不是一个，这个时候我们通常会以对象的形式传递，也就是payload是一个对象</p>
<h1 id="mutations-类型常量"><a href="#mutations-类型常量" class="headerlink" title="mutations 类型常量"></a>mutations 类型常量</h1><p>重新建立一个js文件，里面存储常量，然后这些常量可以在其他地方使用这个常量。</p>
<p>mutations-types.js</p>
<h1 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h1><p>Vuex 要求我们 mutations 里面的方法<strong>必须是同步方法</strong></p>
<p>如果是<strong>异步方法</strong>，那么就要用到actions</p>
<p>actions 类似于mutation，但是<strong>接收的是异步数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    <span class="comment">// context：上下文</span></span><br><span class="line">    <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                context.commit(<span class="string">&#x27;updateInfo&#x27;</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(payload);</span><br><span class="line">                resolve(<span class="string">&#x27;12334&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的 <code>context</code>也可以写成  <code>&#123;context,···&#125;</code> 也就是对象的解构，通过对象取出特定的东西</p>
<h1 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h1><p>Vue使用单一状态树，那么也意味着很多状态都会交给Vuex来管理</p>
<p>当应用变得非常复杂时，store对象就有可能变得相当臃肿</p>
<p>为了解决这个问题，Vuex允许我们将store分割成模块（Module）,而每个模块都拥有自己的state、mutations、actions、getters等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;···&#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;···&#125;,</span><br><span class="line">    <span class="attr">getters</span>: &#123;···&#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123;···&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    ······</span><br><span class="line">    <span class="attr">modules</span>: &#123; <span class="attr">a</span>: moduleA &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>state：存放数据</p>
<p>getters：处理数据</p>
<p>mutations：修改数据</p>
<p>actions：接收异步数据</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>vue CLI</title>
    <url>/2021/10/18/vue_CLI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><p>脚手架的作用其实就是为了我们后面的代码编写快速搭建一个项目模板，免去手动安装各种插件的麻烦</p>
<p>在前面，我们使用了webpack进行打包配置，但是比较麻烦，我们需要手动配置各种加载器，编译器，插件等等，而且还需要注意版本</p>
<p>我们将要使用的vue-cli其实就是 <strong>vue+webpack</strong>，帮助我们自动生成各种必要的依赖库，插件等</p>
<span id="more"></span>
<h1 id="vue-cli的使用"><a href="#vue-cli的使用" class="headerlink" title="vue-cli的使用"></a>vue-cli的使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先我们要确保在node环境下才能进行安装</p>
<p><strong>创建脚手架</strong></p>
<p><code>vue create 文件名</code></p>
<p>当然在vscode中如果无法使用的话，可以使用 npx vue create 文件名的命令进行脚手架的创建</p>
<h1 id="脚手架目录详解"><a href="#脚手架目录详解" class="headerlink" title="脚手架目录详解"></a>脚手架目录详解</h1><h2 id="最外层的目录"><a href="#最外层的目录" class="headerlink" title="最外层的目录"></a>最外层的目录</h2><ul>
<li><p><strong>dist 文件夹：</strong> 存储打包后的文件</p>
</li>
<li><p><strong>node_modules 文件夹：</strong> 存放node包</p>
</li>
<li><p><strong>public 文件夹</strong> 里面存储 <strong>index.html </strong>等公共文件 </p>
<ul>
<li><p>index.html 文件就是单页面复应用中的<strong>单页面</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里body中只有一个<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，但是这个会被<code>App.js</code>文件替换掉，也就是会显示<code>App.vue</code>中的内容</p>
</li>
</ul>
</li>
<li><p><strong>src 文件夹：</strong> 是我们放源代码的地方</p>
</li>
<li><p><strong>.gitignore ：</strong> 忽略不需要上传到github的文件</p>
</li>
<li><p><strong>babel.config.js：</strong>  转码器配置文件，将ES6转成ES5</p>
</li>
<li><p><strong>package.json： </strong> 各种配置，依赖包……学了node后再补充</p>
</li>
<li><strong>package.lock.json：</strong> 里面显示的是node包的真实版本</li>
</ul>
<h3 id="src文件夹中的文件"><a href="#src文件夹中的文件" class="headerlink" title="src文件夹中的文件"></a>src文件夹中的文件</h3><h4 id="assets-文件夹"><a href="#assets-文件夹" class="headerlink" title="assets 文件夹"></a>assets 文件夹</h4><p><strong>目录中的文件会被webpack处理解析为模块依赖</strong>，只支持相对路径形式</p>
<p>里面我们可以定义一些文件夹，如css,img……文件</p>
<h4 id="components-文件夹"><a href="#components-文件夹" class="headerlink" title="components 文件夹"></a>components 文件夹</h4><p>里面存储了各种<code>.vue</code>文件，也就是<strong>主要的代码编写地</strong>，我们可以在里面定义各种不同的组件，然后可以在 <strong>App.vue</strong> 中，或者components中的<code>.vue</code>文件中引用，不过要注意降低耦合度</p>
<h4 id="router-文件夹"><a href="#router-文件夹" class="headerlink" title="router 文件夹"></a>router 文件夹</h4><p>里面的index.js文件就是配置路由的地方，也就是配置url和不同页面的映射关系</p>
<p><strong>给个例子</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里通过这样引用就可以将后面打包的js文件分割成一个个小文件，因为如果只请求一个大文件会花费很长时间</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/home/Home.vue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Category = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/category/Category.vue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ShoppingCart = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/shopping_cart/ShoppingCart.vue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Profile = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/profile/Profile.vue&#x27;</span>);</span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件)，安装插件。</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/category&#x27;</span>, <span class="attr">component</span>: Category &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/cart&#x27;</span>, <span class="attr">component</span>: ShoppingCart &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/profile&#x27;</span>, <span class="attr">component</span>: Profile &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;history&quot;</span>,<span class="comment">//去掉哈希默认的#</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<h4 id="views-文件夹"><a href="#views-文件夹" class="headerlink" title="views 文件夹"></a>views 文件夹</h4><p>默认我们会将<code>src/views</code>文件夹下的 <code>.vue</code> 文件加载为路由页，也就是views文件夹中存储路由页。</p>
<h4 id="App-vue-文件"><a href="#App-vue-文件" class="headerlink" title="App.vue 文件"></a>App.vue 文件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main-tab-bar</span>&gt;</span><span class="tag">&lt;/<span class="name">main-tab-bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> MainTabBar <span class="keyword">from</span> <span class="string">&quot;./components/MainTabBar.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    MainTabBar,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">&quot;./assets/css/base.css&quot;</span>;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//这里默认引入的就是router中的index.js文件</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el:&#x27;#app&#x27;,</span></span><br><span class="line">    router,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),<span class="comment">//使用runtime-only</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)<span class="comment">//这个和el:&#x27;#app&#x27;一样</span></span><br></pre></td></tr></table></figure>
<p>这个其实就是 <strong>源代码的入口</strong></p>
<h2 id="runtime-compiler"><a href="#runtime-compiler" class="headerlink" title="runtime-compiler"></a>runtime-compiler</h2><p>template ==&gt; ast ==&gt; render ==&gt; vdom(virtual dom) ==&gt; UI</p>
<h2 id="⭐runtime-only"><a href="#⭐runtime-only" class="headerlink" title="⭐runtime-only"></a>⭐runtime-only</h2><p>render ==&gt; vdom ==&gt;UI</p>
<p>综上可以看出，runtime-only性能更好，且代码量更少。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>六、事件处理</title>
    <url>/2021/10/09/vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下笔记均来自<a href="https://cn.vuejs.org/">Vue</a>官网教程，为了方便记忆，自己进行了整理</p>
</blockquote>
<h2 id="6-1-监听事件（v-on简单调用）"><a href="#6-1-监听事件（v-on简单调用）" class="headerlink" title="6.1. 监听事件（v-on简单调用）"></a>6.1. 监听事件（<code>v-on</code>简单调用）</h2><p>通过 <code>v-on</code> 指令监听DOM事件，并在触发时运行一些JavaScript代码。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-1&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="6-2-v-on-调用方法名"><a href="#6-2-v-on-调用方法名" class="headerlink" title="6.2. v-on 调用方法名"></a>6.2. <code>v-on</code> 调用方法名</h2><p>由于许多事件的逻辑会很复杂，所以直接把它写在 <code>v-on</code> 指令中是不可行的。所以这里可以通过调用方法名的方式进行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#example2&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alter(<span class="string">&#x27;Hello &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然不仅可以调用方法名，我们同样可以在里面传参，参数也可以是特殊变量<code>$event</code> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;message&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">warn</span>: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-事件修饰符"><a href="#6-3-事件修饰符" class="headerlink" title="6.3. 事件修饰符"></a>6.3. 事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，<strong>但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</strong></p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4-按键修饰符"><a href="#6-4-按键修饰符" class="headerlink" title="6.4. 按键修饰符"></a>6.4. 按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以直接将 <code>KeyboardEvent.key</code>暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，处理函数只会在 <code>$event.key</code> 等于 <code>PageDown</code> 时被调用。</p>
<h4 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h4><blockquote>
<p><code>keyCode</code> 的事件用法已经被废弃了并可能不会被最新的浏览器支持。</p>
</blockquote>
<p><strong>使用 <code>keyCode</code> attribute 也是允许的：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了在必要的情况下支持旧浏览器(IE)，Vue 提供了绝大多数常用的按键码的别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p><strong>自定义：</strong></p>
<p>也可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure>
<h2 id="6-5-系统修饰键"><a href="#6-5-系统修饰键" class="headerlink" title="6.5. 系统修饰键"></a>6.5. 系统修饰键</h2><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h4><p><code>.exact</code> 可以控制 <strong>由精确的系统修饰符组合</strong> 触发的事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<h2 id="6-6-在HTML监听事件的好处"><a href="#6-6-在HTML监听事件的好处" class="headerlink" title="6.6. 在HTML监听事件的好处"></a>6.6. 在HTML监听事件的好处</h2><p>虽然这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式 <strong>都严格绑定在当前视图的 ViewModel 上</strong>，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p>
<ol>
<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li>
<li>因为你无须在 JavaScript 里手动绑定事件，<strong>你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试</strong>。</li>
<li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除，无须担心如何清理。</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>条件与列表渲染</title>
    <url>/2021/10/07/vue%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下笔记均来自<a href="https://cn.vuejs.org/">Vue</a>官网教程，为了方便记忆，自己进行了整理</p>
</blockquote>
<h1 id="四、条件渲染"><a href="#四、条件渲染" class="headerlink" title="四、条件渲染"></a>四、条件渲染</h1><h2 id="4-1-v-if"><a href="#4-1-v-if" class="headerlink" title="4.1. v-if"></a>4.1. <code>v-if</code></h2><p>类似 js 中的 if</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-v-else"><a href="#4-2-v-else" class="headerlink" title="4.2. v-else"></a>4.2. <code>v-else</code></h2><p>类似 js 中的 else</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>Oh no 😢<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="4-3-v-else-if"><a href="#4-3-v-else-if" class="headerlink" title="4.3. v-else-if"></a>4.3. <code>v-else-if</code></h2><p>类似 js 中的 else if</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4-⭐用-key-管理可复用的元素"><a href="#4-4-⭐用-key-管理可复用的元素" class="headerlink" title="4.4. ⭐用 key 管理可复用的元素"></a>4.4. ⭐用 <code>key</code> 管理可复用的元素</h2><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。</p>
<p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。<strong>只需添加一个具有唯一值的 <code>key</code> attribute 即可</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> attribute。</p>
<p><strong>也就是说key的作用就是给元素起一个独一无二的ID</strong>，这样就可以防止相同模板不进行替换。</p>
<h2 id="4-5-v-show"><a href="#4-5-v-show" class="headerlink" title="4.5. v-show"></a>4.5. <code>v-show</code></h2><p><code>v-show</code> 与 <code>v-if</code> 的区别就是<code>v-show</code> 只是 <strong>简单地切换元素的display</strong>，而<code>v-if</code> 是 “真正” 的条件渲染。</p>
<h1 id="五、列表渲染"><a href="#五、列表渲染" class="headerlink" title="五、列表渲染"></a>五、列表渲染</h1><h2 id="5-1-用v-for-遍历数组"><a href="#5-1-用v-for-遍历数组" class="headerlink" title="5.1. 用v-for 遍历数组"></a>5.1. 用<code>v-for</code> 遍历数组</h2><p>我们可以用 <code>v-for</code>  来迭代数组中的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里通过 遍历得到items数组中每个item对象中的message属性值，并动态绑定key来保证其唯一性--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-1&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<ul>
<li>Foo</li>
<li>Bar</li>
</ul>
<hr>
<p><strong>这里<code>v-for</code> 可传入第二个参数，即当前索引值</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; index &#125;&#125; : &#123;&#123; item &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-2&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<ul>
<li>1 : Foo</li>
<li>2 : Bar</li>
</ul>
<p>当然我们也可以用 <code>of</code> 来替代 <code>in</code> 作为分隔符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item of items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-2-用-v-for-遍历对象"><a href="#5-2-用-v-for-遍历对象" class="headerlink" title="5.2. 用 v-for 遍历对象"></a>5.2. 用 <code>v-for</code> 遍历对象</h2><p><strong>这里的遍历是依次遍历对象中的键值</strong></p>
<p><strong>例子：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;v-for-object&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in object&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#v-for-object&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">object</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">      <span class="attr">author</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">      <span class="attr">publishedAt</span>: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<ul>
<li>How to lists in Vue</li>
<li>Jane Doe</li>
<li>2016-04-10</li>
</ul>
<hr>
<p><strong>这里 <code>v-for</code> 可传入第二个参数，即键名</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; name &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>title : How to do lists in Vue<br>author : Jane Doe<br>publishedAt : 2016-04-10</p>
<hr>
<p>还可以用第三个参数作为索引：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<ol>
<li><p>title : How to do lists in Vue</p>
</li>
<li><p>author : Jane Doe</p>
</li>
<li>publishedAt : 2016-04-10</li>
</ol>
<h2 id="5-3-维护状态"><a href="#5-3-维护状态" class="headerlink" title="5.3. 维护状态"></a>5.3. 维护状态</h2><p>Vue的默认更新策略是”就地更新 “。即不会移动匹配数据项的顺序，并且保证它们在每个索引位置正确渲染。</p>
<p><strong>通过 <code>key</code> 给 Vue 一个提示</strong>，以便它能跟踪到每个节点的身份，从而有利于重用和重新排序现有元素，其实就类似于链表的地址。</p>
<p><strong>所以说使用 <code>v-for</code> 时尽量提供 <code>key</code></strong></p>
<p><strong>注意点：</strong></p>
<p><strong>不要使用对象或数组之类的非基本类型值</strong>作为 <code>v-for</code> 的 <code>key</code>。<strong>请用字符串或数值类型的值</strong>。</p>
<h2 id="5-4-数组更新检测"><a href="#5-4-数组更新检测" class="headerlink" title="5.4. 数组更新检测"></a>5.4. 数组更新检测</h2><h3 id="5-4-1-改变原始数组"><a href="#5-4-1-改变原始数组" class="headerlink" title="5.4.1. 改变原始数组"></a>5.4.1. 改变原始数组</h3><p>这里就用到了js中操作数组的一些方法</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<p>通过这些方法可以改变原始数组</p>
<h3 id="5-4-2-生成新数组"><a href="#5-4-2-生成新数组" class="headerlink" title="5.4.2. 生成新数组"></a>5.4.2. 生成新数组</h3><p>当然 js 中还有一些操作数组的方法并不是改变原始数组，而是<strong>返回一个新数组</strong>，如 <code>filter()</code> 、<code>concat()</code>、<code>slice()</code>。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>一、模板语法</title>
    <url>/2021/10/02/vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下笔记均来自<a href="https://cn.vuejs.org/">Vue</a>官网教程，为了方便记忆，自己进行了整理</p>
</blockquote>
<h2 id="1-1-插值语法"><a href="#1-1-插值语法" class="headerlink" title="1.1. 插值语法"></a>1.1. 插值语法</h2><h3 id="1-1-1-插入文本"><a href="#1-1-1-插入文本" class="headerlink" title="1.1.1. 插入文本"></a>1.1.1. 插入文本</h3><p><strong>普通文本</strong>的插入我们可以用”Mustache”语法（双大括号）的文本插值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Mustache 标签会被替代为对应 data 对象上 <code>msg</code> 的属性值。并且会随着属性值的改变进行更新</p>
<p><strong>注意：双大括号只能操作普通文本</strong></p>
<span id="more"></span>
<h3 id="1-1-2-插入原始HTML"><a href="#1-1-2-插入原始HTML" class="headerlink" title="1.1.2. 插入原始HTML"></a>1.1.2. 插入原始HTML</h3><p>双大括号会将数据解释为普通文本，<strong>而非HTML代码</strong>。为了输出真正的HTML代码，我们可以使用 <strong><code>v-html</code> 指令</strong>：</p>
<p><strong>html 部分</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustache:&#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;rawHtml&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>js 部分</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">rawHtml</span>: <span class="string">`&lt;span style=&quot;color:red&quot;&gt;这是红色的字&lt;/span&gt;`</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: data,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个 <code>span</code> 里面的的内容会被替换成为 <code>rawHtml</code> 的属性值，直接作为HTML</p>
<h3 id="1-1-3-插入HTML-Attribute"><a href="#1-1-3-插入HTML-Attribute" class="headerlink" title="1.1.3. 插入HTML Attribute"></a>1.1.3. 插入HTML Attribute</h3><p>这里区分一下：</p>
<ul>
<li><p><strong>property</strong>：<strong>是 js 获取的DOM对象上的属性值</strong>，比如 a，你可以将它看作为一个基本的 js 对象。这个节点包括很多property，比如 value，className以及一些方法onclik等方法。</p>
</li>
<li><p><strong>attribute</strong>：<strong>是 HTML 标签上的某个属性</strong>，如id、class、value等以及自定义属性，它的值只能是字符串</p>
</li>
</ul>
<p>我们可以通过 <strong><code>v-bind</code> 指令</strong> 来操作 HTML attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-4-使用-js-表达式"><a href="#1-1-4-使用-js-表达式" class="headerlink" title="1.1.4. 使用 js 表达式"></a>1.1.4. 使用 js 表达式</h3><p>对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些<strong>表达式</strong>会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-指令"><a href="#1-2-指令" class="headerlink" title="1.2. 指令"></a>1.2. 指令</h2><p>指令 (Directives) 是带有 <code>v-</code> 前缀的<strong>特殊 attribute</strong> </p>
<h3 id="1-2-1-参数"><a href="#1-2-1-参数" class="headerlink" title="1.2.1. 参数"></a>1.2.1. 参数</h3><p>一些指令能够接收一个 “参数”，在<strong>指令名称后以冒号</strong>表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-动态参数"><a href="#1-2-2-动态参数" class="headerlink" title="1.2.2. 动态参数"></a>1.2.2. 动态参数</h3><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p>
<p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<h4 id="一些约束"><a href="#一些约束" class="headerlink" title="一些约束"></a>一些约束</h4><p><strong>1. 对动态参数值的约束</strong></p>
<p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。<strong>任何其它非字符串类型的值都将会触发一个警告</strong>。</p>
<p><strong>2、 对动态参数表达式的约束</strong></p>
<p>某些字符，如<strong>空格和引号，放在 HTML attribute 名里是无效的</strong>。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[&#x27;<span class="attr">foo</span>&#x27; + <span class="attr">bar</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p>
<p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要<strong>避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-修饰符"><a href="#1-2-3-修饰符" class="headerlink" title="1.2.3. 修饰符"></a>1.2.3. 修饰符</h3><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-缩写"><a href="#1-3-缩写" class="headerlink" title="1.3. 缩写"></a>1.3. 缩写</h2><p><code>v-bind:</code>  :</p>
<p><code>v-on:</code> @</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>八、组件基础</title>
    <url>/2021/10/14/vue%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="8-1-示例："><a href="#8-1-示例：" class="headerlink" title="8.1. 示例："></a>8.1. 示例：</h2><p>原始方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建组件构造器对象</span></span><br><span class="line"><span class="keyword">const</span> cpnConstructor = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2.注册组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>,cpnConstructor);</span><br></pre></td></tr></table></figure>
<p>简写方法（创建和注册合为一体）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>组件可复用的Vue实例，且带有一个名字：在这个例子中是 <code>button-counter</code>。我们可以在一个通过 <code>new Vue</code> 创建的Vue 根实例中，把这个组件作为自定义元素来使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;<span class="attr">el</span>:<span class="string">&#x27;#components-demo&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>因为组件是可复用的Vue实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像<code>el</code> 这样根实例特有的选项。</p>
<h2 id="8-2-组建的可复用"><a href="#8-2-组建的可复用" class="headerlink" title="8.2. 组建的可复用"></a>8.2. 组建的可复用</h2><p>每个组件都得是一个独立的个体，可以<strong>重复使用，且互不影响。</strong></p>
<h3 id="data-必须是一个函数"><a href="#data-必须是一个函数" class="headerlink" title="data 必须是一个函数"></a><code>data</code> 必须是一个函数</h3><p>由于我们需要保证每一个组件都是一个独立的个体，这就要求 <code>data</code> <strong>不能是这样可直接提取的对象</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">	count: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取而代之的是，<strong>一个组件的 <code>data</code> 选项必须是一个函数，</strong>这样就可以让每个实例维护一份被返回对象的独立的拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Vue没有这条规则，那么一个组件就可能会影响到其他所有的相同组件。</p>
<p>因为函数有其独立的作用域，如果用对象，那么传递的是相同的地址，或者说是引用。</p>
<h2 id="8-3-组件的组织"><a href="#8-3-组件的组织" class="headerlink" title="8.3. 组件的组织"></a>8.3. 组件的组织</h2><p>我们<strong>可以通过一颗嵌套的组件树的形式</strong>来组织一个应用</p>
<p>为了能够在模板中使用，这些组件都必须 <strong>先注册</strong> 以便Vue能够识别。</p>
<p>组件的注册类型有两种：</p>
<ul>
<li>全局注册</li>
<li>局部注册</li>
</ul>
<p><strong>全局注册：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//………option……</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全局注册的组件可以用在其被注册之后的任何（通过 <code>new Vue</code>）新创建的 Vue 根实例，<strong>也包括其组件树中的所有子组件的模板中。</strong> </p>
<p><strong>局部注册：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    ……,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        my-component-name: &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="8-4-通过-Prop-向子组件传递数据"><a href="#8-4-通过-Prop-向子组件传递数据" class="headerlink" title="8.4. 通过 Prop 向子组件传递数据"></a>8.4. 通过 Prop 向子组件传递数据</h2><p>Prop 是在可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一个组件可以拥有默认任意数量的prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件中访问这个值，就像访问 <code>data</code> 中的值一样。</p>
<p>一个prop被注册之后，你就可以像这样把数据作为一个自定义 attribute 传递进来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是在典型应用中，<code>data</code> 里一般有一个博文的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#blog-post-demo&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">posts</span>: [</span><br><span class="line">      		&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;My journey with Vue&#x27;</span> &#125;,</span><br><span class="line">      		&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Blogging with Vue&#x27;</span> &#125;,</span><br><span class="line">      		&#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;Why Vue is so fun&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以将它渲染成一个组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">	<span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然props不仅可以传递数组，还可以传递对象</p>
<p><strong>传递对象的好处：能够对props进行数据类型的验证，提供默认值……</strong></p>
<p>支持的数据类型有：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Data</li>
<li>Function</li>
<li>Symbol</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    <span class="comment">// 1.类型的限制</span></span><br><span class="line">   <span class="attr">id</span>: <span class="built_in">Number</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="built_in">String</span>,</span><br><span class="line">   <span class="comment">// 2.提供默认值</span></span><br><span class="line">   <span class="attr">id</span>: &#123;</span><br><span class="line">       <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">       <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">       <span class="attr">required</span>: <span class="literal">true</span><span class="comment">//表示这个参数必须绑定</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-5-单个根元素"><a href="#8-5-单个根元素" class="headerlink" title="8.5. 单个根元素"></a>8.5. 单个根元素</h2><p>当构建一个 <code>&lt;blog-post&gt;</code> 组件时，模板最终会包含不仅仅只有标题，还会包含其他很多东西，比如正文：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>但是这样写会报错，因为每个组件必须只有一个根元素</strong></p>
<p>所以可以改成这样，把它包含在一个里面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blog-post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是博文还有很多东西，比如标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个prop会变得很麻烦：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:content</span>=<span class="string">&quot;post.content&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:publishedAt</span>=<span class="string">&quot;post.publishedAt&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:comments</span>=<span class="string">&quot;post.comments&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以这里我们可以让它变成接受一个单独的 <code>post</code> prop：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="8-6-监听子组件事件（-emit）"><a href="#8-6-监听子组件事件（-emit）" class="headerlink" title="8.6. 监听子组件事件（$emit）"></a>8.6. 监听子组件事件（<code>$emit</code>）</h2><p>在开发组件时，我们不仅需要父组件传递信息给子组件，同样也需要让子组件与父组件进行沟通。例如这里引用一个放大博文字号的辅助功能，同时让页面其他部分保持默认的字号。</p>
<p>在其父组件上，我们可以添加一个 <code>postFontSize</code> 的data property 来支持这个功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#blog-posts-events-demo&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">post</span>: [<span class="comment">/*……*/</span>],</span><br><span class="line">        <span class="attr">postFontSize</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>它可以在模板中用来控制所有博文的字号：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-posts-events-demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; fontSize: postFontSize + &#x27;em&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">    	&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在我们在每篇博文正文之前添加一个按钮来放大字号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;button&gt;</span></span><br><span class="line"><span class="string">        Enlarge text</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是这个 <code>button</code> 按钮不会做任何事</p>
<p>当点击这个按钮时，我们需要告诉父级组件放大所有博文文本。这里可以<strong>通过 <code>v-on</code> 监听子组件实例</strong>的任意事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时<strong>子组件</strong>可以<strong>通过调用内建的 <code>$emit</code> 方法</strong>并传入事件名称来触发一个事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span> <span class="comment">&lt;!--发射事件--&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以把它封装为一个方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;cpnClick&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">cpnClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;enlarge-text&#x27;</span>) <span class="comment">//发射事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h3><p>有时候用一个事件来抛出一个特定的值是非常有用的。例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 <code>$emit</code> 的第二个参数来提供这个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;,0.1)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后当在父组件监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者，如果这个事件处理函数是一个方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个值将会作为第一个参数传入这个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="attr">onEnlargeText</span>: <span class="function"><span class="keyword">function</span> (<span class="params">enlargeAmount</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.postFontSize += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 <code>v-model</code></h3><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">	<span class="attr">v-bind:value</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">v-on:input</span>=<span class="string">&quot;searchText = $event.target.value&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>
<p>在组件上时。<code>v-model</code>则会这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;searchText = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了让它正常工作，这个组件内的 <code>input</code> 必须：</p>
<ul>
<li>将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在 <code>v-model</code> 就应该可以在这个组件上工作了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="8-7-动态组件"><a href="#8-7-动态组件" class="headerlink" title="8.7. 动态组件"></a>8.7. 动态组件</h2><h4 id="……"><a href="#……" class="headerlink" title="……"></a>……</h4><h2 id="8-8-解析DOM模板时的注意事项"><a href="#8-8-解析DOM模板时的注意事项" class="headerlink" title="8.8. 解析DOM模板时的注意事项"></a>8.8. 解析DOM模板时的注意事项</h2><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p>
<p>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 <code>is</code> attribute 给了我们一个变通的办法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">&quot;blog-post-row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：</strong></p>
<ul>
<li>字符串 (例如：<code>template: &#39;...&#39;</code>)</li>
<li><strong>单文件组件 (<code>.vue</code>)</strong></li>
<li>&lt;script type=”text/x-template”&gt;</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>九、组件补充</title>
    <url>/2021/10/15/vue%E7%BB%84%E4%BB%B6%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="9-1-父子组件的访问方式"><a href="#9-1-父子组件的访问方式" class="headerlink" title="9.1. 父子组件的访问方式"></a>9.1. 父子组件的访问方式</h2><ul>
<li>父组件访问子组件：使用<code>$refs</code></li>
<li>子组件访问父组件：使用<code>$parent</code></li>
</ul>
<h3 id="9-1-1-父访问子：-ref"><a href="#9-1-1-父访问子：-ref" class="headerlink" title="9.1.1. 父访问子：$ref"></a>9.1.1. 父访问子：<code>$ref</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">&quot;abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ref=&quot;abc&quot;让此组件与其他组件区别开来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;#test&#x27;</span>,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$ref.abc.name);<span class="comment">//通过这个就可以访问到子组件中的name属性值</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">cpn</span>: &#123;</span><br><span class="line">            <span class="attr">template</span>:<span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;子组件&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>$ref</code>默认的是一个空的对象类型，必须在我们组件上面给他加上一个<code>ref=&#39;···&#39;</code>，这样才能通过<code>this.$ref.···</code>访问到里面的内容</p>
<h3 id="9-1-2-子访问父：-parent"><a href="#9-1-2-子访问父：-parent" class="headerlink" title="9.1.2. 子访问父：$parent"></a>9.1.2. 子访问父：<code>$parent</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;#test&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;父组件&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">cpn</span>: &#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">            <span class="attr">methods</span>: &#123;</span><br><span class="line">                <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              		<span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.name)<span class="comment">//访问父组件的name属性      </span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不过这样使用的复用性不是很好，而且与父组件的耦合性也很高。</p>
<p>就如同上面的例子，我们没法保证每个父组件都存在一个name属性。</p>
<p><strong>当然还有 <code>$root</code>，通过这个就可以让子组件访问到自己的根组件。</strong></p>
<h2 id="9-2-插槽（slot）"><a href="#9-2-插槽（slot）" class="headerlink" title="9.2. 插槽（slot）"></a>9.2. 插槽（slot）</h2><h3 id="9-2-1-使用插槽的原因"><a href="#9-2-1-使用插槽的原因" class="headerlink" title="9.2.1. 使用插槽的原因"></a>9.2.1. 使用插槽的原因</h3><p>生活中插槽很常见，比如手机电脑的usb插槽，插板当中的电源插槽。</p>
<p>插槽的目的是让我们原来的设备具备更多的扩展性，比如电脑的usb可以让我们插入U盘、硬盘、手机、鼠标……</p>
<p><strong>所以这里组件的插槽也就是为了让我们封装的组件具备更多的扩展性</strong></p>
<p><strong>封装组件要抽取共性，保留不同</strong></p>
<h3 id="9-2-2-基本插槽的使用"><a href="#9-2-2-基本插槽的使用" class="headerlink" title="9.2.2. 基本插槽的使用"></a>9.2.2. 基本插槽的使用</h3><p><strong>1、插槽的基本使用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;#cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;#test&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">cpn</span>: &#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>加入插槽后，它就可以通过插槽显示内容，比如这里的 <code>button</code> 按钮</p>
<p><strong>2、给插槽提供默认值</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3、插槽一次可以替换多个元素</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-具名插槽的使用"><a href="#9-2-3-具名插槽的使用" class="headerlink" title="9.2.3. 具名插槽的使用"></a>9.2.3. 具名插槽的使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span> <span class="comment">&lt;!--这样就可以替换含有 name=&quot;center&quot;的slot--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#test&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">cpn</span>: &#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过给插槽起名字来进行指定替换</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>七、表单输入绑定</title>
    <url>/2021/10/12/vue%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下笔记均来自<a href="https://cn.vuejs.org/">Vue</a>官网教程，为了方便记忆，自己进行了整理</p>
</blockquote>
<h2 id="7-1-基础用法"><a href="#7-1-基础用法" class="headerlink" title="7.1. 基础用法"></a>7.1. 基础用法</h2><p><code>v-model</code> 指令可以在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上<strong>创建双向数据绑定</strong>。它会根据控件类型自动选取正确的方法来更新元素。</p>
<p>它其实是一个语法糖，背后本质上是包含两个操作：</p>
<ul>
<li>v-bind绑定一个value 属性</li>
<li>v-on给当前元素绑定input事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">等同于</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>注意：</strong></p>
<p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<h3 id="7-1-2-文本-text"><a href="#7-1-2-文本-text" class="headerlink" title="7.1.2. 文本(text)"></a>7.1.2. 文本(text)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-多行文本-textarea"><a href="#7-1-3-多行文本-textarea" class="headerlink" title="7.1.3. 多行文本(textarea)"></a>7.1.3. 多行文本(textarea)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;white-space: pre-line;&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;add multiple lines&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<p>在文本区域插值 (<code>&lt;textarea&gt;&#123;&#123;text&#125;&#125;&lt;/textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p>
<h3 id="7-1-4-复选框（checkbox）"><a href="#7-1-4-复选框（checkbox）" class="headerlink" title="7.1.4. 复选框（checkbox）"></a>7.1.4. 复选框（checkbox）</h3><p><strong>单个复选框，绑定到布尔值：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    <span class="attr">checked</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多个复选框，绑定到数组：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">checkedNames</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="7-1-5-单选按钮-radio"><a href="#7-1-5-单选按钮-radio" class="headerlink" title="7.1.5. 单选按钮(radio)"></a>7.1.5. 单选按钮(radio)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;One&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Two&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-4&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">picked</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> </p>
<p><strong>这里不用绑定相同的 <code>name</code> 互斥，因为 <code>v-model</code> 已经构成互斥了。</strong></p>
<h3 id="7-1-6-选择框-selected"><a href="#7-1-6-选择框-selected" class="headerlink" title="7.1.6. 选择框(selected)"></a>7.1.6. 选择框(selected)</h3><h4 id="单选（字符串）："><a href="#单选（字符串）：" class="headerlink" title="单选（字符串）："></a>单选（字符串）：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-5&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">selected</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>这里绑定要绑定在 <code>selected</code> 上，而不是 <code>option</code> 上。</p>
<p><strong>用 <code>v-for</code> 渲染:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;option in options&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;option.value&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">selected</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;One&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;A&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Two&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;B&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Three&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里其实就用到了后面要说的动态的值绑定</p>
<h4 id="多选（数组）："><a href="#多选（数组）：" class="headerlink" title="多选（数组）："></a>多选（数组）：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-6&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">&quot;width: 50px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-6&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">selected</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>multiple</code> 实现多选，<strong>不过选择时需要按住 <code>ctrl</code>键</strong></p>
<h2 id="7-2-使用动态值绑定-v-bind-value"><a href="#7-2-使用动态值绑定-v-bind-value" class="headerlink" title="7.2. 使用动态值绑定(v-bind:value)"></a>7.2. 使用动态值绑定(<code>v-bind:value</code>)</h2><p>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是<strong>静态字符串</strong> ，也就是在html部分直接给出来，这样就有一个缺点：更改值的时候比较麻烦</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以我们可以把值绑定到 Vue 实例的一个动态属性上，这时可以<strong>用 <code>v-bind</code> 实现，通过 <code>v-bind:value</code> 动态绑定值。</strong></p>
<p>比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;option in options&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;option.value&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">selected</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;One&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;A&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Two&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;B&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Three&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>当然不仅是<code>value</code>，我们也可以动态绑定其他东西，比如<code>id</code>,<code>for</code>……</strong></p>
<h2 id="7-3-修饰符"><a href="#7-3-修饰符" class="headerlink" title="7.3. 修饰符"></a>7.3. 修饰符</h2><h3 id="7-3-1-lazy"><a href="#7-3-1-lazy" class="headerlink" title="7.3.1. .lazy"></a>7.3.1. <code>.lazy</code></h3><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步。添加 <code>lazy</code> 修饰符就可以让它<strong>在 <code>change</code> 事件后进行同步</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在&quot;change&quot;时而非&quot;input&quot;时更新--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>change事件是失去焦点后才会改变，不会像input事件那样频繁改变</strong></p>
<h3 id="7-3-2-number"><a href="#7-3-2-number" class="headerlink" title="7.3.2. .number"></a>7.3.2. <code>.number</code></h3><p>如果想自动<strong>将用户的输入值转为数值类型</strong>，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.bumber</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>
<h3 id="7-3-3-trim"><a href="#7-3-3-trim" class="headerlink" title="7.3.3. .trim"></a>7.3.3. <code>.trim</code></h3><p>如果想要<strong>自动过滤用户输入的首尾空白字符</strong>，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>二、计算属性和侦听器</title>
    <url>/2021/10/04/vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下笔记均来自<a href="https://cn.vuejs.org/">Vue</a>官网教程，为了方便记忆，自己进行了整理</p>
</blockquote>
<h2 id="2-1-计算属性"><a href="#2-1-计算属性" class="headerlink" title="2.1. 计算属性"></a>2.1. 计算属性</h2><h3 id="2-1-1-基础例子"><a href="#2-1-1-基础例子" class="headerlink" title="2.1.1. 基础例子"></a>2.1.1. 基础例子</h3><p>虽然我们可以在大括号内使用表达式，但是在双大括号中使用<strong>会造成模板过重，难以维护</strong>，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以使用 <strong>计算属性 </strong>将该复杂的表达式替代掉</p>
<span id="more"></span>
<p><strong>js部分：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>html部分：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">//计算属性的 getter</span></span><br><span class="line">        <span class="attr">reversedMessage</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//&#x27;this&#x27;指向 vm 实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-计算属性缓存-vs-方法"><a href="#2-1-2-计算属性缓存-vs-方法" class="headerlink" title="2.1.2. 计算属性缓存 vs 方法"></a>2.1.2. 计算属性缓存 vs 方法</h3><p><strong>html部分：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reverseMessage() &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>js部分：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="attr">reversedMessage</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这种方式和计算属性的结果是相同的，但是<strong>计算属性是基于它们的响应式依赖进行缓存的。</strong> 只有相关的依赖发生改变时才会重新求值，所以说多次访问<code>reversedMessage</code> 计算属性会立即返回之前的结果，而不会再次执行函数。</p>
<p>简单来说就是计算属性是<strong>属性</strong>不是<strong>方法</strong>，所以可以直接得到属性值，不必多次调用</p>
<h3 id="2-1-3-计算属性vs侦听属性"><a href="#2-1-3-计算属性vs侦听属性" class="headerlink" title="2.1.3. 计算属性vs侦听属性"></a>2.1.3. 计算属性vs侦听属性</h3><h4 id="⭐先了解一下侦听属性"><a href="#⭐先了解一下侦听属性" class="headerlink" title="⭐先了解一下侦听属性"></a>⭐先了解一下侦听属性</h4><h3 id="2-1-4-计算属性的-setter"><a href="#2-1-4-计算属性的-setter" class="headerlink" title="2.1.4. 计算属性的 setter"></a>2.1.4. 计算属性的 setter</h3><p>计算属性默认只有一个getter，不过在需要时也可以提供一个 setter：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computes: &#123;</span><br><span class="line">    <span class="attr">funllName</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> +<span class="built_in">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过设置setter，那么<code>vm.fullName = &#39;John Doe&#39;</code> 时，setter会被调用，那么<code>this.firstName</code> 和 <code>this.lastName</code> 也会相应地更新。</p>
<h2 id="2-2-侦听器"><a href="#2-2-侦听器" class="headerlink" title="2.2.  侦听器"></a>2.2.  侦听器</h2><h3 id="⭐以后再补充"><a href="#⭐以后再补充" class="headerlink" title="⭐以后再补充"></a>⭐以后再补充</h3>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>webSocket</title>
    <url>/2021/11/08/webSocket/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Websocket协议"><a href="#Websocket协议" class="headerlink" title="Websocket协议"></a>Websocket协议</h1><p>握手是基于http协议的</p>
<h1 id="客户端（浏览器）实现"><a href="#客户端（浏览器）实现" class="headerlink" title="客户端（浏览器）实现"></a>客户端（浏览器）实现</h1><h2 id="webSocket-对象"><a href="#webSocket-对象" class="headerlink" title="webSocket 对象"></a>webSocket 对象</h2><p>实现 webSockets 的 Web 浏览器将通过 WebSocket 对象公开所有必须的客户端功能（主要指支持 Html5 的浏览器）。</p>
<p>以下API用于创建 WebSocket 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> webSocket(url)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数 url 格式说明： ws://ip地址：端口号/资源名称</p>
</blockquote>
<h2 id="webSocket-事件"><a href="#webSocket-事件" class="headerlink" title="webSocket 事件"></a>webSocket 事件</h2><p>webSocket 对象的相关事件</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>事件处理程序</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>websocket 对象.onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>websocket 对象.onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>websocket 对象.onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>websocket 对象.onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody>
</table>
</div>
<h2 id="webSocket方法"><a href="#webSocket方法" class="headerlink" title="webSocket方法"></a>webSocket方法</h2><p>webSocket 对象的相关方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>send()</td>
<td>使用连接发送数据</td>
</tr>
</tbody>
</table>
</div>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1>]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的使用</title>
    <url>/2021/10/16/webpack%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>webpack是前端资源构建工具，一个静态模板打包器。</strong></p>
<p>虽然webpack是前端开发绕不开的工具，但是实在是很难用，配置起来很麻烦，需要下载各种loader,plugin，而且还得注意各种版本号的匹配，很容易突然报错，让人头大，文档对使用者也不是那么友好，虽然有各种吐槽的地方，但是它的作用还是非常大的，所以就在这记录一下我这几天的学习笔记、</p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry:"></a>entry:</h2><p>entrys指示webpack以哪个文件作为入口起点分析构建内部依赖图并进行打包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这里的配置，入口就是这个 main.js 文件</p>
<span id="more"></span>
<p>而这个main.js文件里面通过模块化引用，将我们所需要的其他js文件引入main.js中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用commonJS的模块化规范</span></span><br><span class="line"><span class="keyword">const</span> &#123; add &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mathUtiles.js&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES6的模块化规范</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, height &#125; <span class="keyword">from</span> <span class="string">&#x27;./info.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br></pre></td></tr></table></figure>
<p>当然main.js文件并不只是引入这些内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.使用commonJS的模块化规范</span></span><br><span class="line"><span class="keyword">const</span> &#123; add &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/mathUtiles.js&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化规范</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, height &#125; <span class="keyword">from</span> <span class="string">&#x27;./js/info.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.依赖css文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;style-loader!css-loader!./css/normal.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.依赖less文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/special.less&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.writeln(<span class="string">&#x27;&lt;h2&gt;hello&lt;/h2&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// import test from &#x27;./vue/test&#x27;</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./vue/Test.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#test&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;test/&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        test</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在这个main.js中引入各种各样的前端文件，像css,less,js,vue啥的，引入时最好分下类，不然会很乱。</p>
<h2 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h2><p>output指示webpack打包后的资源bounldes输出到那里去，以及如何命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是把main.js文件打包到’./dist/‘的文件目录下，文件名是bundle.js</p>
<p>这样我们就只需要在index.html下引入这个文件就完成了整个页面的渲染：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这个是导入vue，因为vue都是在js中写的，所以只需要写着一句话，后面只需要引入js文件，就会把我们利用vue模板编译的内容替换显示出来--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个bundle.js文件就是将main.js打包后的文件。</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader的目的就是去处理哪些非js文件，因为webpack文件本身只能理解JavaScript</p>
<ul>
<li>css-loader/style-loader</li>
<li>less-loader/less</li>
<li>url-loader/file-loader</li>
<li>babel-loader</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// publicPath: &#x27;dist/&#x27;,这个属性注释掉，因为在dist已经有了index.html文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">      <span class="attr">rules</span>: [&#123;    </span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">          <span class="comment">//比较反人类，编译是自下而上，自右向左的，所以有了下面的顺序</span></span><br><span class="line">          <span class="comment">//注意：这里顺序不能乱！！！</span></span><br><span class="line">          <span class="comment">//use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],</span></span><br><span class="line">          <span class="comment">//可以传递字符串，顺序自右向左</span></span><br><span class="line">          use: [&#123;</span><br><span class="line">              <span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// 在js字符串中创建样式节点</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">              <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// css加载</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">              <span class="attr">loader</span>: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// 将less文件编译成css文件</span></span><br><span class="line">          &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                  <span class="attr">options</span>: &#123;</span><br><span class="line">                      <span class="comment">//当图片小于limit时，会将图片编译成base64</span></span><br><span class="line">                      <span class="comment">//当图片大于limit时，需要使用file-loader模块进行加载</span></span><br><span class="line">                      <span class="attr">limit</span>: <span class="number">12000</span>,</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;img/[name].[hash:8].[ext]&quot;</span> <span class="comment">//通过这个属性来规定打包后的文件的命名格式</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">          use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>新增的module就是给我们下载的loder进行配置的，test通过正则表达式匹配到这些文件扩展名，然后在use数组中传入使用的loader，这里既可以是对象也可以是字符串，不过对象的好处就是可以进行其他的配置。</p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>Plugins（插件）可以用于执行范围更广的任务，范围包括从打包和压缩，一直到重新定义环境中的变量等。</p>
<h1 id="webpack配置vue"><a href="#webpack配置vue" class="headerlink" title="webpack配置vue"></a>webpack配置vue</h1><ul>
<li>vue-loader：vue的加载</li>
<li>vue-template-compile：vue的编译</li>
</ul>
<p>webpack.config.js中的新增配置内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; webpack &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">      <span class="attr">rules</span>: [&#123;</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">          use: [<span class="string">&#x27;vue-loader&#x27;</span>]<span class="comment">//配置.vue文件的loader</span></span><br><span class="line">      &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">      <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],<span class="comment">//查找顺序从左向右，匹配则终止</span></span><br><span class="line">          <span class="comment">//这个extensions是实现导入文件省略.vue </span></span><br><span class="line">          <span class="comment">//比如import Cpn from &quot;./Cpn.vue&quot;;就可以简写成import Cpn from &quot;./Cpn&quot;;</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      <span class="comment">//alias别名</span></span><br><span class="line">      <span class="attr">alias</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">          <span class="comment">//将原本的runtime-only改成runtime-complier，这样就可以使用template了</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的alias是给这个路径起了一个别名，也就是说后面用到这个路径 ‘vue/dist/vue.esm.js’ 就直接写 ‘vue’ 即可</p>
<p>在index.html文件中需要导入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>main.js文件中导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span><span class="comment">//这里的导入就是使用那个别名定义的路径进行导入的</span></span><br><span class="line"><span class="comment">// import test from &#x27;./vue/test&#x27;</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./vue/Test.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#test&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;test/&gt;&#x27;</span>,<span class="comment">//使用这个组件</span></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//同时有el和template时，template中的内容会替换掉index.html中的&lt;div id=&quot;test&quot;&gt;&lt;div&gt;</span></span><br><span class="line">    <span class="comment">//而这个&#x27;&lt;test/&gt;&#x27;又是一个组件，但组建的内容封装在Test.vue中的template内</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        test<span class="comment">//注册一下这个组件</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>import test from &#39;./vue/Test.vue&#39;</code>将我们编写的.vue文件导出，这个.vue文件就是template中的组件</p>
<p>不过你可能有个疑问，我们这里不是可以引入.js文件吗？为什么要使用.vue文件？</p>
<p>这里对比导入.js的文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click=&#x27;btnClick&#x27;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>js代码和html代码并没有实现很好的分离，导致我们写代码时并不是那么清晰和舒服</p>
<p>而导入 .vue文件的好处是实现html和js文件相分离，不过由于vue是特殊的文件类型，我们使用时需要进行相关的loader和编译的下载，也就是最开始提到的vue-loader 和 vue-template-compile。</p>
<p>我们可以观察Test.vue文件中的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">Cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Cpn <span class="keyword">from</span> <span class="string">&quot;./Cpn&quot;</span>;<span class="comment">//引入子组件，webpack.config.js中配置了extensions，所以.vue可以省略</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;world&quot;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Cpn,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;<span class="comment">//默认导出这一部分代码</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">142</span>, <span class="number">226</span>, <span class="number">146</span>);</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>html、js、css是不是很清晰！！！</p>
<p>这里可以继续引入子组件，上面我就引入了一个名为 Cpn的子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>cpn子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;Cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h1><ul>
<li>webpack-dev-server</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        <span class="attr">inline</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过webpack-dev-server搭建本地服务器</span></span><br><span class="line">    <span class="comment">// devserver也是作为webpack中的一个选项，选项本身可以设置如下属性</span></span><br><span class="line">    <span class="comment">// contentBase:为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</span></span><br><span class="line">    <span class="comment">//port:端口号</span></span><br><span class="line">    <span class="comment">// inline:页面实时刷新</span></span><br><span class="line">    <span class="comment">// historyApiFallback:在SPA页面中，依赖HTML5的history模式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="分离配置"><a href="#分离配置" class="headerlink" title="分离配置"></a>分离配置</h1><p>我们可以将webpack.config.js分成三个js文件（prod.config.js、dev.config.js、base.config.js）存储在build文件夹中</p>
<p>然后使用webpack-merge这个插件将这些文件进行整合</p>
<h3 id="base-config-js：基础配置文件"><a href="#base-config-js：基础配置文件" class="headerlink" title="base.config.js：基础配置文件"></a>base.config.js：基础配置文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);<span class="comment">//这个插件是将index.html文件打包到dist中</span></span><br><span class="line"><span class="comment">//html-webpack-plugin做了两件事：</span></span><br><span class="line"><span class="comment">//自动生成一个index.html文件（可以指定模板来生成）</span></span><br><span class="line"><span class="comment">//将打包的js文件，自动通过script标签插入到body中</span></span><br><span class="line"><span class="keyword">const</span> uglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">//uglifyjs-webpack-plugin是将js文件压缩的插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="comment">// path: path.resolve(__dirname, &#x27;dist&#x27;),//这里需要修改一下，因为不是当前目录的dist</span></span><br><span class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// publicPath: &#x27;dist/&#x27;,这个属性注释掉，因为在dist已经有了index.html文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span> </span><br><span class="line">         &#125;, &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span> </span><br><span class="line">         &#125;, &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">     &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                 <span class="attr">options</span>: &#123;</span><br><span class="line">                     <span class="attr">limit</span>: <span class="number">12000</span>,</span><br><span class="line">                     <span class="attr">name</span>: <span class="string">&quot;img/[name].[hash:8].[ext]&quot;</span> </span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">         use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">     &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">resolve</span>: &#123;</span><br><span class="line">     <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">     <span class="comment">//alias别名</span></span><br><span class="line">     <span class="attr">alias</span>: &#123;</span><br><span class="line">         <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">plugins</span>: [</span><br><span class="line">     <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">         <span class="attr">template</span>: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">     &#125;),</span><br><span class="line"> ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是渲染成页面要配置的内容。</p>
<h3 id="prod-config-js：生产配置文件"><a href="#prod-config-js：生产配置文件" class="headerlink" title="prod.config.js：生产配置文件"></a>prod.config.js：生产配置文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">//uglifyjs-webpack-plugin是将js文件压缩的插件</span></span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> uglifyjsWebpackPlugin(),</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里使用了压缩js文件的插件，减少体积，更易于生产</p>
<h3 id="dev-config-js-开发环境配置文件"><a href="#dev-config-js-开发环境配置文件" class="headerlink" title="dev.config.js: 开发环境配置文件"></a>dev.config.js: 开发环境配置文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        <span class="attr">inline</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过webpack-dev-server搭建本地服务器</span></span><br><span class="line">    <span class="comment">// devserver也是作为webpack中的一个选项，选项本身可以设置如下属性</span></span><br><span class="line">    <span class="comment">// contentBase:为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</span></span><br><span class="line">    <span class="comment">//port:端口号</span></span><br><span class="line">    <span class="comment">// inline:页面实时刷新</span></span><br><span class="line">    <span class="comment">// historyApiFallback:在SPA页面中，依赖HTML5的history模式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里配置了本地服务器，用于实时刷新浏览器查看效果。</p>
<p>然后修改package.json文件里的build、dev：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config ./build/prod.config.js&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --open --config ./build/dev.config.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>对比原本的package.json文件中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样就实现了开发环境和生产环境的分离</p>
<p>通过 npm run dev 运行开发环境，只需运行一次，本地服务器可以实时刷新预览修改内容</p>
<p>通过npm run build 运行生产环境，将所有修改的文件进行一次编译</p>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>不等式</title>
    <url>/2021/08/21/%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>收录一些比较常见的不等式</p>
</blockquote>
<h1 id="⭐基本不等式链"><a href="#⭐基本不等式链" class="headerlink" title="⭐基本不等式链"></a>⭐基本不等式链</h1><blockquote>
<p>调几算方</p>
</blockquote>
<p>对非负实数$a,b$，有</p>
<script type="math/tex; mode=display">
\frac{2}{\dfrac{1}{a}+\dfrac{1}{b}}\leqslant\sqrt{ab}\leqslant\frac{a+b}{2}\leqslant\sqrt{\frac{a^2+b^2}{2}}</script><p>等号成立当且仅当 $a=b$</p>
<p>$\dfrac{2}{\dfrac{1}{a}+\dfrac{1}{b}}$ 称作 $a,b$的 <strong>调和平均值</strong></p>
<p>$\sqrt{ab}$ 称作$a,b$的 <strong>几何平均值</strong></p>
<p>$\dfrac{a+b}{2}$ 称作$a,b$的 <strong>算术平均值</strong></p>
<p>$\sqrt{\dfrac{a^2+b^2}{2}}$ 称作$a,b$的 <strong>平方平均值</strong></p>
<span id="more"></span>
<p><strong>推广</strong></p>
<script type="math/tex; mode=display">
\frac{n}{\sum\limits_{i=1}^n\dfrac{1}{a_i}}\;\leqslant\;\sqrt[n]{\prod\limits_{i=1}^n}a_i\;\leqslant\;\frac{\sum\limits_{i=1}^na_i}{n}\;\leqslant\;\sqrt{\frac{\sum\limits_{i=1}^na_i^2}{n}}</script><h1 id="柯西不等式"><a href="#柯西不等式" class="headerlink" title="柯西不等式"></a>柯西不等式</h1><h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h2><p>设 $a_1,a_2,\cdots,a_n,b_1,b_2,\cdots,b_n$ 为实数，则：</p>
<script type="math/tex; mode=display">
(a_1^2+a_2^2+\cdots+a_n^2)(b_1^2+b_2^2+\cdots+b_n^2)\geqslant(a_1b_1+a_2b_2+\cdots+a_nb_n)^2</script><p>当且仅当 $\dfrac{a_1}{b_1}=\cdots=\dfrac{a_n}{b_n}$ 时，不等式等号成立</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p><strong>向量证明</strong><br>记两个 $n$ 维向量，$\vec{a}=(a_1,a_2,\cdots,a_n)$，$\vec{b}=(b_1,b_2,\cdots,b_n)$</p>
<p>其满足</p>
<script type="math/tex; mode=display">
\vec{a}·\vec{b}=|\vec{a}||\vec{b}|\cos\theta\leqslant|\vec{a}||\vec{b}|</script><p>即</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^na_ib_i\;\leqslant\;\sqrt{\sum\limits_{i=1}^na_i^2}\;·\;\sqrt{\sum\limits_{i=1}^nb_i^2}</script><p>两边同时平方，得</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^na_i^2\;·\;\sum\limits_{i=1}^nb_i^2\;\geqslant\;\left(\;\sum\limits_{i=1}^n a_ib_i\;\right)^2</script><p>当且仅当 $\cos\theta=1$ ，即 <strong>两向量线性相关时取等</strong>，也就是 $\dfrac{a_1}{b_1}=\cdots=\dfrac{a_n}{b_n}$</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="点到直线距离"><a href="#点到直线距离" class="headerlink" title="点到直线距离"></a>点到直线距离</h3><p><strong>二维</strong></p>
<p>设直线方程为 $Ax+By+C=0$，其上取一点$M(x,y)$，在平面上取一点 $P(x_0,y_0)$</p>
<script type="math/tex; mode=display">
PM=\sqrt{(x-x_0)^2+(y-y_0)^2}</script><p>我们知道点到直线的距离就是 $PM_{min}$</p>
<p>而由柯西不等式得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt{(A^2+B^2)\left[(x-x_0)^2+(y-y_0)^2\right]}&\geqslant| A(x-x_0)+B(y-y_0)|\\
&=|Ax+By-Ax_0-By_0|\\
&=|Ax_0+By_0+C|
\end{aligned}</script><p>所以 </p>
<script type="math/tex; mode=display">
d=PM_{min}=\frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}}</script><h3 id="⭐积分形式"><a href="#⭐积分形式" class="headerlink" title="⭐积分形式"></a>⭐积分形式</h3><script type="math/tex; mode=display">
\int f^2(x)dx\int g^2(x)dx\geqslant\left(\int f(x)g(x)dx\right)^2</script><h1 id="伦琴不等式"><a href="#伦琴不等式" class="headerlink" title="伦琴不等式"></a>伦琴不等式</h1><p><strong>凸函数</strong> $f’’(x)&lt;0$</p>
<script type="math/tex; mode=display">
f(\frac{a+b}{2})\;\geqslant\;\frac{f(a)+f(b)}{2}</script>]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关于hexo的next主题的适配问题</title>
    <url>/2021/06/25/%E4%B8%80%E4%BA%9Bhexo%E7%9A%84%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里记录一些hexo方面的问题</p>
<p>今天对于next主题的移动端的问题进行了一些研究，发现在mathjax渲染下存在手机屏幕右方预留出大量空白的问题，<br>问题一：latex数学符号编辑 <strong>$$</strong> 中的内容过长，导致公式溢出屏幕。解决方法：1.将符号用 <strong>$$</strong> 包裹，文字不进行包裹，这样<br>文字是markdown的形式，可以实现自动换行，2.对于过长的数学等式，我目前采用的方法是在前面添加-或1.这种<br>形式在移动端的浏览器，比如百度，夸克……可以实现左右滚动处理<br>问题二：mathjax渲染问题，经过筛选，我发现用cases来编写方程组，aligned内部//过多……会造成即使符号未溢出屏幕，<br>也会造成手机页面右方预留出大量空白，解决方法：仍然是添加-或1.让其实现类似于代码块的左右滚动处理。<br>但是对于问题二，目前没有想出为什么会出现这种情况，因为对前端不是很了解，所以这个问题暂且搁置，等以后进行分析，<br>当然目前的这些解决方法并不能从根本上解决问题，但目前在网络上并没又找到类似问题的解决方法，所以暂时只好这样处理这<br>两个问题,更好的解决办法以后再寻找<br>问题三:移动端不同浏览器的适配问题，我发现在不同浏览器中笔记的显示不太一样，目前适配比较好的是夸克，以后慢慢研究</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>初入</title>
    <url>/2021/06/15/%E5%88%9D%E5%85%A5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b0ca2ef9541fede87b8c708a533c49229e736ec76cfc1393c6388623a747d871">b932aaa1676845656e99a89ce5708d0a6d629f27376e686be0b7b81e242a554ca974cb7c0d19940d116aac2233fcde8c0eaaa3f436a53ab205c47dd54ff1d66cf3e524aec81cb572511195ff71a4c0e06e620fff646ae43ba520c1ae0f329c5dffba1e93b59f84a0c2e570805a0ed6ceb0b9ed142ef2b3b0e86f5b7c752329902963b266d8ecf12d7ce1be312d2bb6f9595f2b670482e5713110f82d2a2f865ca301078ffccbd1b588c0c1f26f4500ba867d1fde9951ff463ee5b992cc3f349d0d89b4caa0eb3460a8f1be637f6bc948af3229c57d9f719e0c0f45513e595a66df62e9da096655e355d51cdd32e2b3efd3308c1a2de4424c9e3e5f059bf33fa7a46d57972a8d440a32545d2ffa75a01f81c0af8979df87c4f26acc1d4182e2baf55748e271f618ca61c55df3ebd9f473a3017555f54ce12602f483c695ef5c7f3a9765c6405bb25eb7f5f4a96d9be65c830c784451c8c97e869239b5746673f2ea8b3f3cc7467e2e74e91259924bfca411b4d30a06d71be6859c7bebde9e9349912c90c8805cd3152df3e549be7ffb40fe2fe31ab56a91ae73f890c8a111dbc7c443521f4d7f12992588f0fd41b5fe299bd135ee19f4c196d5c620d5554a3ad785cf3afe7b9724b0ea0dd0d92445e566697a1bea4b0018a626dc364372db46c9af9e5dbcc2948ce471ef093e70ec3fcfbf5aa8ff12e3ecd505ac142b0a82e1e9e0043af9756589b2ee868f361c92108f74f8d6e2995fa35a76dda720b3bfb438f25d214a45f3878e262b6abda60fe07bef03958a389f863164d05c893a5863300bea6a777046af655fb3b366c540935c766bc2b7c4c1d1f6d16662fd1321730bd182da504af842c2c01585322ae8768f750ba584a8e8eb53e4b32ed1afb7ca786c82ebfd2d3ef6ad2c03e749ffdcfdfd5f1c1e94c11ec03e5d959f25b73a9ea7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>无穷级数</title>
    <url>/2021/08/18/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><h2 id="函数的傅里叶-fourier-级数"><a href="#函数的傅里叶-fourier-级数" class="headerlink" title="函数的傅里叶(fourier)级数"></a>函数的傅里叶(fourier)级数</h2><p>设函数$f(x)$在区间$[-\pi,\pi]$（或$[0,2\pi]$）上可积，则称</p>
<script type="math/tex; mode=display">
a_n=\displaystyle\frac1\pi\int^{\pi}_{-\pi}f(x)\cos nx dx\quad n=0,1,2\cdots</script><script type="math/tex; mode=display">
b_n=\displaystyle\frac1\pi\int^{\pi}_{-\pi}f(x)\sin nx dx\quad n=1,2\cdots,</script><p>为函数$f(x)$的傅里叶系数，由上述$a_n,b_n$所形成的三角级数</p>
<script type="math/tex; mode=display">
\displaystyle\frac{a_0}{2}+\sum\limits_{n=1}^∞(a_n\cos nx+b_n\sin nx)</script><p>称为函数$f(x)$的傅里叶级数。<br><span id="more"></span><br><strong>正弦级数</strong><br>若$f(x)$是$(-\pi,\pi)$上的奇函数，则</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{n=1}^{∞}b_n\sin nx,</script><p>其中 $b_n=\displaystyle\frac2\pi\int^{\pi}_0f(x)\sin nx dx\quad n=1,2\cdots,$</p>
<p><strong>余弦级数</strong><br>若$f(x)$是$(-\pi,\pi)$上的偶函数，则</p>
<script type="math/tex; mode=display">
f(x)=\displaystyle\frac{a_0}{2}+\sum\limits_{n=1}^{∞}a_n\cos nx,</script><p>其中 $a_n=\displaystyle\frac2\pi\int^{\pi}_0f(x)\cos nx dx\quad n=0,1,2\cdots$</p>
<h2 id="迪利克雷-Dirichlet-定理"><a href="#迪利克雷-Dirichlet-定理" class="headerlink" title="迪利克雷(Dirichlet)定理"></a>迪利克雷(Dirichlet)定理</h2><p>设函数$f(x)$在区间$[-\pi,\pi]$（或$[0,2\pi]$）上满足条件：</p>
<ul>
<li>连续或只有有限个第一类间断点；</li>
<li>至多只有有限个极值点</li>
</ul>
<p>则$f(x)$的傅里叶级数</p>
<script type="math/tex; mode=display">\displaystyle\frac{a_0}{2}+\sum\limits_{n=1}^∞(a_n\cos nx+b_n\cos nx)</script><p>在区间$[-\pi,\pi]$或（$[0,2\pi]$）上收敛，并且，若其和函数为$S(x)$，则有：</p>
<ol>
<li>在$f(x)$的连续点处，$S(x)=f(x)$；</li>
<li>在$f(x)$的间断点 $x_0$处，$S(x)=\displaystyle\frac{f(x_0-0)+f(x_0+0)}{2}$，</li>
<li>在端点 $x=\pm\pi$ 处，$S(x)=\displaystyle\frac{f(-\pi+0)+f(\pi+0)}{2}$<br>(或在 $x=0,2\pi$ 处)</li>
</ol>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>在知乎上看到一种推导方法，当然原答有些错误，但思路不难，所以这里根据他的思路，进行了一下简单的推导</p>
<p>首先我们要明确傅里叶级数就是将函数通过无数个简单三角函数累加得到的，</p>
<p>所以我们可以写出其最一般的形式</p>
<script type="math/tex; mode=display">f(t)=A_0+\sum\limits_{n=1}^∞ A_n\sin(n\omega t+\psi_0)</script><p>因为</p>
<script type="math/tex; mode=display">A_n\sin(n\omega t+\psi_0)=A_n\sin\psi_0 \cos(n\omega t)+A_n\cos\psi_0\sin(n\omega t)</script><p>这里令 $a_n=A_n\sin\psi_0$，$b_n=A_n\cos\psi_0$</p>
<p>那么</p>
<script type="math/tex; mode=display">
f(t)=A_0+\sum\limits_{n=1}^∞a_n\cos(n\omega t)+b_n\sin(n\omega t)</script><p>问题就转化成求出$A_0、a_n、b_n$</p>
<p><strong>在求之前介绍个概念</strong></p>
<p><strong>三角函数的正交性</strong><br>默认m，n都为正整数</p>
<p>$<br>\displaystyle\int_{-\pi}^{\pi}\sin nxdx=0<br>$</p>
<p>$<br>\displaystyle\int_{-\pi}^{\pi}\cos nxdx = 0<br>$</p>
<p>$<br>\begin{aligned}<br>\int_{-\pi}^{\pi}\sin mx\sin nxdx=<br>\begin{cases}<br>0，\quad m\neq n\\<br>\pi\quad m=n<br>\end{cases}<br>\end{aligned}<br>$</p>
<p>$<br>\int_{-\pi}^{\pi}\cos mx\cos nxdx=<br>\begin{cases}<br>0，\quad m\neq n\\<br>\pi\quad m=n<br>\end{cases}<br>$</p>
<p>$<br>\displaystyle\int_{-\pi}^{\pi}\sin mx\cos nxdx=0<br>$</p>
<p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}f(t)dt
&=\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}A_0dt+\sum\limits_{n=1}^∞\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}a_n\cos(n\omega t)+b_n\sin(n\omega t)dt\\
&=\frac{2\pi}{\omega} A_0+0\\
&=\frac{2\pi}{\omega} A_0
\end{aligned}</script><p>$\therefore A_0=\displaystyle\frac{\omega}{2\pi}\int_{-\pi}^{\pi}f(t)dt$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}f(t)\cos(n\omega t)dt
&=\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}A_0\cos(n\omega t)dt\\
&\quad+\sum\limits_{n=1}^∞\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}a_n\cos^2(n\omega t)+b_n\sin(n\omega t)\cos(n\omega t)dt\\
&=0+0+a_n\;\frac\pi\omega\\
\end{aligned}</script><p>$\therefore a_n=\displaystyle\frac{\omega}{\pi}\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}\cos(n\omega t)·f(t)dt$</p>
<p>同理</p>
<p>$b_n=\displaystyle\frac{\omega}{\pi}\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}\sin(n\omega t)·f(t)dt$</p>
<p>为了统一分母，我们令$a_0=2A_0$</p>
<p>那么就得到了傅里叶级数的形式</p>
<script type="math/tex; mode=display">
f(t)=\displaystyle\frac{a_0}{2}+\sum\limits_{n=1}^∞a_n\cos(n\omega t)+b_n\sin(n\omega t)</script><p>其中</p>
<p>$a_n=\displaystyle\frac{\omega}{\pi}\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}\cos(n\omega t)·f(t)dt$</p>
<p>$b_n=\displaystyle\frac{\omega}{\pi}\int_{-\frac{\pi}{\omega}}^{\frac{\pi}{\omega}}\sin(n\omega t)·f(t)dt$</p>
<p>为了表达方便，这里令 $\displaystyle\frac{\pi}{\omega}$为 $l$，那么就得到了在 <strong>区间$[-l,l]$上的傅里叶级数</strong></p>
<p><strong>即</strong></p>
<script type="math/tex; mode=display">
f(t)=\displaystyle\frac{a_0}{2}+\sum\limits_{n=1}^∞a_n\cos(n\;\frac{\pi}{l}\;t)+b_n\sin(n\;\frac{\pi}{l}\;t)</script><p><strong>其中</strong></p>
<p>$a_n=\displaystyle\frac{1}{l}\int_{-l}^{l}\cos(n\;\frac{\pi}{l}\;t)·f(t)dt$</p>
<p>$b_n=\displaystyle\frac{1}{l}\int_{-l}^{l}\sin(n\;\frac{\pi}{l}\;t)·f(t)dt$</p>
]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>数学竞赛试题收录</title>
    <url>/2021/08/23/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一届"><a href="#第一届" class="headerlink" title="第一届"></a>第一届</h1><h2 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h2><p><strong>问题</strong>：</p>
<p>已知平面区域 $D=\{(x, y) \mid 0 \leqslant x \leqslant \pi, 0 \leqslant y \leqslant \pi\} \quad L$ 为 $D$的正向边界, 试证：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(1)\oint_{L} x e^{\sin y} d y-y e^{-\sin x} d x=\oint_{L} x e^{-\sin y} d y-y e^{\sin x} d x\\
&(2)\oint_{L} x e^{\sin y} d y-y e^{-\sin x} d x \geqslant \dfrac{5}{2} \pi^{2}
\end{aligned}</script><hr>
<p><strong>分析</strong>：</p>
<p>第一问很基础，可以用格林公式，也可以用对称性</p>
<p>第二问主要就在于放缩的精度问题，这里不能用基本不等式，因为精度不够。</p>
<span id="more"></span>
<script type="math/tex; mode=display">
\begin{aligned}
\oint_Lxe^{\sin y}dy -ye^{-\sin x}dx&=\iint\limits_D e^{\sin y}+e^{-\sin x}dxdy\\
&=\iint\limits_D e^{\sin x}+e^{-\sin x}dxdy\\
\end{aligned}</script><p>所以本题目标很明确，只需要对 $e^x+e^{-x}$ 进行放缩，我们知道 $e^x$ 的泰勒级数</p>
<script type="math/tex; mode=display">
e^x=\sum\limits_{n=0}^∞\frac{1}{n!}x^n</script><p>所以说</p>
<script type="math/tex; mode=display">
\begin{aligned}
e^x+e^{-x}&=\sum\limits_{n=0}^∞\frac{1}{n!}x^n+\sum\limits_{n=0}^∞(-1)^n\frac{1}{n!}x^n\\
&=2\sum\limits_{n=0}^∞\frac{1}{(2n)!}x^{2n}
\end{aligned}</script><p>根据题目，这里只需要取前两项</p>
<p>也就是 $e^x+e^{-x}\geqslant2+x^2$</p>
<script type="math/tex; mode=display">
\iint\limits_D e^{\sin x}+e^{-\sin x}dxdy\geqslant\iint\limits_D2+x^2d\delta\geqslant\frac{5}{2}\pi^2</script><hr>
<h2 id="积分审敛法"><a href="#积分审敛法" class="headerlink" title="积分审敛法"></a>积分审敛法</h2><p><strong>问题</strong>：</p>
<p>求 $x\rightarrow 1^-$ 时，与 $\sum\limits_{n=0}^∞x^{n^2}$等价的无穷大量</p>
<hr>
<p><strong>分析</strong>：</p>
<p>等价无穷大，也就是</p>
<script type="math/tex; mode=display">
\lim\limits_{x\rightarrow1^-}\frac{\sum\limits_{n=0}^\infty x^{n^2} }{f(x) }=1</script><p>如何寻找 $f(x)$ 呢？利用 <strong>级数和积分的联系</strong>，级数可以说是数列的“反常积分”</p>
<p>观察这个式子，我们会发现这种形式类似于高斯积分</p>
<script type="math/tex; mode=display">
\int_0^{+\infty} e^{-ax^2}dx=\frac12\sqrt\frac{\pi}{a}</script><p>这里其实就是证明积分审敛法的不等式，当然这里要保证 $x^{n^2}$ 单调递减，由题意可以知道它确实单调递减</p>
<script type="math/tex; mode=display">
\int_0^{+\infty} x^{t^2}dt\leqslant\sum\limits_{n=0}^\infty x^{n^2}\leqslant1+\int_0^{+\infty} x^{t^2}dt</script><blockquote>
<p>这里来证明一下积分审敛法，并引出这个不等式的由来：</p>
<p>积分审敛法：设 $\sum\limits_{n=1}^\infty u_n$ 为正项级数，若存在 $[1,\infty)$ 内单调减少的非负连续函数 $f(x)$ ,使得 $u_n=f(n)$ ，则级数 $\sum\limits_{n=1}^\infty u_n$ 与反常积分 $\displaystyle\int_1^{+\infty}f(x)dx$ 的收敛性相同</p>
<p>证：由已知，当 $k\leqslant x\leqslant k+1$ $(k\in Z^*)$ 时，</p>
<script type="math/tex; mode=display">
f(k+1)\leqslant f(x)\leqslant f(k)</script><p>从而有</p>
<script type="math/tex; mode=display">
f(k+1)\leqslant\int_k^{k+1}f(x)dx\leqslant f(k)</script><p>故</p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^n f(k+1)\leqslant\sum\limits_{k=1}^n\int_k^{k+1}f(x)dx=\int_1^{n+1}f(x)dx\leqslant\sum\limits_{k=1}^nf(k)</script><p>因此，若 $\displaystyle\int_1^{+\infty}f(x)dx$ 收敛，则对任意自然数 $n$ 有，</p>
<script type="math/tex; mode=display">
s_n=\sum\limits_{k=0}^nf(k+1)\leqslant f(1)+\int_1^nf(x)dx\leqslant f(1)+\int_1^{+\infty}f(x)dx</script><p>从这个不等式，我们就可以知道上面那个不等式右半边的由来，</p>
<script type="math/tex; mode=display">
\sum\limits_{n=0}^\infty u_n\leqslant f(0)+\int_0^{+\infty}f(t)dt</script><p>故$\sum\limits_{n=1}^\infty u_n$ 收敛</p>
</blockquote>
<p>所以可求得其等价无穷大量</p>
<script type="math/tex; mode=display">
\int_0^{+\infty} x^{t^2}dt=\int_0^{+\infty}e^{-t^2\ln\frac{1}{x} }dt=\frac12\sqrt\frac{\pi}{\ln\frac1x}</script><p>用到的不等式，说实话感觉有点超纲……</p>
<h1 id="第二届"><a href="#第二届" class="headerlink" title="第二届"></a>第二届</h1><h2 id="极限技巧"><a href="#极限技巧" class="headerlink" title="极限技巧"></a>极限技巧</h2><p><strong>问题</strong>：</p>
<p>设$x_n=$ $(1+a)$ · $(1+a^2)$ $\cdots$ $(1+a^{2^n})$，其中$|a|&lt;1$，求$\lim\limits_{n\rightarrow+\infty}x_n$</p>
<hr>
<p><strong>分析</strong>：</p>
<p>这一题其实并不难，但是很容易把人带入坑中，因为这种形式非常类似于取对数可以转化成积分的题，但是取完对数之后，却发现还是不容易做，而这一题其实更巧妙的方法，在这里收录一下</p>
<script type="math/tex; mode=display">
\begin{aligned}
x_n&=(1+a) · (1+a^2)\cdots(1+a^{2^n})\\
&=\frac{(1-a)(1+a) · (1+a^2)\cdots(1+a^{2^n})}{1-a}\\
&=\frac{1-a^{2^{n+1} } }{1-a}\\
&=\frac{1}{1-a}
\end{aligned}</script><hr>
<h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><ul>
<li>和的极限判断敛散</li>
<li>柯西收敛准则</li>
</ul>
<p><strong>问题</strong></p>
<p>设$a_n&gt;0$，$S_n=\sum\limits_{k=1}^na_k$，证明：</p>
<p>(1) 当 $\alpha&gt;1$ 时，级数 $\sum\limits_{n=1}^{+\infty}\dfrac{a_n}{S_n^\alpha}$ 收敛</p>
<p>(2) 当 $\alpha\leqslant1$，且 $S_n\rightarrow\infty$ $(n\rightarrow \infty)$时，$\sum\limits_{n=1}^{+\infty}\dfrac{a_n}{S_n^\alpha}$ 发散</p>
<hr>
<p><strong>分析</strong>：</p>
<p>级数的题目确实比较灵活，准备将级数放缩的方法进行一些整理，像这一题，应该是用比较审敛法，如何用放缩找到一个可以判断收敛的级数呢？这得一步步来</p>
<p>首先第一问，这一题将 $S_i$ 转化成 $a_i$ 会让变量增多，而且这题没有其他特殊条件，所以不容易处理，那么就将 $a_n$ 转化成 $S_n-S_{n-1}$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum\limits_{n=1}^{+\infty}\frac{a_n}{S_n^\alpha}&=\sum\limits_{n=1}^{+\infty}\frac{S_n-S_{n-1} }{S_n^\alpha}\\
\end{aligned}</script><p>到这一步我卡了很久，怎么将其进行放缩呢？在这里我进入了一个误区，认为必须要将其放缩成常见的收敛级数，例如 p级数，但是却始终无法办到，这里我忽略了另一种办法，其实可以放缩找到一个可以进行裂项求和的级数，只要它的和收敛就行，这与证明级数 $\sum\limits_{n=1}^\infty \dfrac1n$ 发散的方法类似。</p>
<p>ok，有了这样的思路，我们就可以去寻找一个这种类型的项，其实很好发现，也就是 $S_{n-1}^{1-\alpha}-S_n^{1-\alpha}$，但是这里很难用放缩直接判断它们的大小关系，为了方便观察这里令 $m=S_n$，$n=S_{n-1}$</p>
<p>只要证</p>
<script type="math/tex; mode=display">
n^{1-\alpha}-m^{1-\alpha}\geqslant\frac{m-n}{m^\alpha}</script><p>这就非常清晰了，只需要借助拉格朗日中值定理，就可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
n^{1-\alpha}-m^{1-\alpha}&=(n-m)(1-\alpha)\xi^{-\alpha}\quad\xi\in(m,n)\\
&\geqslant(\alpha-1)(m-n)m^{-\alpha}\\
&\geqslant\frac{m-n}{m^\alpha}
\end{aligned}</script><p>当然正常做的时候这里构造个函数 $f(x)=x^{1-\alpha}$ ，然后利用拉格朗日中值定理</p>
<p>因为</p>
<script type="math/tex; mode=display">
\sum\limits_{n=1}^\infty S_{n-1}^{1-\alpha}-S_n^{1-\alpha}=S_1^{1-\alpha}\quad\text{收敛}</script><p>所以原级数收敛</p>
<p>第二问，由于 $\alpha\leqslant1$ 时，$\dfrac{a_n}{S_n^\alpha}$ $\geqslant\dfrac{a_n}{S_n}$</p>
<p>所以只要证明 $\alpha=1$时发散就行了</p>
<p>这一个就不容易求和的极限了</p>
<p>但是，我们可以将这个级数任意截取p个数，使得这p个数能够大于零，那么取极限就会趋近于无穷了，其实就是柯西收敛准则</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum\limits_{i=n+1}^{n+p}\frac{a_i}{S_i}\geqslant\frac{1}{S_{n+p} }\sum_{i=n+1}^{n+p}a_i&=\frac{S_{n+p}-S_n}{S_{n+p} }\\
&=1-\frac{S_n}{S_{n+p} }
\end{aligned}</script><p>对于任意 n，总存在 $p\in N$，使得 $\dfrac{S_{n} }{S_{n+p} }$ $\leqslant$ $\dfrac12 $</p>
<p>即 $\sum\limits_{i=n+1}^{n+p}\dfrac{a_i}{S_i}$ $\geqslant$ $\dfrac12$</p>
<p>所以级数 $\sum\limits_{n=1}^\infty\dfrac{a_n}{S_n}$ 发散</p>
<h1 id="第三届"><a href="#第三届" class="headerlink" title="第三届"></a>第三届</h1><h2 id="stolz定理"><a href="#stolz定理" class="headerlink" title="stolz定理"></a>stolz定理</h2><p><strong>问题</strong></p>
<p>设 $\{a_n\}_{n=0}^\infty$ 为数列，$a$，$\lambda$ 为有限数，求证：</p>
<ol>
<li>如果$\lim\limits_{n\rightarrow\infty}a_n=a$，则$\lim\limits_{n\rightarrow\infty}\dfrac{a_1+a_2+\cdots+a_n}{n} =a$；</li>
<li>如果存在正整数 $p$，使得$\lim\limits_{n\rightarrow\infty}(a_{n+p}-a_n)=\lambda$ ，则 $\lim\limits_{n\rightarrow\infty}\dfrac{a_n}{n}$ = $\dfrac{\lambda}{p}$ </li>
</ol>
<hr>
<p><strong>分析</strong></p>
<p>第一问直接用stolz定理就行了，没啥难度</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\lim\limits_{n\rightarrow\infty}\frac{a_1+a_2+\cdots+a_n}{n}\\
&=\lim\limits_{n\rightarrow\infty}\frac{(a_1+a_2+\cdots+a_n)-(a_1+a_2+\cdots+a_{n-1})}{n-(n-1)}\\
&=\lim\limits_{n\rightarrow\infty}a_n\\
&=a
\end{aligned}</script><p>第二问就不满足stolz定理的条件了，而且这道题我们必然会想到累项求和。</p>
<p>令 $A_n=a_{n+p}-a_n$</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\qquad\lim_{n\rightarrow\infty}\frac{A_1+A_2+\cdots+A_n}{n}=\lim\limits_{n\rightarrow\infty}\frac{a_{n+p}-a_1}{n}=\lim\limits_{n\rightarrow\infty}A_n=\lambda\\
\\
&\Rightarrow\;\;\lim\limits_{n\rightarrow\infty}\frac{a_{n+p} }{n+p}=\lim_{n\rightarrow\infty}\frac{a_{n+p} }{n}\frac{n}{n+p}=\frac{\lambda}{p}
\end{aligned}</script><hr>
<h2 id="曲面积分的几何理解"><a href="#曲面积分的几何理解" class="headerlink" title="曲面积分的几何理解"></a>曲面积分的几何理解</h2><p><strong>问题</strong></p>
<p>设函数 $f(x)$ 连续，$a,b,c$为常数，$\Sigma$ 是单位球面 $x^2+y^2+z^2=1$。记第一型曲面积分</p>
<script type="math/tex; mode=display">
I=\iint\limits_{\Sigma}f(ax+by+cz)dS.</script><p>求证：$I=2\pi\displaystyle\int_{-1}^1f(\sqrt{a^2+b^2+c^2}u)du$</p>
<hr>
<p><strong>分析</strong></p>
<p>拿到这一题，直接硬解的话并不容易，我们先一步步进行分析</p>
<p>首先，我们很容易发现 $f$ 括号里的东西发生了变化</p>
<p>这里得分两种情况</p>
<ul>
<li><p>$a,b,c$全为零，显然成立</p>
</li>
<li><p>$a,b,c$不全为零</p>
</li>
</ul>
<p>令</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\qquad ax+by+cz=\sqrt{a^2+b^2+c^2}u\\
\\
&\Rightarrow u=\frac{ax+by+cz}{\sqrt{a^2+b^2+c^2} }
\end{aligned}</script><p>也就是说, $|u|$ 的几何意义就是单位球面上的点$P(x,y,z)$，到平面 $ax+by+cz=0$ 的距离</p>
<p>而球面到过原点平面的距离 $|u|\in[0,1]$</p>
<p>即 $-1\leqslant u\leqslant 1$</p>
<p>我们可以将|u|,|u+du|所截的区域，被积函数范围就是$f(\sqrt{a^2+b^2+c^2}u)$，而它的面积微元$ds$其实就是定积分中旋转体面积微元</p>
<p>为了好表示，我们这里令$v^2=\sqrt{1-u^2}$</p>
<p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
ds&=2\pi\sqrt{1-u^2}\sqrt{1+\left(\frac{dv}{du}\right)^2}du\\
&=2\pi\sqrt{1-u^2}\frac{1}{\sqrt{1-u^2} }du\\
&=2\pi du
\end{aligned}</script><p>所以说 $I=2\pi\displaystyle\int_{-1}^1f(\sqrt{a^2+b^2+c^2}u)du$</p>
<p>答案的思路也是这样，并不是从代数的角度直接去证明的，而纯代数角度进行证明也确实复杂，有时间可以再试一试</p>
<h1 id="第四届"><a href="#第四届" class="headerlink" title="第四届"></a>第四届</h1><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p><strong>问题</strong></p>
<p>求极限 </p>
<script type="math/tex; mode=display">
\lim\limits_{x\rightarrow+\infty}\sqrt[3]{x}\int_x^{x+1}\frac{\sin t}{\sqrt{t+\cos t} }dt</script><hr>
<p><strong>分析</strong></p>
<p>这一题其实并不难，因为思路比较局限，泰勒公式，洛必达肯定没法用，肯定就是夹逼定理，但是这里的难点就是如何进行放缩，把这样复杂的形式放缩简单，我们其实可以猜测极限取0，再结合正余弦函数的值域</p>
<p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left|\sqrt[3]{x}\int_x^{x+1}\frac{\sin t}{\sqrt{t+\cos t} }dt\right|&\leqslant\sqrt[3]{x}\int_x^{x+1}\frac{1}{\sqrt{t-1} }dt\\
&=2\sqrt[3]{x}\;(\sqrt{x}-\sqrt{x-1})\\
&=2\frac{\sqrt[3]{x} }{\sqrt{x}+\sqrt{x-1} }\rightarrow0
\end{aligned}</script><p>问题也就解决了</p>
<p>一般来说三角函数的放缩如果是趋近于零，那么我们可以结合泰勒级数来进行放缩，而这一题显然不可以，那么我们就可以借助它的值域来进行放缩，从而化简式子，而且像这种题极限一般都是趋向于0的.</p>
<hr>
<h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><p><strong>问题</strong><br>计算</p>
<script type="math/tex; mode=display">
\int_0^{+\infty}e^{-2x}|\sin x|dx</script><hr>
<p><strong>分析</strong></p>
<p>这一题比较烦的就是这个绝对值，我们没法直接用分部积分法，因为 |sinx| 的一些点导数不存在</p>
<p>但是这种取绝对值的方法我也是第一次见，说实话，如果不看解答方法，这一题思路很难想到，简单的来说就是，在区间$[0,\infty)$上，按步长为$\pi$进行分割，达到去绝对值的目的</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int_0^{+\infty}e^{-2x}|\sin x|dx\\
\\
=&\sum\limits_{k=0}^\infty(-1)^k\int_{k\pi}^{(k+1)\pi}e^{-2x}\sin xdx\\
\\
=&\sum\limits_{k=0}^\infty\;\frac15[e^{-2(k+1)\pi}+e^{-2k\pi}]\\
\\
=&\frac15(e^{-2\pi}+1)\sum\limits_{k=0}^\infty e^{-2k\pi}
\end{aligned}</script><p>下面就转化为了求 $\sum\limits_{k=1}^\infty e^{-2k\pi}$ 这个级数的值，这个就是等比级数</p>
<p>也就是说</p>
<script type="math/tex; mode=display">
\sum\limits_{k=0}^\infty e^{-2k\pi}=\frac{1}{1-e^{-2\pi} }</script><p>所以说</p>
<script type="math/tex; mode=display">
\int_0^{+\infty}e^{-2x}|\sin x|dx=\frac{e^{2\pi}+1}{5(e^{2\pi}-1)}</script><hr>
<h2 id="级数-1"><a href="#级数-1" class="headerlink" title="级数"></a>级数</h2><p><strong>裂项相消</strong></p>
<p><strong>问题</strong><br>设 $\sum\limits_{n=1}^\infty a_n$ 和 $\sum\limits_{n=1}^\infty b_n$ 为正项级数</p>
<p>(1)若 $\lim\limits_{n\rightarrow\infty}\left(\dfrac{a_n}{a_{n+1}b_n}-\dfrac{1}{b_{n+1} }\right)&gt;0$ ，则 $\sum\limits_{n=1}^\infty a_n$ 收敛</p>
<p>(2)若 $\lim\limits_{n\rightarrow\infty}\left(\dfrac{a_n}{a_{n+1}b_n}-\dfrac{1}{b_{n+1} }\right)&lt;0$ 且 $\sum\limits_{n=1}^\infty b_n$ 发散，则 $\sum\limits_{n=1}^\infty a_n$ 发散</p>
<hr>
<p><strong>分析</strong></p>
<p>虽然作为第四届的压轴题，但是思路却非常清晰，并不是很难，但是里面的一些细节却需要注意</p>
<p>第一问假设 $\lim\limits_{n\rightarrow\infty}\left(\dfrac{a_n}{a_{n+1}b_n}-\dfrac{1}{b_{n+1} }\right)=$ $\delta&gt;0$</p>
<p>由极限的保号性可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\exists\;N\in N^*，\text{使得}，n\geqslant N\,\text{时}，\\
&\frac{a_n}{a_{n+1}b_n}-\frac{1}{b_{n+1} }>\frac{\delta}{2}\\
\Rightarrow\;&\frac{\delta}{2}\;a_{n+1}<\frac{a_n}{b_n}-\frac{a_{n+1} }{b_{n+1} }\\
\Rightarrow\;&\frac{\delta}{2}\sum\limits_{n=1}^\infty a_n < \frac{\delta}{2}\sum\limits_{n=0}^{N-1}a_n+\sum\limits_{n=N}^\infty(\frac{a_n}{b_n}-\frac{a_{n+1} }{b_{n+1} })\\
&=\frac{\delta}{2}\sum\limits_{n=0}^{N-1}a_n+\frac{a_N}{b_N}-\frac{a_{n+1} }{b_{n+1} }<\frac{\delta}{2}\sum\limits_{n=0}^{N-1}a_n+\frac{a_N}{b_N}
\end{aligned}</script><p>第二问也是同样的方法，用比较审敛法即可得出</p>
<hr>
<h1 id="第五届"><a href="#第五届" class="headerlink" title="第五届"></a>第五届</h1><h2 id="广义积分敛散性"><a href="#广义积分敛散性" class="headerlink" title="广义积分敛散性"></a>广义积分敛散性</h2><p><strong>问题</strong></p>
<p>证明广义积分 $\displaystyle\int_0^{+\infty}\dfrac{\sin x}{x}dx$ 不是绝对收敛的</p>
<hr>
<p><strong>分析</strong></p>
<p>注意这里证明的是绝对收敛，因为我们知道这个广义积分条件收敛，并且收敛于 $\dfrac{\pi}{2}$</p>
<p>广义积分的敛散性证明其实可以转化成级数的敛散性证明</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_0^\infty\frac{|\sin x|}{x}dx
&=\sum_{n=0}^\infty\int_{n\pi}^{(n+1)\pi}\frac{|\sin x|}{x}dx\\
&=\sum_{n=0}^\infty a_n
\end{aligned}</script><p>下面就通过比较审敛法证明 $\sum\limits_{n=0}^\infty a_n$ 发散即可</p>
<p>由于</p>
<script type="math/tex; mode=display">
\begin{aligned}
a_n
&=\int_{n\pi}^{(n+1)\pi}\frac{|\sin x|}{x}dx\\
&\geqslant\frac{1}{(n+1)\pi}\int_{n\pi}^{(n+1)\pi}|\sin x|dx\\
&=\frac{1}{(n+1)\pi}\int_0^\pi|\sin x|dx\\
&=\frac{2}{(n+1)\pi}
\end{aligned}</script><p>因为 $\sum\limits_{n=0}^\infty\dfrac{2}{(n+1)\pi}$发散，所以原级数发散</p>
<hr>
<h2 id="不等式-含三角"><a href="#不等式-含三角" class="headerlink" title="不等式(含三角)"></a>不等式(含三角)</h2><p><strong>问题</strong></p>
<p>设 $|f(x)|\leqslant\pi$，$f’(x)\geqslant$ $m&gt;0$ $(a\leqslant x\leqslant b)$，证明：$|\displaystyle\int_a^b\sin f(x)dx|$ $\leqslant$ $\dfrac{2}{m}$</p>
<hr>
<p><strong>分析</strong></p>
<p>这一题比较烦的就是 $\sin f(x)$ 中的 $f(x)$，我们可以选择将其代换掉，但这里为了方便些就不做代换了，还有一点就是我们必须凑出 $\dfrac{1}{m}$ 这种形式，不难发现 </p>
<script type="math/tex; mode=display">
\frac{1}{f'(x)}=\frac{dx}{df(x)}\leqslant \frac{1}{m}</script><p>沿着这个思路，我们就可以进行如下放缩</p>
<script type="math/tex; mode=display">
\begin{aligned}
|\int_a^b\sin f(x)dx|&=|\int_a^b\sin f(x)\frac{dx}{df(x)}df(x)|\\
&\leqslant\frac1m|\int_a^b\sin f(x)df(x)|\\
&=\frac1m|\cos f(a)-\cos f(b)|\leqslant\frac2m
\end{aligned}</script><hr>
<h1 id="第六届"><a href="#第六届" class="headerlink" title="第六届"></a>第六届</h1><h2 id="数列极限定义"><a href="#数列极限定义" class="headerlink" title="数列极限定义"></a>数列极限定义</h2><p><strong>积分不等式</strong></p>
<p><strong>问题</strong></p>
<p>设 $f$ 在 $[a,b]$ 上非负连续，严格单增，且存在 $x_n\in[a,b]$ 使得</p>
<script type="math/tex; mode=display">
[f(x_n)]^n=\frac{1}{b-a}\int_a^b[f(x)]^ndx</script><p>求 $\lim\limits_{n\rightarrow\infty}x_n.$</p>
<hr>
<p><strong>分析</strong></p>
<p>我认为这一题难度很大，其实就是函数和数列极限的结合，我们没法得到 $x_n$ 具体是什么，但是我们可以很容易画出它的图形，由于这里的 $f(x)$ 非负连续，且严格单调递增，那么当 $n\rightarrow\infty$ 时，$f(x)^n$ 一定会变得非常非常陡峭，站在宏观来看，$a,b$ 几乎就可以看成重合的两个点，所以极限值应该在 $a,b$ ,这两点，然后再通过观察图形，我们很容易猜测出 $\lim\limits_{n\rightarrow\infty}x_n =b$  </p>
<p>到这其实只是迈出了第一步，因为这是几何的直观理解，我们必须将其代数化证明，当然这一题的方法基本锁定，数列极限定义。</p>
<p>只要证明出来</p>
<p>$\forall \epsilon&gt;0$ ，$\exists N$，使得 $n&gt;N$ 时，都有 $|x_n-b|&lt;\epsilon$ </p>
<p>由于这里的 $f(x)$ 严格单增，</p>
<p>所以只要证明 </p>
<script type="math/tex; mode=display">
[f(b-\epsilon)]^n<[f(x_n)]^n=\frac{1}{b-a}\displaystyle\int_a^b [f(x)]^ndx</script><p>由于 $\forall c\in(a,b)$，都有</p>
<script type="math/tex; mode=display">
\int_a^b[f(x)]^ndx\geqslant(b-c)f^n(c)</script><p>这一个不等式非常关键，它构建了定积分和被积函数之间的不等关系，我们可以使用变限函数将其证明出来，这里就不再进行证明了。</p>
<p>那么，这里取$c=b-\dfrac{\epsilon}{2}$ ，那么就得到 $f(b-\epsilon)^n&lt;f(c)^n$</p>
<p>于是</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty}\left[\frac{f(b-\epsilon)}{f(c)}\right]^n=0</script><p>所以 $\exists N$ ,对 $\forall n&gt;N$ 时，有</p>
<script type="math/tex; mode=display">
\left[\frac{f(b-\epsilon)}{f(c)}\right]^n <\frac{\epsilon}{2}=b-c</script><p>即</p>
<script type="math/tex; mode=display">
f^n(1-\epsilon)<f(c)^n(b-c)\leqslant\int_a^b[f(x)]^ndx=[f(x_n)]^n</script><p>所以就得到了$1-\epsilon &lt; x_n$</p>
<p>那么由极限定义就得到了</p>
<p>$\lim\limits_{n\rightarrow\infty}x_n=b$ </p>
<p>这一题的有两处难点</p>
<ol>
<li>找到极限值</li>
<li>找到函数与不定积分的不等关系</li>
</ol>
<hr>
<h2 id="极限-1"><a href="#极限-1" class="headerlink" title="极限"></a>极限</h2><p><strong>求和与积分</strong><br><strong>问题</strong><br>设</p>
<script type="math/tex; mode=display">
A_n=\frac{n}{n^2+1}+\frac{n}{n^2+2^2}+\cdots+\frac{n}{n^2+n^2}</script><p>求 $\lim\limits_{n\rightarrow\infty}n\left(\dfrac{\pi}{4}-A_n\right)$</p>
<hr>
<p><strong>分析</strong><br>首先很容易得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim\limits_{n\rightarrow\infty}A_n
&=\lim\limits_{n\rightarrow\infty}\frac1n\sum_{k=1}^n\frac{1}{1+(\frac {k}{n})^2}\\
&=\int_0^1\frac{1}{1+x^2}dx\\
&=\frac{\pi}{4}
\end{aligned}</script><p>将它转化为积分与和的形式</p>
<p>即</p>
<script type="math/tex; mode=display">
\frac{\pi}{4}=\sum_{i=1}^n\int_\frac{i-1}{n}^\frac{i}{n}\frac{1}{1+x^2}dx</script><script type="math/tex; mode=display">
A_n=\sum_{i=1}^n\int_\frac{i-1}{n}^\frac{i}{n}\frac{1}{1+(\frac{i}{n})^2}dx</script><p>所以说</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\lim\limits_{n\rightarrow\infty}n\left(\frac{\pi}{4}-A_n\right)\\
=&\lim\limits_{n\rightarrow\infty}n\left(\sum_{i=1}^n\int_\frac{i-1}{n}^\frac{i}{n}(\frac{1}{1+x^2}-\frac{1}{1+(\frac{i}{n})^2})dx\right)\\
=&\lim\limits_{n\rightarrow\infty}n\left(\sum_{i=1}^n\int_\frac{i-1}{n}^\frac{i}{n}(f(x)-f(\frac{i}{n})dx\right)\\
=&\lim\limits_{n\rightarrow\infty}n\left(\sum_{i=1}^n\int_\frac{i-1}{n}^\frac{i}{n}f'(\xi)(x-\frac{i}{n})dx\right)
\end{aligned}</script><p>这里没法直接用积分中值定理，需要用到介值定理，</p>
<p>因为 $f’(x)$在定义域上连续，则$m\leqslant f’(x)\leqslant M$</p>
<p>而</p>
<script type="math/tex; mode=display">
\begin{aligned}
&M\int_\frac{i-1}{n}^\frac{i}{n}(x-\frac{i}{n})dx\leqslant\int_\frac{i-1}{n}^\frac{i}{n}f'(\xi)(x-\frac{i}{n})dx\leqslant m\int_\frac{i-1}{n}^\frac{i}{n}(x-\frac{i}{n})dx\\
\Rightarrow&m\leqslant-2n^2\int_\frac{i-1}{n}^\frac{i}{n}f'(\xi)(x-\frac{i}{n})dx\leqslant M
\end{aligned}</script><p>所以存在 $f’(\eta)$，使得 $f’(\eta)$ $=-2n^2\displaystyle\int_\frac{i-1}{n}^\frac{i}{n}f’(\xi)(x-\frac{i}{n})dx$ 成立</p>
<p>其中 $\eta\in[x,\dfrac{i}{n}]$</p>
<p>那么就可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\lim\limits_{n\rightarrow\infty}n\left(\sum_{i=1}^n\int_\frac{i-1}{n}^\frac{i}{n}f'(\xi)(x-\frac{i}{n})dx\right)\\
=&\lim\limits_{n\rightarrow\infty}-\frac{1}{2n}\sum_{i=1}^nf'(\eta)\\
\end{aligned}</script><p>然后用夹逼定理就可以得到</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty}-\frac{1}{2n}\sum_{i=1}^nf'(\frac{i-1}{n})\leqslant\lim\limits_{n\rightarrow\infty}-\frac{1}{2n}\sum_{i=1}^nf'(\eta)\leqslant\lim\limits_{n\rightarrow\infty}-\frac{1}{2n}\sum_{i=1}^nf'(\frac{i}{n})</script><p>而</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim\limits_{n\rightarrow\infty}-\frac{1}{2n}\sum_{i=1}^nf'(\frac{i-1}{n})&=\lim\limits_{n\rightarrow\infty}-\frac{1}{2n}\sum_{i=1}^nf'(\frac{i}{n})\\
&=-\frac12\int_0^1f'(x)dx\\
&=-\frac12[\;f(1)-f(0)\;]\\
&=\frac14
\end{aligned}</script><p>这一题就是把它们转化成积分与求和的形式，但是里面的一些细节还是需要注意的，比如介值定理，夹逼定理的使用</p>
<h1 id="第七届"><a href="#第七届" class="headerlink" title="第七届"></a>第七届</h1><h2 id="反证"><a href="#反证" class="headerlink" title="反证"></a>反证</h2><p><strong>问题</strong></p>
<p>设函数 $f$ 在 $[0,1]$ 上连续，且 $\displaystyle\int_0^1f(x)dx=0$，$\displaystyle\int_0^1xf(x)dx=1$，试证：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(1)\;\exists\,x_0\in[0,1]，\text{使得}|f(x_0)|>4；\\
&(2)\;\exists \,x_1\in[0,1]，\text{使得}|f(x_1)|=4.
\end{aligned}</script><hr>
<p><strong>分析</strong></p>
<p>第一问要我们证明的是存在性问题，可以通过反证法，将其转化为恒成立问题</p>
<p>也就是证明对于 $\forall\;x_0\in[0,1]$，都有 $|f(x_0)|$ $\leqslant4$ 这个命题为假就行</p>
<p>我们令$F(x)=\displaystyle\int_0^xf(t)dt$</p>
<p>那么我们能得到 $F(1)=0$ </p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_0^1F(x)dx&=F(x)x\big|_0^1-\int_0^1xf(x)dx\\
&=0-1\\
&=-1
\end{aligned}</script><p>但是很显然这个第一问用不到</p>
<p><strong>我们可以用待定系数法凑出</strong></p>
<script type="math/tex; mode=display">
a=\int_0^1(ax+b)f(x)dx\leqslant\int_0^1|ax+b||f(x)|dx\leqslant4\int_0^1|ax+b|dx=a</script><p>使得两边相等</p>
<p>这样就可以让$\displaystyle\int_0^1|ax+b||f(x)|dx$ $=$ $4\displaystyle\int_0^1|ax+b|dx$ 恒成立</p>
<p>也就是说 $x\in[0,1]$时，$f(x)\equiv4$，这就与$\displaystyle\int_0^1f(x)dx=0$ 矛盾，那么就证出来了</p>
<p>要说明这两个相等，只要使得 $4\displaystyle\int_0^1|ax+b|dx=a$ 即可</p>
<p>也就是</p>
<script type="math/tex; mode=display">
4\int_0^1|x+\frac{b}{a}|dx=1</script><p>取一个特殊的情况，$\dfrac{b}{a}=-\dfrac12$，让 $a=1$，$b=-\dfrac12$即可</p>
<p>当然待定系数法的步骤在草稿纸上进行即可，我们只需要直接写出构造出的不等式</p>
<p>第二问其实就比较简单了，有了第一问的铺垫就可以得到有一点 $x_0$ 大于4，我们只要找到一个点$\xi$小于4，就可以用介值定理得到等于4的情况</p>
<p>这里我是多项式拟合进行构造</p>
<p>令$g(x)=F(x)-2x+2$</p>
<p>那么<br>$g(1)=0$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_0^1g(x)dx&=\int_0^1F(x)dx-\int_0^1(2x-2)dx\\
&=-1+1=0
\end{aligned}</script><p>因为g(x)在[0,1]上连续，由积分中值定理可以得到 </p>
<p>存在一点 $\xi\in(0,1)$ 使得 $g(\xi)$ $=$ $\displaystyle\int_0^1g(x)dx=0$ 成立</p>
<p>得到$g(1)=g(\xi)=0$</p>
<p>然后用罗尔定理就可以得到存在一点 $\eta$，使得 $g’(\eta)=0$</p>
<p>即 $|f(\eta)|=2$</p>
<p>而在区间[0,1]上又存在大于4的点，通过介值定理即可得到存在一点$x_0$，使得 $|f(x_0)|=4$ 成立</p>
<hr>
<h2 id="二元泰勒公式"><a href="#二元泰勒公式" class="headerlink" title="二元泰勒公式"></a>二元泰勒公式</h2><p><strong>问题</strong></p>
<p>设 $f(x,y)$ 在 $x^2+y^2\leqslant 1$ 上，有连续的二阶导数，$f_{xx}^2+2f_{xy}^2+f_{yy}^2$ $\leqslant$ $M$，若</p>
<script type="math/tex; mode=display">
f(0,0)=f_x(0,0)=f_y(0,0)=0</script><p>证明：</p>
<script type="math/tex; mode=display">
\left|\iint\limits_{x^2+y^2\leqslant 1}f(x,y)dxdy\right|\leqslant \frac{\pi\sqrt{M} }{4}.</script><hr>
<p><strong>分析</strong></p>
<p>很容易看出这一题得用到二元泰勒展开</p>
<p>将 $f(x,y)$ 在(0,0)处泰勒展开</p>
<script type="math/tex; mode=display">
\begin{aligned}
|f(x,y)|&=\left|f(0,0)+\left(x\frac{\partial}{\partial x}+y\frac{\partial}{\partial y}\right)f(0,0)+\frac12\left(x\frac{\partial}{\partial x}+y\frac{\partial}{\partial y}\right)^2f(0,0)\right|\\
&=\frac12\left(x\frac{\partial}{\partial x}+y\frac{\partial}{\partial y}\right)^2|f(\theta x,\theta y)|\\
&=\frac12\left|x^2\frac{\partial^2}{\partial x^2}+2xy\frac{\partial^2}{\partial x\partial y}+y^2\frac{\partial^2}{\partial y^2}\right||f(\theta x,\theta y)|
\end{aligned}</script><p>由柯西不等式可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\left|x^2\frac{\partial^2}{\partial x^2}+2xy\frac{\partial^2}{\partial x\partial y}+y^2\frac{\partial^2}{\partial y^2}\right|\\
\\
\leqslant&\sqrt{(x^2)^2+(\sqrt{2\,}xy)^2+(y^2)^2}\sqrt{\left(\frac{\partial^2}{\partial x^2}\right)^2+\left(\sqrt{2\,}\frac{\partial^2}{\partial x\partial y}\right)^2+\left(\frac{\partial^2}{\partial y^2}\right)^2}\\
\\
=&(x^2+y^2)\sqrt{\left(\frac{\partial^2}{\partial x^2}\right)^2+\left(\sqrt{2\,}\frac{\partial^2}{\partial x\partial y}\right)^2+\left(\frac{\partial^2}{\partial y^2}\right)^2}
\end{aligned}</script><p>又因为$f_{xx}^2+2f_{xy}^2+f_{yy}^2$ $\leqslant$ $M$</p>
<p>那么就得到了</p>
<script type="math/tex; mode=display">
|f(x,y)|\leqslant\frac{\sqrt{M} }{2}(x^2+y^2)</script><p>而</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left|\iint\limits_{x^2+y^2\leqslant 1}f(x,y)dxdy\right|&\leqslant\iint\limits_{x^2+y^2\leqslant 1}|f(x,y)|dxdy\\
&\leqslant\frac{\sqrt{M} }{2}\iint\limits_{x^2+y^2\leqslant 1}(x^2+y^2)dxdy\\
&=\frac{\sqrt{M} }{2}\int_0^{2\pi}d\theta\int_0^1r^3dr\\
&=\frac{\pi\sqrt{M} }{4} 
\end{aligned}</script><hr>
<h1 id="第八届"><a href="#第八届" class="headerlink" title="第八届"></a>第八届</h1><h2 id="双中值"><a href="#双中值" class="headerlink" title="双中值"></a>双中值</h2><p><strong>问题</strong><br>设函数 $f(x)$ 在区间 [0,1]上连续，且</p>
<script type="math/tex; mode=display">
I=\int_0^1f(x)dx\neq0.</script><p>证明：在 $(0,1)$内存在不同的两点$x_1,x_2$，使得</p>
<script type="math/tex; mode=display">
\frac{1}{f(x_1)}+\frac{1}{f(x_2)}=\frac{2}{I}</script><hr>
<p><strong>分析</strong></p>
<p>首先这一题，我们可以很容易看出这是一道双中值问题</p>
<p>那么我们就可以将区间拆成两份</p>
<script type="math/tex; mode=display">
I=\int_0^1f(x)dx=\int_0^cf(x)dx+\int_c^1f(x)dx</script><p>然后通过积分中值定理可以得到</p>
<script type="math/tex; mode=display">
\int_0^cf(x)dx=cf(x_1)</script><script type="math/tex; mode=display">
\int_c^1f(x)dx=(1-c)f(x_2)</script><p>也就是说</p>
<script type="math/tex; mode=display">
\frac{1}{f(x_1)}+\frac{1}{f(x_2)}=\frac{c}{\displaystyle\int_0^cf(x)dx}+\frac{1-c}{\displaystyle\int_c^1f(x)dx}=\frac{2}{I}</script><p>我们就需要找到一个c，使其能够满足$\displaystyle\int_0^cf(x)dx=$ $\dfrac{I}{2}$ 即可</p>
<p>可是这儿怎么找呢？</p>
<p>为了好表示，我们令 $F(x)=\displaystyle\int_0^xf(t)dt$</p>
<p>那么就可以得到 $F(0)=0$，$F(1)=I\neq0$</p>
<p>那么由介值定理我们就可以找到一点 $\xi$，使其满足c的条件</p>
<p>那么就证明出来了</p>
<hr>
<h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><p><strong>问题</strong></p>
<p>设 $f(x)$在$(-\infty,+\infty)$上可导，且</p>
<script type="math/tex; mode=display">
f(x)=f(x+2)=f(x+\sqrt{3}).</script><p>用傅里叶级数理论证明$f(x)$为常数。</p>
<hr>
<p><strong>分析</strong></p>
<p>傅里叶级数其实并不是太熟悉，这么多竞赛试题下来，就这么一道傅里叶级数的证明题，因此将它收录下来，也许不难，但是也能帮助我更好的运用</p>
<p>由题可得 $f(x)$的周期为 $\sqrt{3}$ 和 2</p>
<p>傅里叶系数为</p>
<script type="math/tex; mode=display">
a_n=\int_{-1}^1f(x)\cos n\pi xdx\\
b_n=\int_{-1}^1f(x)\sin n\pi xdx</script><p>再由 $f(x)=f(x+\sqrt{3})$ 可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
a_n&=\int_{-1}^1f(x)\cos n\pi xdx\\
&=\int_{-1}^1f(x+\sqrt{3})\cos n\pi xdx\\
&\xlongequal{t=x+\sqrt{3} }\int_{-1+\sqrt{3} }^{1+\sqrt{3} }f(t)\cos n\pi(t-\sqrt{3})dt\\
&=\int_{-1+\sqrt{3} }^{1+\sqrt{3} }f(t)[\;\cos n\pi t\cos\sqrt{3}n\pi +\sin n\pi t\sin\sqrt{3}n\pi \;]dt\\
&=\cos\sqrt{3}n\pi\int_{-1+\sqrt{3} }^{1+\sqrt{3} }\cos n\pi tdt+\sin\sqrt{3}n\pi\int_{-1+\sqrt{3} }^{1+\sqrt{3} }\sin n\pi tdt\\
&=\cos\sqrt{3}n\pi\int_{-1}^1\cos n\pi tdt+\sin\sqrt{3}n\pi\int_{-1}^1\sin n\pi tdt 
\end{aligned}</script><p>所以说 $a_n=a_n\cos\sqrt{3}n\pi+b_n\sin\sqrt{3}n\pi$</p>
<p>同理可得 $b_n=b_n\cos\sqrt{3}n\pi-a_n\sin\sqrt{3}n\pi$</p>
<p>联立方程就可以得到$a_n=b_n=0$ $(n=1,2\cdots)$</p>
<p>所以 $f(x)=\dfrac{a_0}{2}$</p>
<h1 id="第九届"><a href="#第九届" class="headerlink" title="第九届"></a>第九届</h1><h2 id="不等式（取二次积分）"><a href="#不等式（取二次积分）" class="headerlink" title="不等式（取二次积分）"></a>不等式（取二次积分）</h2><p><strong>问题</strong></p>
<p>设函数 $f(x)&gt;0$ 且在实轴上连续，若对任意实数t，有 $\displaystyle\int_{-\infty}^{+\infty}e^{-|t-x|}f(x)dx$ $\leqslant1$，证明：$\forall$ $a,b$，$a &lt; b$，有</p>
<script type="math/tex; mode=display">
\int_a^bf(x)dx\leqslant\frac{b-a+2}{2}</script><hr>
<p><strong>分析</strong></p>
<p>这一题我们会想到按t进行划分，从而达到去绝对值的目的，但是尝试之后发现很难继续下去了，这里我们肯定不能让积分区域从负无穷到正无穷，这就太宽泛了，因此取积分a-b，而这里运用的方法就非常巧妙</p>
<p>两边同时积分，转化成二次积分</p>
<script type="math/tex; mode=display">
\int_a^b\left[\int_a^be^{-|t-x|}f(x)dx\right]dt\leqslant\int_a^b1·dx=b-a</script><p>那么这里就可以先对t积，再对x积</p>
<script type="math/tex; mode=display">
\int_a^b\left[\int_a^be^{-|t-x|}f(x)dx\right]dt=\int_a^bf(x)dx\int_a^be^{-|t-x|}dt</script><p>这样的好处就是消去t这个烦人的量</p>
<p>而</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_a^be^{-|t-x|}dt&=\int_a^xe^{t-x}dt+\int_x^be^{x-t}dt\\
&=-[e^{t-x}]_a^x+[e^{x-t}]_x^b\\
&=2-e^{a-t}-e^{t-b}
\end{aligned}</script><p>这样就可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int_a^b(2-e^{a-t}-e^{t-b})f(x)dx\\
=\;&2\int_a^bf(x)dx-\int_a^be^{a-t}f(x)dx-\int_a^be^{t-b}f(x)dx\\
\leqslant\;&b-a\\
\\
\Rightarrow&\int_a^bf(x)dx\\
\leqslant\;&\frac{b-a}{2}+\frac12\left(\int_a^be^{a-t}f(x)dx+\int_a^be^{t-b}f(x)dx\right)\\
\leqslant\;&\frac{b-a}{2}+1
\end{aligned}</script><p>证毕</p>
<p>这一题的核心就是那个二次积分，将变量 t 先积出来，然后就能发现分离出 $\displaystyle\int_a^bf(x)$ 这个量了</p>
<h1 id="第十届"><a href="#第十届" class="headerlink" title="第十届"></a>第十届</h1><h2 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h2><p><strong>问题</strong>:</p>
<p>设 $f(x,y)$ 在区域 $D$ 内可微，且 $\sqrt{\left(\dfrac{\partial f}{\partial x}\right)^2+\left(\dfrac{\partial f}{\partial y}\right)^2 }\leqslant M$ ，$A(x_1,y_1)$，$B(x_2,y_2)$是 $D$ 内两点，线段$AB$ 包含在 $D$ 内，证明：$|f(x_1,y_1)-f(x_2,y_2)|$ $\leqslant$ $M|AB|$ ，其中$|AB|$表示线段$AB$的长度<br><br></p>
<hr>
<p><strong>分析</strong>：</p>
<p>拿到这一题，我们很容易明确目标，如何建立偏导数和函数之间的关系呢？很显然应该需要用到微分中值定理</p>
<p>首先我们先观察一下$M|AB|$，这里的 $|AB|$很好表示，也就是$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$，那么问题就可以转化成证明</p>
<script type="math/tex; mode=display">
|f(x_1,y_1)-f(x_2,y_2)|\leqslant\sqrt{\left(\dfrac{\partial f}{\partial x}\right)^2+\left(\dfrac{\partial f}{\partial y}\right)^2 }\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}</script><p>进一步进行转化，用柯西不等式可以得到</p>
<script type="math/tex; mode=display">
\sqrt{\left(\dfrac{\partial f}{\partial x}\right)^2+\left(\dfrac{\partial f}{\partial y}\right)^2 }\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}\geqslant \left[\frac{\partial f}{\partial x}(x_1-x_2)+\frac{\partial f}{\partial y}(y_1-y_2)\right]</script><p>OK,到这里我们的问题已经解决了大半，我们后面只要用到拉格朗日中值定理即可</p>
<p>不清楚这里竞赛的时候是否能用多元函数的拉格朗日中值定理（如果能用，那么秒出答案）</p>
<p>但为了 <strong>谨慎</strong> 这里用了另一种方法，其实就是多元函数微分中值定理的证明</p>
<p>构造辅助函数 </p>
<script type="math/tex; mode=display">\psi(\theta)=f(x_1+\theta(x_2-x_1),y_1+\theta(y_2-y_1))</script><p>由一元函数的拉格朗日中值定理得</p>
<script type="math/tex; mode=display">
\psi(1)-\psi(0)=\psi'(\xi)</script><p>也就是</p>
<script type="math/tex; mode=display">
f(x_2,y_2)-f(x_1,y_1)=f_1'(x_1-x_2)+f_2'(y_1-y_2)</script><p>那么问题也就解决了</p>
<hr>
<h2 id="积分定义"><a href="#积分定义" class="headerlink" title="积分定义"></a>积分定义</h2><p><strong>问题</strong>:</p>
<p>证明：对连续函数$f(x)&gt;0$，有 $\ln\displaystyle\int_0^1 f(x)dx\geqslant\int_0^1\ln f(x)dx$.</p>
<hr>
<p><strong>分析</strong>:</p>
<p>这一题我们拿到手中会很容易想到一种方法，构造辅助函数</p>
<script type="math/tex; mode=display">
\psi(x)=\ln\int_0^xf(t)dt-\int_0^x\ln f(t)dt</script><p>然后求导，研究单调性</p>
<p>但是坑就在这里，我们求导完发现</p>
<p>而这一题，我们可以巧妙地从积分的定义式入手</p>
<p>也就是 $\lim\limits_{\lambda\rightarrow 0}\sum\limits_{i=1}^nf(\xi_i)\Delta x_i$</p>
<p>因为$f(x)在（0,1）$上连续</p>
<p>所以</p>
<script type="math/tex; mode=display">
\ln\int_0^1f(x)dx=\lim\limits_{n\rightarrow ∞}\ln\frac1n\sum\limits_{i=1}^nf(x_i)，x_i\in[\frac{i-1}{n},\frac{i}{n}]</script><script type="math/tex; mode=display">
\begin{aligned}
\int_0^1\ln f(x)dx&=\lim\limits_{n\rightarrow ∞}\frac1n\sum\limits_{i=1}^n\ln f(x_i)，x_i\in[\frac{i-1}{n},\frac{i}{n}]\\
&=\lim\limits_{n\rightarrow ∞}\ln\left(\prod\limits_{i=1}^nf(x_i)\right)^{\dfrac1n}
\end{aligned}</script><p>而由均值不等式我们就可以得到</p>
<script type="math/tex; mode=display">
\frac1n\sum\limits_{i=1}^nf(x_i)\geqslant\left(\prod\limits_{i=1}^nf(x_i)\right)^{\dfrac1n}</script><p>然后两边取极限就证出来了</p>
<hr>
<h2 id="级数-2"><a href="#级数-2" class="headerlink" title="级数"></a>级数</h2><p><strong>问题</strong>：</p>
<p>已知 {$a_k$}，{$b_k$} 是正数数列，且$b_{k+1}-b_k\geqslant\delta&gt;0$，$k=1,2,\cdots$，$\delta$ 为一常数，证明：若级数 $\sum\limits_{k=1}^{+∞}a_k$ 收敛，则级数 $\sum\limits_{k=1}^{+∞}\dfrac{k\sqrt[k]{(a_1a_2\cdots a_k)(b_1b_2\cdots b_k)} }{b_{k+1}b_k}$ 收敛</p>
<hr>
<p><strong>分析</strong>：</p>
<p>这一题只需要我们判断是否收敛，那么我们会想到两种审敛法，一种是比较审敛法，一种是对数审敛法</p>
<p>如果利用比较审敛法，就必然需要用到一些不等式，而且也要充分利用 $\sum\limits_{k=1}^{+∞}a_k$收敛，和 <strong>递增正数</strong> 数列 { $b_j$ }</p>
<p>观察所要证明的级数，可以和根号联系起来的不等式，我们很容易想到均值不等式，</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^ka_i\geqslant k\left(\prod_{i=1}^ka_i\right)^{\dfrac{1}{k} }</script><p>我们发现所要证明的式子有个k，那么应该就不是写两个不等式，相乘，这样就会产生 $k^2$，就不容易处理了，那么不等式如何用才能只会产生 $k$ 呢？这里我们就可以把 $a_ib_i$看成整体</p>
<p>也就是</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^ka_ib_i\geqslant k\left(\prod_{i=1}^ka_ib_i\right)^{\dfrac{1}{k} }</script><p>此时问题就转换成证明级数$\sum\limits_{k=1}^∞\dfrac{\sum\limits_{i=1}^ka_ib_i}{b_kb_{k+1} }<br>$收敛，这样的形式肯定就比根号下要好证了，我们一看就能发现它是收敛的。</p>
<p>因为数列 { $b_k$ }是正项非递减数列，所以说 $\dfrac{b_i}{b_{k+1} }\leqslant1$，$i\in[1,k-1]$ 恒成立</p>
<p>那么</p>
<script type="math/tex; mode=display">
\frac{\sum\limits_{i=1}^ka_ib_i}{b_kb_{k+1} }=\sum\limits_{i=1}^{k-1}a_i\left(\frac{b_i}{b_{k+1} }\right)+a_k\leqslant\sum\limits_{i=1}^{k-1}a_i+a_k=\sum\limits_{i=1}^ka_i</script><p>又因为 $\sum\limits_{k=1}^{+∞}a_k$收敛</p>
<p>那么根据比较收敛法，所证级数收敛</p>
<h1 id="第十一届"><a href="#第十一届" class="headerlink" title="第十一届"></a>第十一届</h1><h2 id="函数归零"><a href="#函数归零" class="headerlink" title="函数归零"></a>函数归零</h2><p><strong>问题</strong><br>设 $f(x)$ 在 $[0,+\infty]$ 上可微，$f(0)=0$，且存在常数 $A&gt;0$，使得 $|f’(x)|\leqslant A|f(x)|$ 在 $[0,+\infty]$ 上成立，试证明在 $(0,+\infty)$ 上有 $f(x)$ $\equiv0$</p>
<hr>
<p><strong>分析</strong></p>
<p>这一题因为带绝对值，所以没法直接解微分方程，而观察其形式，如何让导数和函数挂钩呢，这样我们就会想到拉格朗日中值定理</p>
<p>由拉格朗日中值定理我们可以得到</p>
<script type="math/tex; mode=display">
f(x)=xf'(\xi)\quad\xi\in(0,x)</script><p>那么代入题目所给的不等式，可得</p>
<script type="math/tex; mode=display">
|f'(x)|\leqslant Ax|f'(\xi)|</script><p>这里可以限制x的取值范围在 $[0,\dfrac{1}{2A}]$</p>
<p>那么放缩可以得到</p>
<script type="math/tex; mode=display">
|f'(x)|\leqslant Ax|f'(\xi)|\leqslant \frac12|f'(\xi)|</script><p>这里假设$|f(x_0)|=\max\{|f(x)|\}$</p>
<script type="math/tex; mode=display">
|f(x_0)|=x_0|f'(\xi)|\leqslant \frac{1}{2A}|f'(\xi)|\leqslant\frac12|f(x_0)|</script><p>那么就得到了 $f(x)\equiv 0$ 其中 $x\in[0,\dfrac{1}{2A}]$</p>
<p>下面进行解析延拓</p>
<p>由于得到$f(\dfrac{1}{2A})=0$<br>那么就可以递推出在区间 $[\dfrac{1}{2A},\dfrac{2}{2A}]$ 上</p>
<p>$f(x)\equiv 0$也成立</p>
<p>一直递推可得到在所有 $x\in[\dfrac{i}{2A},\dfrac{i+1}{2A}]$ ( 其中 $i=0,1,2\cdots$ ) 上</p>
<p>$f(x)\equiv0$都成立</p>
<p>所以说$f(x)\equiv0$</p>
<hr>
<h2 id="积分转化（曲面积分）"><a href="#积分转化（曲面积分）" class="headerlink" title="积分转化（曲面积分）"></a>积分转化（曲面积分）</h2><p><strong>问题</strong><br>计算积分</p>
<script type="math/tex; mode=display">
I=\int_0^{2\pi}d\phi\int_0^\pi e^{\sin\theta(\cos\phi-\sin\phi)}\sin\theta d\theta</script><hr>
<p><strong>分析</strong></p>
<p>这道题的方法非常巧妙</p>
<p>首先我们很难直接入手这道题，交换积分次序也并不好求，这一题用到的方法是将其转化成第一类曲面积分的形式，为什么想到转化成第一类曲面积分呢？其实它可以通过通过几何意义转化成定积分的形式，这一点我们可以参照第三届的一道曲面积分的证明题。</p>
<p>当然这一题我们也很容易发现它形式的特殊性，进而联想到，球面的参数方程</p>
<p>因此我们令<br>$x=\sin\theta\cos\phi$，$y=\sin\theta\sin\phi$，$z=\cos\theta$</p>
<p>我们可以得到球面的面积微元</p>
<script type="math/tex; mode=display">
\begin{aligned}
dS&=\sqrt{1+f_x^2+f_y^2}dxdy\\
&=\sqrt{\frac{1}{z^2} }\;\frac{\partial(x,y)}{\partial(\theta.\phi)}\;d\theta d\phi\\
&=\sin\theta d\theta d\phi
\end{aligned}</script><p>那么原式就可以转化成</p>
<script type="math/tex; mode=display">
\iint\limits_{\Sigma}e^{x-y}dxdy</script><p>这里有这样一个结论</p>
<script type="math/tex; mode=display">
\iint\limits_{\Sigma}f(ax+by+cz)dS=2\pi\int_{-1}^1f(\sqrt{a^2+b^2+c^2}u)du</script><p>具体推导方法参照第三届曲面积分证明题</p>
<p>那么根据公式我们很容易得到</p>
<script type="math/tex; mode=display">
\iint\limits_{\Sigma}e^{x-y}=2\pi\int_{-1}^1e^{\sqrt{2}u}du=\sqrt{2}\pi(e^{\sqrt{2} }-e^{-\sqrt{2} })</script><hr>
<h2 id="极限-2"><a href="#极限-2" class="headerlink" title="极限"></a>极限</h2><p><strong>问题</strong></p>
<p>设 $f(x)$ 是仅有正实根的多项式函数，满足</p>
<script type="math/tex; mode=display">
\frac{f'(x)}{f(x)}=-\sum\limits_{n=0}^{+\infty}c_n x^n</script><p>证明：$c_n&gt;0$ $(n\geq0)$，极限 $\lim\limits_{n\rightarrow+\infty}\dfrac{1}{\sqrt[n]{c_n} }$存在，且等于 $f(x)$的最小根</p>
<hr>
<p><strong>分析</strong></p>
<p>注意到这里 $f(x)$ 是仅有正实根的多项式，这一点非常特殊，我们可以直接设出$f(x)$的形式</p>
<p>设</p>
<script type="math/tex; mode=display">
f(x)=A(x-a_1)^{k_1}(x-a_2)^{k_2}\cdots(x-a_m)^{k_m}</script><p>并且 $a_1,a_2,\cdots a_n$ 按从小到大排列</p>
<p>这样设的好处是可以表示重根的情况，且更具有一般性</p>
<p>首先由于 <strong>$f(x)$ 在分母</strong>，所以可以得到 $f(x)$的定义域为$x\neq a_1,\cdots a_n$</p>
<p>要时刻注意函数的定义域</p>
<p>我们就可以进行如下化简</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{f'(x)}{f(x)}&=\frac{d\ln|f(x)|}{dx}\\
&=(\ln|A|+k_1\ln|x-a_1|\cdots k_m\ln|x-a_m|)'\\
&=\frac{k_1}{x-a_1}+\frac{k_2}{x-a_2}+\cdots+\frac{k_m}{x-a_m}
\end{aligned}</script><p>那现在怎么样才能和右边建立等号，并且和 $c_n$建立联系呢？</p>
<p>其实我们可以发现右方的无穷级数其实就类似于 $\sum\limits_{n=0}^\infty x^n$ $=\dfrac{1}{1-x}$</p>
<p>在跟左面进行比较就可以变换其形式</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{f'(x)}{f(x)}&=-\left(\;\frac{k_1}{a_1}\;\frac{1}{1-\frac{x}{a_1} }+\frac{k_2}{a_2}\;\frac{1}{1-\frac{x}{a_2} }+\cdots+\frac{k_m}{a_m}\;\frac{1}{1-\frac{x}{a_m} }\;\right)\\
\\
&=-\left[\;\frac{k_1}{a_1}\;\sum\limits_{n=0}^\infty\left(\frac{x}{a_1}\right)^n+\frac{k_2}{a_2}\;\sum\limits_{n=0}^\infty\left(\frac{x}{a_2}\right)^n+\cdots+\frac{k_m}{a_m}\;\sum\limits_{n=0}^\infty\left(\frac{x}{a_m}\right)^n\;\right]\\
&=-\sum\limits_{n=0}^\infty(k_1a_1^{1-n}+k_2a_2^{1-n}+\cdots+k_ma_m^{1-n})x^n
\end{aligned}</script><p>所以就可以得到</p>
<script type="math/tex; mode=display">
c_n=k_1a_1^{1-n}+k_2a_2^{1-n}+\cdots+k_ma_m^{1-n}</script><p>题目要求的是 $\lim\limits_{n\rightarrow+\infty}\dfrac{1}{\sqrt[n]{c_n} }$ 这个极限</p>
<p>因为分数不太好研究，所以我们就来研究一下 $\lim\limits_{n\rightarrow+\infty}\sqrt[n]{c_n}$ 的值，然后取倒数即可</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim\limits_{n\rightarrow+\infty}\sqrt[n]{c_n}&=\lim\limits_{n\rightarrow+\infty}\exp(\,{\frac{\ln c_n}{n} }\,)\\
&=\lim\limits_{n\rightarrow+\infty}\exp[\,{\frac{\ln c_n-\ln c_{n-1} }{n-(n-1)} }\,]\\
&=\lim\limits_{n\rightarrow+\infty}\exp[\,\ln\frac{k_1a_1^{1-n}+k_2a_2^{1-n}+\cdots+k_ma_m^{1-n}}{k_1a_1^{2-n}+k_2a_2^{2-n}+\cdots+k_ma_m^{2-n}} \,]\\
&=\frac{1}{a_1}
\end{aligned}</script><p>这里面用了stolz定理，考试中用的话要在之前说明一下</p>
<p>当然，也可以转化为函数极限用洛必达。</p>
<p>那么就得到了 $\lim\limits_{n\rightarrow+\infty}\dfrac{1}{\sqrt[n]{c_n} }=a_1$</p>
<p>其中 $a_1$ 为 $f(x)$ 最小根</p>
<h1 id="第十二届"><a href="#第十二届" class="headerlink" title="第十二届"></a>第十二届</h1><h2 id="积分和求和"><a href="#积分和求和" class="headerlink" title="积分和求和"></a>积分和求和</h2><p><strong>问题</strong></p>
<p><strong>三角函数</strong><br><strong>取整函数的处理</strong></p>
<p>证明</p>
<script type="math/tex; mode=display">
f(n)=\sum\limits_{m=1}^n\int_0^m\cos\frac{2\pi n[x+1]}{m}dx</script><p>等于 n 的所有因子（包括1和n本身之和），其中$[x+1]$表示不超过 $x+1$ 的最大整数，并且计算 $f(2021)$</p>
<hr>
<p><strong>分析</strong></p>
<p>这里因为有取整函数，所以我们需要将积分区间进行拆分</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int_0^m\cos\frac{2\pi n[x+1]}{m}dx\\
=&\sum_{k=1}^m\int_{k-1}^k\cos\frac{2\pi nk}{m}dx\\
=&\sum_{k=1}^m\cos\frac{2\pi n}{m}k
\end{aligned}</script><p>首先先看 $\dfrac{2\pi n}{m}k$ </p>
<p>1.如果m是n的因子</p>
<p>那么就可以得到 $\dfrac{2\pi n}{m}k$ 是 $2\pi$ 的整数倍，即可得到 $\cos\dfrac{2\pi n}{m}k=1$</p>
<p>$<br>\therefore\;\displaystyle\int_0^m\cos\frac{2\pi n[x+1]}{m}dx=m<br>$</p>
<p>2.如果m不是n的因子</p>
<p>那么为了表达简便，令 $\dfrac{2\pi n}{m}=t$</p>
<p>即可得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int_0^m\cos\frac{2\pi n[x+1]}{m}dx\\
=&\sum_{k=1}^m\cos tk\\
=&\cos t+\cos 2t+\cdots+\cos mt
\end{aligned}</script><p>那么怎么化简 $\cos t+\cos 2t+\cdots+\cos mt$ 呢？</p>
<ul>
<li>方法一<br><strong>积化和差</strong></li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
&\cos t+\cos 2t+\cdots+\cos mt\\
=&\frac{(\cos t+\cos 2t+\cdots+\cos mt)\sin t}{\sin t}\\
=&\frac{(\sin 2t-\sin 0)+(\sin3t-\sin t)+(\sin 4t-\sin 2t)+\cdots+[\sin (m+1)t-\sin (m-1)t]}{2\sin t}\\
=&\frac{\sin(m+1)t+\sin mt-\sin t}{2\sin t}\\
=&\frac{\sin mt\cos t+\sin t\cos mt+\sin mt-\sin t}{2\sin t}\\
\xlongequal{t=\frac{2\pi n}{m} }&\frac{\sin m\frac{2\pi n}{m}\cos \frac{2\pi n}{m}+\sin \frac{2\pi n}{m}\cos m\frac{2\pi n}{m}+\sin m\frac{2\pi n}{m}-\sin \frac{2\pi n}{m} }{2\sin \frac{2\pi n}{m} }\\
=&0
\end{aligned}</script><ul>
<li>方法二<br><strong>欧拉公式</strong></li>
</ul>
<p>利用 $e^{ix}=\cos x+i\sin x$</p>
<p>可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
e^{it}+e^{2it}+\cdots+e^{mit}&=(\cos t+\cos2t+\cdots+\cos mt)+i(\sin t+\sin2t+\cdots+\sin mt)\\
&=\frac{e^{it}(1-e^{mit})}{1-e^{it} }
\end{aligned}</script><p>又因为 $1-e^{it}=1-\cos x-i\sin x$</p>
<p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
&[(\cos t+\cos2t+\cdots+\cos mt)+i(\sin t+\sin2t+\cdots+\sin mt)](1-\cos x-i\sin x)\\
=&e^{it}(1-e^{mit})\\
=&(\cos t+i\sin t)(1-\cos mt-i\sin mt)
\end{aligned}</script><p>然后实部虚部进行比对解方程得到</p>
<p>不过还是推荐 <strong>第一种方法</strong></p>
<p>这里面我们就得到了如果m不是n的因子，那么$f(n)=0$</p>
<p>那么也就是说不是其因子的数都是零，使其因子的数其值就等于因子本身</p>
<p>所以也就证明出来了</p>
<p>下面又让我们求 $f(2021)$的值</p>
<p>这就比较无聊了，我们需要找出它的因子：1,43,47,2021</p>
<p>所以说 f(2021)=1+41+47+2021=2112</p>
<p>这题其实就是套了一个积分的壳子，本质其实是三角函数的一些运算</p>
<hr>
<h2 id="级数-3"><a href="#级数-3" class="headerlink" title="级数"></a>级数</h2><p><strong>数列极限</strong></p>
<p><strong>问题</strong></p>
<p>设</p>
<script type="math/tex; mode=display">
u_n=\int_0^1\frac{dt}{\left(1+t^4\right)^n}\quad(n\geqslant 1)</script><p>(1) 证明数列 {$u_n$} 收敛，并求极限 $\lim\limits_{n\rightarrow\infty}u_n$</p>
<p>(2) 证明级数 $\sum\limits_{n=1}^\infty(-1)^nu_n$ 条件收敛</p>
<p>(3) 证明当 $p\geqslant 1$ 时，级数 $\sum\limits_{n=1}^\infty \dfrac{u_n}{n^p}$收敛，并求级数 $\sum\limits_{n=1}^\infty\dfrac{u_n}{n}$ 的和</p>
<p>第一小问并不难，因为我们可以很容易发现它的极限应该是趋向于0的，所亦可以用极限定义来解决</p>
<p>$\forall \epsilon&gt;0$</p>
<script type="math/tex; mode=display">
\begin{aligned}
u_n=\int_0^1\frac{dt}{(1+t^4)^n}
&=\int_0^{\frac{\epsilon}{2} }\frac{dt}{(1+t^4)^n}+\int_{\frac{\epsilon}{2} }^1\frac{dt}{(1+t^4)^n}\\
&\leqslant\frac{\epsilon}{2}+\int_{\frac{\epsilon}{2} }^1\frac{dt}{[1+(\frac{\epsilon}{2})^4]^n}\\
&\leqslant\frac{\epsilon}{2}+\frac{1-\dfrac{\epsilon}{2} }{[1+(\frac{\epsilon}{2})^4]^n}
\end{aligned}</script><p>对于 $\exists N\in N^*$ ，当 $x&gt;N$ 时，有</p>
<script type="math/tex; mode=display">
\frac{1-\dfrac{\epsilon}{2} }{[1+(\frac{\epsilon}{2})^4]^n}<\frac{\epsilon}{2}</script><p>即 $u_n&lt;\epsilon$</p>
<p>所以说就得到了 $\lim\limits_{n\rightarrow\infty}u_n=0$</p>
<p>第二问</p>
<p>首先说明它单调递减，很简单就不写了，然后再又因为 $\lim\limits_{n\rightarrow \infty} u_n=0$</p>
<p>所以现在只要证明 $\sum\limits_{n=0}^\infty u_n$ 发散就行</p>
<p>像这种题目一般都是用比较审敛法</p>
<p>这一题也很容得到放缩方法</p>
<script type="math/tex; mode=display">
u_n=\int_0^1\frac{dt}{(1+t^4)^n}\geqslant \int_0^1\frac{dt}{(1+t)^n}=\frac{1}{n-1}(1-2^{1-n})</script><p>$\sum\limits_{n=2}^\infty\dfrac{1}{n-1}$ 发散，而级数$\sum\limits_{n=2}^\infty\dfrac{1-2^{1-n}}{n-1}$ 收敛，（可以用比值审敛法得出）</p>
<p>那么就得到了 $\sum\limits_{n=2}^\infty\dfrac{1}{n-1}(1-2^{1-n})$ 发散</p>
<p>所以说原级数条件收敛</p>
<p>第三问</p>
<p>这里只需要考虑p=1时是否收敛就行，当p&gt;1时，可以用比较审敛法得出.</p>
<p>注意到这一题后面还有求级数的和，那么就不能简单的放缩了，得具体一点。</p>
<script type="math/tex; mode=display">
\begin{aligned}
u_n&=\int_0^1\frac{dt}{(1+t^4)^n}\\
&=\int_0^1(1+t^4)^{1-n}dt-\frac14\int_0^1\frac{t}{(1+t^4)^n}d(t^4+1)\\
&=\int_0^1(1+t^4)^{1-n}dt+\frac{1}{4(n-1)}\int_0^1t\;d(t^4+1)^{1-n}\\
&=\int_0^1(1+t^4)^{1-n}dt+\frac{1}{4(n-1)}\left[t(t^4+1)^{1-n}\bigg|_0^1-\int_0^1(1+t^4)^{1-n}dt\right]\\
&=u_{n-1}+\frac{1}{4(n-1)}[2^{1-n}-u_{n-1}]
\end{aligned}</script><p>不过这样似乎很难看出有什么递推关系，因为这种题最好能出现两数之差的形式，这样可以有利于求和</p>
<p>稍微整理一下</p>
<script type="math/tex; mode=display">
\begin{aligned}
&u_{n-1}=4(n-1)(u_{n-1}-u_n)+2^{1-n}\\
\Rightarrow&u_n=4n(u_n-u_{n+1})+2^{-n}
\end{aligned}</script><p>所以说</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum\limits_{n=1}^\infty\frac{u_n}{n}&=\sum\limits_{n=1}^\infty\frac{1}{ n\;2^{n} }+4\sum\limits_{n=1}^\infty(u_n-u_{n+1})\\
&=\sum\limits_{n=1}^\infty\frac{1}{ n\;2^{n} }+4u_1
\end{aligned}</script><p>那么下面只要求出 $\sum\limits_{n=1}^\infty\dfrac{1}{ n\;2^{n} }$ 即可</p>
<p>易知</p>
<script type="math/tex; mode=display">
\int\frac{1}{1-x}dx=-\ln(1-x)=\sum\limits_{n=0}^\infty\frac{1}{n+1}x^{n+1}</script><p>所以说</p>
<script type="math/tex; mode=display">
\sum\limits_{n=1}^\infty\frac{1}{ n\;2^{n} }=-\ln\frac12=\ln2</script><p>所以说级数 $\sum\limits_{n=1}^\infty \dfrac{u_n}{n^p}$</p>
<p>且它的和为 $\ln2+4u_1$</p>
<p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
u_1&=\int_0^1\frac{1}{1+t^4}dt\\
&=\frac12\left[\int_0^1\frac{1+t^2}{1+t^4}dt+\int_0^1\frac{1-t^2}{1+t^4}dt\right]\\
&=\frac12\left[\int_0^1\frac{d(t-\frac1t)}{(t-\frac1t)^2+2}-\int_0^1\frac{d(t+\frac1t)}{(t+\frac1t)^2-2}\right]\\
&=\frac{\sqrt{2} }{4}\left[\arctan \frac{\sqrt{2} }{2}(t-\frac1t)-\frac12\ln\frac{(t+\frac{1}{t})-\sqrt{2} }{(t+\frac1t)+\sqrt{2} }\right]_0^1\\
&=\frac{\sqrt{2} }{8}[\;\pi+2\ln(1+\sqrt{2})\;]
\end{aligned}</script>]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>曲线曲面积分</title>
    <url>/2021/08/14/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>曲线曲面积分理解起来并不是很难，主要是计算挺复杂，第一类曲线曲面积分，知道弧微分，二重积分求面积时的面积元素，也就是积分区域与投影区域的倍数关系就可以了，而第二类曲线曲面积分就是将有向曲线沿x,y进行分解，然后再进行求解。当然求解第二类曲线曲面有时候需要一些工具，也就是下面所介绍的三个公式，也是我认为曲线曲面积分中最有意思的地方，后面也会引入 $\nabla$ 算子（就是梯度符号），方便书写记忆</p>
<h1 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h1><blockquote>
<p>格林公式描述了第二种曲线积分（向量的形式），和二重积分的一种关系</p>
</blockquote>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><ul>
<li>1<br>$<br>\nabla\times \vec{F} (x,y)·d\vec{s}$<br><br>$=\left(\displaystyle\frac{\partial}{\partial x}\;\vec{i}+\displaystyle\frac{\partial}{\partial y}\;\vec{j}\right)\times[P(x,y)\;\vec{i}+Q(x,y)\;\vec{j}]·d\vec{s}$<br><br>$=(\displaystyle\frac{\partial}{\partial x}\;\vec{i}\times P(x,y)\;\vec{i}+\displaystyle\frac{\partial}{\partial y}\;\vec{j}\times Q(x,y)\;\vec{j}+\displaystyle\frac{\partial}{\partial y}\;\vec{j}\times P(x,y)\;\vec{i}+\displaystyle\frac{\partial}{\partial x}\;\vec{i}\times Q(x,y)\;\vec{j})·d\vec{s}$<br><br>$=\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y} \right)\;\vec{k}·d\vec{s}$<br><br>$=\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y} \right)dxdy<br>$</li>
</ul>
<span id="more"></span>
<script type="math/tex; mode=display">
\therefore\iint\limits_D\nabla\times \vec{F} (x,y)·d\vec{s}=\oint\limits_LPdx+Qdy=\iint\limits_D\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y} \right)dxdy</script><p>2</p>
<p>当然理解的时候可以站在几何的角度，一个 <strong>有向</strong> 闭合曲线内部可以分成无数个小的 <strong>有向</strong> 闭合曲线，并且部分有向边界可以 <strong>相互抵消</strong>（方向相反的线）</p>
<p><img style="transform:scale(0.7)" src="/2021/08/14/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/g1.png"></p>
<p>将这些正方形无限缩小成一个点，也就是曲面内所有“有向点”的积分之和，与这个曲线的积分相等S</p>
<p>那么每一点的关系又是怎么得来的呢？</p>
<p>取一块微分矩形，<br><img style="transform:scale(0.5)" src="/2021/08/14/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/g2.png"></p>
<p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\oint\limits_L
&=\int\limits_{L1}+\int\limits_{L2}+\int\limits_{L3}+\int\limits_{L4}\\
&=\int_{a_1}^{a_2}P(x,b_1)dx+\int_{b_1}^{b_4}Q(a_2,y)dy\\
&\quad+\int_{a_2}^{a_1}P(x,b_3)dx+\int_{b_4}^{b_1}Q(a_1,y)dy\\
&=\int_{a_1}^{a_2}P(x,b_1)-P(x,b_4)dx+\int_{b_1}^{b_4}Q(a_2,y)-Q(a_1,y)dy\\
&=\int_{a_1}^{a_2}\int_{b_4}^{b_1}\displaystyle\frac{\partial P}{\partial y}dxdy+\int_{b_1}^{b_4}\int_{a_1}^{a_2} \displaystyle\frac{\partial Q}{\partial x}dxdy\\
&=\int_{a_1}^{a_2}\int_{b_4}^{b_1}\displaystyle\frac{\partial P}{\partial y}-\displaystyle\frac{\partial Q}{\partial x}dxdy\\
&=\iint\limits_D\displaystyle\frac{\partial P}{\partial y}-\displaystyle\frac{\partial Q}{\partial x}dxdy
\end{aligned}</script><p>这就是一点处的关系，然后进行累加就得到了格林公式</p>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p><strong>1、平面上曲线积分与路径无关的条件</strong><br>设函数$P(x,y)、Q(x,y)$在平面单连通区域$\;D\;$内具有 <strong>连续的一阶偏导数</strong>，则下面四个命题 <strong>等价</strong></p>
<ul>
<li><p>命题一：曲线$\;L\;(\overset{\frown}{AB})$是$D$内由点A到点B的一段有向曲线，则曲线积分</p>
<script type="math/tex; mode=display">\int_L Pdx+Qdx</script><p>与路径无关，只与起点A和中点B有关</p>
</li>
<li><p>命题二：在区域$\;D\;$内任意一条闭曲线 L 的曲线积分有</p>
<script type="math/tex; mode=display">\oint_L Pdx+Qdy=0</script></li>
<li><p>命题三：在区域$\;D\;$内任意一点(x,y)处于</p>
<script type="math/tex; mode=display">\displaystyle\frac{\partial Q}{\partial x}=\displaystyle\frac{\partial P}{\partial y}</script></li>
<li><p>命题四：在$\;D\;$内存在函数 $u(x,y)$，使得 $Pdx+Qdy$是该二元函数 $u(x,y)$ 的全微分，即</p>
<script type="math/tex; mode=display">du=Pdx+Qdy</script></li>
</ul>
<p><strong>2、已知全微分求原函数</strong><br>如果函数$P(x,y)$、$Q(x,y)$在单连通区域$\;D\;$内具有 <strong>连续的一阶偏导数</strong>，<strong>且$\displaystyle\frac{\partial Q}{\partial x}=\displaystyle\frac{\partial P}{\partial y}$</strong>，则 $Pdx+Qdy$ 是某个函数$u(x,y)$的全微分，且有</p>
<script type="math/tex; mode=display">u(x,y)=\int_{(x_0,y_0)}^{(x,y)}Pdx+Qdy</script><p>其中$(x_0,y_0)$是区域 $D$ 内的某一定点，$(x,y)$是 $D$ 内的任一点</p>
<h1 id="高斯公式"><a href="#高斯公式" class="headerlink" title="高斯公式"></a>高斯公式</h1><blockquote>
<p>高斯公式描述了第二种曲面积分（向量的形式），和三重积分的一种关系</p>
</blockquote>
<p>高斯公式就像是格林公式升一维后的产物，所以这里直接给出公式</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">
\iint\limits_{\Sigma}Pdxdy+Qdxydy+Rdxdy=\iiint\limits_{\Omega}\left(\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}\right)dxdydz</script><p>或</p>
<script type="math/tex; mode=display">\iint\limits_{\Sigma}(P\cos\alpha+Q\cos\beta+R\cos\gamma)dS=\iiint\limits_{\Omega}\left(\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}\right)dxdydz</script><p>这里二重积分表示的都是 <strong>闭合曲面</strong>，mathjax似乎不支持闭合二重积分符号</p>
<p>这个证明跟前面证明格林公式基本一致</p>
<h2 id="通量与散度"><a href="#通量与散度" class="headerlink" title="通量与散度"></a>通量与散度</h2><p><strong>1、通量</strong><br>设向量场</p>
<script type="math/tex; mode=display">\vec{A}(x,y,z)=P(x,y,z)\;\vec{i}+Q(x,y,z)\;\vec{j}+R(x,y,z)\;\vec{k}</script><p>其中P、Q、R具有连续的一阶偏导数，&sum; 是场内的一个有向曲面，则称</p>
<script type="math/tex; mode=display">\Phi=\iint\limits_{\Sigma}\vec{A}·d\vec{S}=\iint\limits_{\Sigma}Pdydz+Qdzdx+Rdxdy</script><p>为向量场 $\vec{A}$ 通过曲面 &sum;的 <strong>通量（或流量）</strong></p>
<p><strong>2、散度</strong>：运算的对像是向量,运算出来的结果会是标量<br>$<br>\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}<br>$<br>称为向量场 $\vec{A}$ 的 <strong>散度</strong>，记作div$\vec{A}$，即</p>
<script type="math/tex; mode=display">\text{div}\vec{A}=\displaystyle\frac{\partial P}{\partial x}+\displaystyle\frac{\partial Q}{\partial y}+\displaystyle\frac{\partial R}{\partial z}</script><p>所以高斯公式也可简写成</p>
<script type="math/tex; mode=display">\iint\limits_{\Sigma}\vec{A} · d\vec{S}=\iiint\limits_{\Omega}\text{div}\vec{A}dV</script><h1 id="斯托克斯公式"><a href="#斯托克斯公式" class="headerlink" title="斯托克斯公式"></a>斯托克斯公式</h1><blockquote>
<p>斯托克斯公式就是格林公式的推广，其一般情况是应用在三维空间中的曲线和二重积分的一种关系，当然有时也可以进一步利用高斯公式将二重积分进一步转化为三重积分。</p>
</blockquote>
<h2 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">
\oint_L Pdx+Qdy+Rdz=\iint\limits_{\Sigma}
\begin{vmatrix}
dydz&dzdx&dxdy\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}
=\iint\limits_{\Sigma}
\begin{vmatrix}
\cos\alpha&\cos\beta&\cos\gamma\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}</script><p>这个证明跟前面证明格林公式基本一致</p>
<p>$\nabla\times \vec{F} (x,y,z)·d\vec{s}$，将这个混合积用行列式书写也就是公式中的这玩意</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
dydz&dzdx&dxdy\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}</script><p>当然上面的格林公式其实也可以写成这种行列式的形式</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
0&0&dxdy\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
0\\
\\
P&Q&0
\end{vmatrix}</script><p>所以为什么说斯托克斯公式其实就是格林公式的推广</p>
<h2 id="环流量与旋度"><a href="#环流量与旋度" class="headerlink" title="环流量与旋度"></a>环流量与旋度</h2><p><strong>1、环流量</strong><br>设向量场</p>
<script type="math/tex; mode=display">\vec{A}(x,y,z)=P(x,y,z)\;\vec{i}+Q(x,y,z)\;\vec{j}+R(x,y,z)\;\vec{k}</script><p>L是场内的一条有向闭曲线，则称</p>
<script type="math/tex; mode=display">\Gamma=\oint_L\vec{A} · d\vec{S}=\oint_L Pdx+Qdy+Rdz</script><p>为向量场 $\vec{A}$ 沿曲线L的 <strong>环流量</strong>，</p>
<p><strong>2、旋度</strong>：运算的对像是向量,运算出来的结果会是向量</p>
<script type="math/tex; mode=display">
\left(\displaystyle\frac{\partial R}{\partial y}-\displaystyle\frac{\partial Q}{\partial z}\right)\vec{i}+\left(\displaystyle\frac{\partial P}{\partial z}-\displaystyle\frac{\partial R}{\partial x}\right)\vec{j}+\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y}\right)\vec{k}</script><p>称为向量 $\vec{A}$ 的 <strong>旋度</strong>，记作rot$\vec{A}$，即</p>
<script type="math/tex; mode=display">
\text{rot} \vec{A}=
\begin{vmatrix}
\vec{i}&\vec{j}&\vec{k}\\
\\
\displaystyle\frac{\partial}{\partial x}&
\displaystyle\frac{\partial}{\partial y}&
\displaystyle\frac{\partial}{\partial z}\\
\\
P&Q&R
\end{vmatrix}
=\left(\displaystyle\frac{\partial R}{\partial y}-\displaystyle\frac{\partial Q}{\partial z}\right)\vec{i}+\left(\displaystyle\frac{\partial P}{\partial z}-\displaystyle\frac{\partial R}{\partial x}\right)\vec{j}+\left(\displaystyle\frac{\partial Q}{\partial x}-\displaystyle\frac{\partial P}{\partial y}\right)\vec{k}</script><p>所以斯托克斯公式可简写成</p>
<script type="math/tex; mode=display">
\oint_L \vec{A}·d\vec{r}=\iint\limits_{\Sigma}\text{rot}\vec{A}·d\vec{S}</script><p>其中<br>$d\vec{r}=dx\vec{i}+dy\vec{j}+dz\vec{k}$<br>$d\vec{S}=dydz\vec{i}+dzdx\vec{j}+dxdy\vec{k}$</p>
]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/09/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正则表达式可以说应用非常广泛，而且非常方便使用，而且很多编程语言都支持正则表达式的使用，但是记忆起来确实有些麻烦，所以在这里整理一下，也算帮助自己进行巩固。</p>
]]></content>
      <tags>
        <tag>常识</tag>
      </tags>
  </entry>
  <entry>
    <title>竞赛总结</title>
    <url>/2021/09/06/%E7%AB%9E%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="82857ad8fff5a7c82a07b874dd486dc413a2e68095b2344429a3363def25d4ec">a6b5137951dad53d15c33a27274ad48a800eac88c8b81e2c37b4b9e2f75bf7e5206f84c930f14cbe5e1a146c30a08539e66c9de5d6cbeb363c1fe257573828ceceefd39098921c7eb783e398150598166c1f870c0144299919d9d31e7aba9d590822af6b9304a0d15bc05b9344febabfd4014649454c7b83ec3b03da6e9a24ab502d364e730ddd482bc70bbf4294bf92519ef0b0282768f640b2e8c27f4b6ae31b7917722f9fd6352d22cc82faa2655881bc48d77e4e69ec182466d9fb24866f0260552c8f70b60c7593c3ed13f1c494ced9da8e6651a9e53994925219ac7f9713bc8b9f544930c388c55b5178935ba2dbfcb92f267aababdc1cfab8006461f5705c5d98e61f47294ba8b8eced88b3d7b7d611da252ad924e84b7cf70218d475a728dd21cd0819a73f6f431138bc3904e47c395fabd21a8e276e07b361656b183367dafd5b9b21ada308298938f3a5fcce7b8215929eeb04cf9f0913613c0d01fba1f369935eb9ac0d5eac5f3846c35d3207753319e0d82cad08919dd0024b05c70f8283ece8bcbd3fb4dacacf8a7b78e004ec94a4dbac712afa723adc704d32de38467b3c024e9aec7f120ac344a47fba170d5094c9adf8ec7cd98514c15b2cf6d4b2c9eb924a8577c2759333c419097f7350e1cedd41d2b49ec5d5a77880f04e71b5bd0a0aea5085e44ba0dc0045047dc636916ee8c51ec7e5cf86ab973bca198bbd89b8b652ed3e78dd041e5106a46523260298c8bc23e1ca4433089645d74b4b114d03f51278a6e6636405381e2efb275c3ffe77aa55ae6add8ea9dbab9c3f0ca23039021375eec7bc683e1b5f2e548a60add81d3a6a07f2f4e81ac794d1d65712487506dae1389fc372047e77aa7962bcf11dd6c6fbdb8a15c6326450372ef61a67d2b37faa303373b2de527a7df96faca3032f9c6bd83592fda17a6a84f106147d0f058b9d14a632331bbf517e51b7b9c0733dd52e525bb70017d755eb4b3283ab23c82d9ce5ee3cf197f66aceac325888dcbf7eae9c6d43fb1d9c01ed6727a04f147324f30dbef2bf817e38e6d08623ea3ddf77c842f74dc677cca28ccf8adb9544d06065c89d7a74ef41bb40708ec7cb5514774ed815d24daae79e91289ae757a0df0546a67d1678f201ab62325ea5ee01fc79549f05665bf54d386320450f26c1bb620fcc01047cf1ad045b0698a7800b1d5577e8ed1b94a17b27cdd71434c92df7486765b73ac2716014b6740ea7bc38919e7f1bd86ec1783c78204a242a58ea9b1cedf8206a4fca54584da42c369dd4b8a2153441868a71648aaa9c087a970ca576a041084ad5013c9596d1f467c76acbd7804b46c1935fc3d556b2ad6e234ea75ec775c44e29cb280cad096d008fe85fa3e80661a38f9e5d44af10c0af68bd686a90b932847f60277204a8315cf16638e74df8fc0b4262c6ce69e1b0aeb824b976cb95b6b6dbdd9c7dce47f4df4e2969a585a8ec4c41434a3d04ccef592617f658fae41ea64794e4052656b0bed8fb2fe742e02e09929efc1a80919a58696d5ca373b69a49bff18fab279d75d589d5361472bdad08f1175d091f69289c9c593ad69f2bcb85e737986faeca4820acacc54789d802afca231eeb1314a836a64317122d42fa31a5fa5f8b9f4e9dd91a409c8f58045d989d31730de49cb420169c481b36c7de04dfa237b2c65c89be792e8d7a198684f2711759e9767de43bedc77da9db773bf76bb221f54575c9a1ece6f3414ab6ec848ca4ececc8245e9f4da8f68aa3a2f1023f27beb84f53727b285cb10dd739ceaffccd8c3f36d4d78925743affc25dfb93fc4a7e1e7a18f90fed7efafdd618b7a3f41a53e184f53d80e0d8a1ec4a83a7f38a5f211e2e1c2afccb40686275306c9142aea2006accd82bacd9e4b0f08459fe5c08ea5a6ed88c6e9074f8fa44ba5ae4a29110d4d1d9f2ffeb7c4dac9e74d586ee8ac677fd16a3633f432fd71ac6df69486400ab7f595aa42fbaffa78420cc7065965136750fb3f540919dda1099477b306376546ae0ab12a53010b13aed9854b890aa8922805d550e2269303e20f65d08cb2eeb49c3d5770a0a1fbdb41ac14de73fb30cf5378bf4dd50f698e54dcd8f972f10ce175a6c198081c69a1333d480ecd2b3615a46669206e1bb69df1019045d45b539cbed28c843aa2861e9b7915c24fc1e33e8f0ec1ca59ea3a0b053826881aa2d616d2692a64f05737e5c0959fd76cf0e418e5573c31d20eae2491cc935a0147cfebecb29b520ff9881ad4a17f048282cd0f8a9706299d0c0a117d62f3bacfb77184911b372082e535c91af1364e13158810b970ffe4e868557ba5ca73489c1939d27f932dbea7b9180c3aacd1dccb17d1d19df7c8555b06d1c31bfe3522abbb9ec00dfad0ed4f1e5a7652316a39d4686dbefc1bd89f80af9fe4af8fb5d12d1b8d0d094da461d52597c174620e68dfb63ae56b3252352f8d7047af48f22aec34e2863980a2e21dba0a6b9cd27dbe88f9d3d8321680c364607a0e61e7f32c89a22a0a75a509f0563218508e69c120debe6a002d72208e9907371a007426157f48c37e17c5fa45e360cab29804fac0cc0aac53d0ae8a7f698f56923a2be08e38e3bbbe9bbff0945218991cc341fc083008d74e3bfcf321e4fa04fc965845b903bfb9fa8bbadecc6f2fa59e53be0a833fba14ece11f7e1069137dc6d6107974cd832f31c9d6ab058d5f48e7b2fd5f43bac5a75e0fbaed0bcd44ea40daccf59fd8623dc451116f1efad24ff2633981674b8084afe3ed9b02d94eebc5603c986cbe8c45fd3c1bffe36590df78bd96015554b6c508a35e6704c6c415eda526bfa30acdfd7a6e30bc481aca930baeef902c904eb499ef526691643fe0a105e348564dad7aeeb1fb4ab0f0495b7e9246976032c1bf4c2de2de9c2d7602f888c714109120f2f47a0da5f55a2832d7f06df55cb15b4bab4f6e4917b70b9bbbe6980e95035f8e2dc250c687a0c31562bc70d0e8ca9e4412e9a5459d4d2cb8abae50144ac12dd3f07532aed702c3bd66f1840cd396a4f8d12384c13cd400a15f19f8651ce19b2e4c7cb6dbb77c52fc05376e6aa755f776448d88d229f3a37bb6f90b7a7ca23f266312700960a6fd6fed9826455a30fb6aa1cfcf56a80ff4345d5d59755be9747a91519e158d3390c3e2b1a29278514766df5b55475258cfb33cd8c31740a553043a6bef1436c7e25d6869b7455d07da3429117de4133d620424ac35270fdc3461c7d1343e489e89dc19d73b227c0c76a960b509b9d622142a7cfb694767292fcb17ceae1d4e410689a032765651de147035036a805f6620bf853edf9b26413c98841981668dfedc0c13794fbecd68329d67e4bb70bceaeea5eee5125eccecaff56f6c43ed6973e3870fbb8ecb48ea94ac1e1b251fd4b535d2b7964b9e41082ae49307eb27a634db046554cc3ec38876e6cf50fb47a69ae835eb07d060ee2210c83cede6b730c974ad7376d0036b837c404bc94a6de86961566e9539a07efdde1e4cfa1baf72ce3e5807031b49ce214665a812f4a847e6bb2d8b65d6a5bff69516a75d94a14e6bb39aa2aaa13091ae6af837ab17c89b966b7e53a73ca313b1c940052afbbd8b9b8d889f94eef57c9098ec4f38fde08dfbcf645893598ba2be9f86d4bc79e7397d8420e5d1a2d08fc041088b48bcd07d5eaa63d445f897b52b547a81572d8407f731c6c3c930d40af29771fcfeb977b6b1a4b7847ec03958207a658b0b18aeeb17d3776198443c7515c2ddf42406b9a524e8c85deb75885ee78073e5abd822d6d5ad80b5aa67d07f9e0c5b7664c696c190f7bd5ad3ffbad1fa3f4dc23504134998e4d3c59c755fb6addde0e296d927462d431eff19881a07c53159424cbda9f860ab074b767166437dd9dcf7d633d0020660954b8921b80403fdb12ee99272c408175105ee1e42e3a62c7a374f02811baee95e24c02439c83a932bdf190bfe94871f9f94d02ab398999976bf7eca99462ffa6b258109461a51366cd5f2f5d28ad27872e4fb679aa88140f4374a7b1fecb89f56865a797b4beeb831d5c3f03628f0fbe7a2a7e5a191813d2a1f52003940d6fc7217abbb3eef07fc3cb5b92fb86020525e574172d69bd691dd2ccec82f47a37932945511eac0149ca3ec24b7927d4707f316460b3a4844e30c55b2fb75da9ebbac8bc4d35a7083929cc05447b22e81680f65b6e99b3f7ffec6e094467ae404238c1aa4fe6ec37fd7b04a12233228e872cfccc409b831beb2a8900c71eb7c80d633ca22d0f719e7de4c1777e4953a3be5fd2b9356a8bb3d3243a81253b53aae82482d9073ddfe9d1944cce0b41c4ca15da6b6dfd414e4fc1d7f47abab8d8b89714c79dc53fc30677954b19c3023425f60e5c26caed43aff5cf5d4982e4567eac27ecc0a4f0353a6e85a012e20cee86c6198121a39030f087b1be2dc4879fe4201d8cdc572d2a0253451c932bbf3a8e8cb7032d2e2a3cbc1298273acb79eb1959ef1a6ff6a90a4366f2703ffc9e553847bf0c8e9d9cc0fc37fd247620453d132eda4018fd06499a4b6c93edd95bd4c078ec03f56984d3f2ca0efff775c103f77cd8294c677c74a783786af6cc28a03ac79405ff4b4e655ae6b9c6dcf37b4f98378d35a8c70f7db5b28615e060c25b8f996d6086659393a6fe4f4458b3864a65b092a175040ae514ab203769f860f3942d92c952148268b82a42dd54d94df5052629a90545d2be2df51cb9cd249125f8411edc401cb6115ed8a92a675c64027df6e61d8a49f93fc4fdb9f852d4cd0412b1dada700943414bd33abfd9b9be259f2912698a39ccbee557fb5cbb0a7cd42f167fcc637ab8f507e94eb7ba78c2562042439a28dbb50629a7c3be7db5f73674bd5032e4298792521beb52cbb78a554b0db6e710d595c14da8000776c226d456c5bbb1c1930890146fe71e492bc0d4a9b84c8f3d0491271d927cd8b27910dc07ef9aa4591909e35880ecf55c71ceb6023bf69bd9475dee1b9d35871b028060b841a8ca2f619732dbc0a7405a894ca6310e2bbcef362fa4fe6fda9c8f8d3571489ffd2d1980dcaea7dcd8cbcd9da38c045fe98fd2688a0f84b8d446a831f5c9f8dc5e0f84d2ea9db72982eab635399a0f13e971502f85801eb235be227acbc650afff81f7a82e5b8007bd88df297e0836fa491a911535b13a926fad6a0f3c5c6bae2e70660a313bfd9a3168d995504d53af6c445705c3bd4d42daa73a3d81dac2d78fcdd9279ecc5d735bfbec34591888df616329c0d0f6c118c5b30cc1fa17affebfd526879d287631131101fd120dffa3c85d5e1f4b23642b64d7fbdea54a601c51378d33e92b6b1c2ac23309fe04480fc483afe3150190625ae1cefd5e608185f7da8a0945b6c66f7a94b5597f18ce533465f44551a393efe9ec60a8dd38d60301b133a9375ff2abb29f664b3b9a2959268de2a95d00a3e261c990dbdd44b0dc07cea96e7735eb9e9d3a86966458e0b87a898a5327b27eedc4f25781789a4169f082a86a021fe7b941ebf9bef8b16c936ed9604bd7525d88873e4946024c0ecbcf4d8660aa4d9759c909d0158a2826b9b31e798e6d72b10731fcd1abd16a9ba6991e0931777fc88761b6dbda1cd27cb2ba0a51ed1f5c9ff3129aea1536f7c3588444b468965545d8b5e7c34983f4f6f0faadfb220cd7051cd52264e38190f578775f2b7bbc6f7562534ec8324557518963909ae4439a4be24302cac5f0c1178c413d7196a57f4cd0b1c3605848288bac2edffb52e4b2998384f893e1f5a863f8373cc40c0fc8cb408e6c2a9ccfb53331a68eb9e650d41c8d1bd5fad73a8949df5248cb811f15fe86af01f2ed3ccf7d6b0b65e186c13a89bb73747e7cc41dcfa10ae35fde245a6ece174a56d5180eb8f704a05b7fa6ead1d791c9058205946b7aef649fbaa5170d2cb18585f116fe7d0b4a984218970713bec5188f9b7320331bc8d0f1f516139a2728dd710be041d76b113a689584c4c7285938f1ed9b8bb48fdc37d0246ae86f51d6b42fd57a87eeb6e1b16ff479905c31df3bbbeb7de58422a5696a80e8d080b12eacf68e8f0412455488b9c962ebf111f97c9d66c087b43c7a97cc8b63fc564dc2f5c6b0d97ca3cba799e177b20c0d20f0b9ea1d078082c5d0c0b4464fd1fb89a1f2d594eaaf4ec1cb405742fbd71c7ae6fdec759017834e88fa3f9982fd941ce2f64442ff228f2c0cd0e9c0b6ef6acee5410c4b75c851f199cf44e41bf51da0ca3526d76b962a5fc84b0597fb20d6f806c1b877a699cfb97519344428b89daea1dff48e177dd7ff3cd5a6dba33c46426857d6ebdbb6264bb3f311f5b426d0fd7fe95253ef0a311f3ae882cef72c65b8b2d2739731249a98795a3133fc5f5b61950d448a30cb61c791d9b4268f7f752e3a94430a01f37625015cb1cc532a49651247017ec8f76559fd1319f37c1ae9b11d8cd2d25000fc1de1d46dfaedfd513c6c75746618b5e7f9de06bfd8795ec323df6a638278d5506d29d8a87f9d3c6f79aba621751399248812c32f0e4caaadfe5b62d3b9b90a5e37f83f648650359070ef21521c5f47013bb37442c66feedbb73fecb41cad34bc7dca3b717128791e661cd033d5005af403bd8841d569a1b8c147cd46a40858e3e2daa20be3c8fb9f94e8bdd0c7d43d8088b4ab039cf0a4679ed975aaa96420e2f28e6d7e482f1a81a3284ed7585d2459d1ebf166c68875022fac312b5e7607faf0d5320f40d6ae1a10f8a3ec3214f54ac1282c568944d446606a710577fa978af9d67061d9c64ccbff910c4e2ea1c2e81a870eaf235c0b24796e2d20c6faaef44fab3ca22397c1d0f8e2a4a8475841be583d0ec4b19dfa7a8f3c1e7b5c8839f74135ed8f85dc6adfeda00c27b1f67c03dc1f57960893af75f4f67c1b8a52d429cab91440c4941a5da37b7d92a934df85cb3d4650e7b0482c32a2678fdfcddddd015fbf42552fd6b9cd3ba5b665bf969fa871484b167e27f44647beaa5d74dffe97b5f34dc916cd61758fb23427f2912c833badf5aea280e7c9ba96716ff0926974d644ce0895c5f9cc88d0b472b2c5f40dcd53b804dbf67f5a8c59e4b41107593d44a281ef56028b1c3faa3ec9056be958d81d5940b8d270d54d05d2d591455b221418e169d5d41d82f3774dc148cdc944032ea640ef690e8cb7df37679acdc43c4fbd9fbf885af590b46ea9f504ee2c81b9343bc0004bbf75f6d059cc137ae10188e2a92c4e9215d9782e53361942eeecdf08e39147e20bcfe40e7e8ad9ec027e1dc871fff0fac1815904c8dd7862eece89e6b3530697f4d78a02639ceeac3a971622e409cb7970bca73e44641bc10ba6a189cfaddb4d9aee68a788c6da066ed199f0c1ddbbd1f24db318d5df11523a99b904a8e3d0a5a933a244f2fdadfcc08e68df5bc76a83d5fa13189f282b5e87628fb02db96c680176f65afe68b98cdbb431bbefc285f669cb4c958f50edf389df1bcc56764ceedbf89a7dc842983c43282c6ce047435587e70c1c5b10f031f3efca685a3a57898749529822dd745f539bdd7bc03744395905773482ad742bfb0802438ff227615818201b60465091bc178ff4b9f79b0860b79240afe39008b3077ba91f231a4fdfc60651c94a0f4beb2b8149221106dbb95b1c08f437d3f5ea3c2303b74da4cff5e854bba033b6cc9b5d302d1a902901854b46601f7fb08cfe479673c648fd36dff9836cd6b2d999fa4b476fd103fa7c85cdf29352abbd7fdbbe49827a096391540310679bba142876507f261c59fb83af122b535879c66b6ad7338945da2503c872ccd89764fb44f1d3b08366e09eb47b6ca5568227a7cb08e806791575ea3380db7130af267ee5090ab7414b780918f5b01ff40f4da3fb4773a7e48af08f5db947bef6118f3191f1a99e07a80f6c22591467274ecff7e6e5552c9d12e52b21fc9c1143b8a37c0d14492f382714c9479e18cbf2775bbe8fb9ab85223cc71abc112c9be6ec08f38e44d0ac03a2d715e5daf5c740fc0186a7716e06306dc19ccc4fc1f26210b4cc2329b1be4a796d31e463e4ec89a856a36e52ee8b02363970e41809b7df718691919ad55e83ef598c7213386389a958f6b4407df6484640595bcd6e7f29901fc233afba8acc391cb339a65bf781c5fc042aa21c23d9a691f6b26abeb319bc94a9770033169e60d228e188084b6431b58384941d24eecdd73b366bc3f55018dfa4faaf5bdeb0ce49337b2fa70d7646908a650c06f2a810205cd55cbfc0f157cf6ff1bd6c464fa8bef1a5ff6644c1ddfd2ee538d5643f1a807fa01f59ca3180fbb5ee810e64cd69ff69a3d41951e769ecaf36a7ce8d2d87e5321d7a99ea4164dcc0de00eb01b34776242f5778e34eaded032f82f265acb45768d3e7d65b18a43484d7e2a2cee6b7fc7cd1f774f200f584c327c6976e010639b586494c2d4803438c52e6fa1f821cfc33738a6b985609818b876e9c127c374b6601a9997000759152313fce7fc6686435b12aae35bf4f076da186a95d3de7456640f42e6af29697a95942099475fa14620bd40ff58e364bbda5955fe0478369a6bd1d9876855f33ea65d36be79f037652a83cf5751a5bcdda4234a96a8bf449c3d7eb17f47ee6e6261985167245aa216599d6246ab6bd5919e9a0641ffdc1497767395426f50d77164c0d0b179a4db4fb229bb64e206e154056e9ffe3c6000d1b4e79dee39270e99274f2c01fb947835ec9e3c6333720b6ce8a6c7b411021b49821bb470c97590c9f400f4045d058d2a0485ff50444467e4e49d865dbd1d2209c4bcaffe8a21dd95e0207c68b84efa8ad88d65e90cdf563cc8f1b55796a0de5cc2c913adb345592401c9831b7bbac0366399a3b34d283b8734bd4fd91e2f036ae02e88ecd2507149131131ccfd5efef17142ba3e6960bed12d042eec8c3c26a0baba169fdfb678cac56152b8306d0e7e8b19d27232b50f0282ea0400d4c015fc90c89770ccd5656450f14b414f1f2a50943304420c8ea5b390e15d76ce97d8d91cb0dc079cf6ad66031a6f7c002c7bd42772189105cc7457141f96fa8530509e5f074744da019ae0ab3ac4fe18e2de115f1372f30f31d69f83432e9a21ea287eb18edd75c9642a97570b810de5821a772fde369e75275dca4d06eb50b323b9b07ec4997b9df8973878505f2543b3d6249132026a8a02e4dd8ee01ee93149edc5e49b7a7bb782dd3dafcf6112fbae06cbc02510f1ba4c7a5099532f07ac247c86950a4e10d6e981d2bf97aa6157d81679b6d5c215669f5b29cbe8ca4dc269c81ddb92a6fcabda0ff9f9f32aec097ca9e4fdc041c5ba8f9712ba4786ea2fda4374041b8c8596f60c3be0fc824d826e78f4a69f27ca9437f610678b9264cbebb7eb401abe10c6036a1ca1d08f60a40426e45e7a1c036ab2922a5d6519929d2daee96ba8bca88a96d0ad15af59957fc69fc2ce1cb947a8300a7e63e568cf6275f6ceb25896ba96e280d16e70eaf5416f7a7ccf2b2018d7109b5e1340c19cd54b8b8d732c961d1392f1f3d3382a4d3c992bbff40737f761aa9da8805c0f81832b548bc1405ef4dfc242e482bc197072cd9546d2bb6a9bcb922fba845c5d0786b40b68f5ff15830c980a7f9f98eca3fdfac684a365264de615d6b1a8e2c171e0615f550de9e4659e62f24d2cc5a7ddba4419c0ddd45ca877d30c1add775f2f5d329eea98a42b79cef3420ad0e9ba25167ad1c714a0e984f09d7bad142ffc1501b99f438600c197f7cc9f65b0b529c2f2aec88bf96fbb19070452faa6da1630036126885b5b44d4dd4ca8f99e8ae7e83eca83c0a091900c3af13617f8f96c22034fe5067e108fcce04110eb65b4493d5d7a90aec1d4a7f48caf26988072148abc74175481b69c3519917e484471c6c12b6d102feba26fceba3351e9db718b465fed156976ce85714b036f4ddfaff6f321d98c439687ed13a5ea0563b1d50dc38fe2246e1439ec7adec072bb2677c9b1cb9c73011d5e0c90fc73d43140bee0aed0979a3111cd79abac2c6f4185e9ec40070bdc431194aa6cf1b8ef2373b634ed9e45acdc16b41d535ccfa168586d9e597400a67ba6af1d10e361d44d38aca5d4b9d089a74decb50ef5b95177c31b8726701e9eff9e0f90294763a106f42fa55bbbc2f0761ae57c16b98156aff949fc32b7bbf8de0cc78256cf7495bee47460f87ca73cb6eec38e0054ba4c2e9259fb6054cd72b820755fb4d62bcaed9abd666ab7240d6f0c7751913be0388a1355d3feb01d8a9e0ec8c0fc3ea89f348a65ed21d8666ca2dac039c8b0ca5a44cc2518c80837ab2bf1dffd6963b85ee882950cde05d3ef453a5e3bf18e12ff2747a581d10f8bc10f621d7d942c04fc550f4950e843c26444f6eab126c4d8f5eb29ca10643352cb6b6720e7c9af765375ee7bfae52aa933c7276e893f38d0d66a3db036c33a5d601d6e9eb4c498f0c9d531b7be333ccf559d8e141bf1195ac00a743655756a8431360fa6dba743818979e46924dc31fff6daa3e89f42a6e0660abcf39e8435cbd317f408f4fd63b43f7b3ced525fd90d6415f1f16b1f088736220fb5c7661b381c91154eb39580743246b4c8aadb56b0dfd4857131ba0fb98d71a8459433a1513cefba98b80fe5bb47256242b59e04f9d94f9a5018516abcd8d56caeb2d6656f2c01b9fe1b64a53864e73fcca0377a6ca61ca1950a764a52e592ed5843e40750a61dc38572eb66dbabd41e3523873f0343bc31037c410c8e82b38d05d4f28084eab75f15299d1a1c15de1d78ffdca82cb82b8dc991623bfed8204de0863d2a4241498752af3aa7d4728b1503b4d2ccee809d89ffa315ec86a5bf90a133b1256a212ee18ffcac3eda7b58114bc599ba2d116ab3f365254fef34e7d444a324fe85c0c70b786466dc651a25a144b2eb3e621003441ab16f82022c7aff465e6d1e842e11a789638e497e3a5078d801cb52e8e74b2e7a423bc3c1693f9c82e55e7e98c5e8291681c783638e56eab6f39fc2e2dbb87eb364ffec38f15638233e03f739488928e58713a5225d9a683653ff897563b91db34ff0dc7d99783d841c9028d7097698c4ecdfd09d2d1d0042a8109f33276a5c043921345a06321e9634781ccaa72919cf2fc1823e250537426c1eed7c44969293624e87bb58fc7f3a0f58bf38183a2bb8339a6ddf7d57ea1e79b6471f3a02e7bb1f343e54f9455310a0d2ebba5aa2d4e7cf666a7d7c1efa62544e1c17d13468cb64f008425e56d1fcc64b6b7ffcc29558c409bcd104961d489f0e186f9e63f42005f06244b54bd2f92de1009533a20686e2ead292e27af6e246dcd1fe224321277e8d030ab5d1248b99103e0604e8552437fc0c9aa86c1f269ba77e6885f8c48ae273723d574bb9e18372ccd7e903469433181ad6e608af719a3106a9e7cbee695dd31bc2c19e19763da93058ba4825c263a2490219e91f070988e946acb7c8481abd8b8243ec926e800f9c4c80bbad67cd8a5747be599d2b07f621440b6dbdd00a3e76d971ba8e6580c609a3143bea17287cc7807514c84dc69d50fd184b917654c1ce3f44717322228b6b476480a5bdeb8dc7ce60a2d97b30145240f59af7d9039aa0db1b91786489bd1a7c841694720a3c78733cc1d8d0f8e70e7df0f4eafc8fa43cbd01c48596a40bccf9dd2294320540dd76b30a7fc6dd27a883466aba6ea59043ee26d1190cdf071f1bd45f9d4cefba2debfb24d5104f611ccf5561252a9ceda9c93bea2788fb0bd42f0f344f64b11580640e1278e5655a7dbc51d79046b5ea174f325724ba6fdf5d8b60f6845ce6873e29fa1fc5c45d4a1616934be7f97f0c3fe4c3e1c58b777bf29646656cac7756c3ffb331e05dc7dabe7e12f29519634bca4826ab89f3a66140945d564779e6eb61c24ddbeaf726b27899e26a8d370d29ffe6d859cca5e4ecf94fa5339ebb42f215284043379effcad901651325881c0fa3a53b35fb9b2d09fb4cdc3475e4f3fb255598dc0b3394a4d7c8e226b4aee96e61950728967bb8957776a6442a8db071178df7efe875da394c40a6be2b1553540e9814e103979ebb9fad8909c91c36b33f97d79f1114e6bdbcc05a8ed6b9729fff7b56d4054528a83b1db97e0f4c76f6160c9f88da78e41f866375639f21d98f4d1400277bca2a58c74943128a752413cd33bf18f05d8751b13ef67a431a3ee7e2923c15c0f75c63180cfcc92355f500edac1db4d1c412397a3b7cdd6d72fef05f2354a534d1e67587e2f2fec8d656e456fa709bae1e964fae72b783311594f52af656197dec82eecd8f984cb4c34166821350df65120b5032a2ad5b261ffb11e557f7403b1fba420595b866529d99ab70792213d919d6c444fb4e4b9d198884e37e43ee9ad899e3f22bc28e703e5ed48306786e9ef079a44995839a51157e1b746abcec11a7e95619be84a3730f436a96e3ea1f2f332a7aaa22204cf6159b98a04e95f127040a7946e4fbdf03a909fe14875613632f72713a4c8bb18e9b427b9cf687615bab6c6eafd2f95c492314668e5f1033cadd2e0dcd9e87302e87019320712aa1bcec0aea1b70388f9913d4fa603bfc45e0449001f3aef7eb33dd0c90f5c47c8517af224035484d6506e1d0036bfe78c6c8a1d6cca882e744643dc7ed675fc7882892c101672e8ccdf191c984baf12d24ebd099e0742b594fa6fca2d68328d2ea429bb9e4b533a0b580cba5b9438bd4b04d912fec5c9bbf71be3d1b87e63b9285795c099b00d6646792cc6da4d4c70179f5fb0a8912ceba5d0c52f1559567d489688169e05a1bc6b3e2291bc5f2f189f86a6b57db6e802c98da201e7fe5e7d11692f50e3a48227f4421948fd62035a28cc972b860d365cca45322ff1a92af62e7594924082d2c2135956eaedee0e219f4783810f5388caf9a63831549214f1d6a269d8905635115bd2dac07c5eb9d56e8138c55f63df0744ae0899198e70f2519677f827999c2a52337e15da49168e35082cbc8ca82c28fbbee93e8b18af6637d282f12b001b8d271931e3307fdd964c7e8ab3e213ccd69a52ee1f72f4beb99d86d02ac8b3aacb35a20173d6259681243c0c1f4a437ff4672efef22ccc6abae00cddb0406dcdce27c524eb48f34537ed812d6472ecd3d291b8cfa2499e1a0f4b5c778e1fe4594d5e449b52884ed7ef47f754ac211930f594597ea54d35899ba7b0c252a8849ba9aef475cfcee653a4206f475cd6730f0f1416018f977f61a0cfdf3d8a58103de227bf8db1447bc2b3c3ffd8f5fde0ed1536dda7279311da867dc1929a1bd3af4ac73c91cecb674535fefed7ac2939574e63e8ce477d04fc71a89714a841ec5e7a011a99948c4e99418fe6d2d0ec8570dd74811e3dfcfdd1233cc88016359575866f676f9b4e0b4a99a9b771fd6d3648b39592d6d8eb0e5108677b51baee9256ef4d1dc1844ebec44eb24ba929e39020b1cbc72e6766baaea41cfa0930e57ba30bcd5c30a6291b06353ed7f99431e5ce57df9af14c3a1b53960158ef79f45133a931db257759e2cb7837cd85e8520ac97f8d406ce39d596e8b8f3e3e6c31c98aca0dca7d742dbdf448b23255c05affb157cfd67335935fbb65f4f5d3cbd06a7c3f4552d79c0f7923a64fa844410574a2b4cdbb6b8da7031a66f1960ded824c8a349139b8faa9b788d6c8586b943a11cff3af2998c5df3adddbe6b124aa5f3f53b1e987326e2b1a654b72f628385ded389d50c2f7ffb1aa756db163c6a715f232e3a588246a44190357cc64fe56b1b5535ade739cf4691fb16988f9198206a564d91d5138791b37f18323850a24285cd3f100e93d7bfc18d121a2850ef56cfd44100a6465325c49fdc5b81b85fb0805a31bc1f405ad0723347a79e89a4878e7e38c925e141100cc0c7aa88fe534f39885f2dfeed5caacbfac890a082302aed841ec2ef12fc7058d2ad241622f83ef18716337a526d62e6f55d447d9d415dfb9164497d7070dbf3cfeb2b58ada72e45cd6f29f8f3d68e01e3dbcb2b29f9e055bc2a7097215a90c256d3831dc953691834a30627e12d9baac430b2e271ce329ab91b2fd17a01da0a88fdd2853c3c2f7fbe21df15a742e6a7fcad877ccdfcacf196a298d0bfcc572903d4133f910f5d484604c378e3bb2a1fb1f13870afba694d76eaedb4416336cf4b8a61cefc826b84404e97b610cd2eceea79a8c5b0c61da7db5b81063412fe3863c3f5cb7f1764db459c1ce1a7fc82345dfbff0a70f29ac03689e51794b46b8e103d3fa0d957b7b2bedb42febe1de3d97b06306c68187d93fa6c214ad3a8c7b13682b5f445e8c467bcac9f26cf8dec95371fd4879a2a6701cdabd6617a54b3b25104c2b30301fe2f0ac6b236d4eeef2f40e3600e9d3dde309550daf3f76b43c028ffbd37bb2721c64261b88c397736dac2a2daee00a4e0f07defe1a2b07e8f7aa408095c71a82fc457e4c7f3741103ef22819c3c49833fc7f7631b779155099ec506ecd78cdf53935f6f18daa9d749709ebb8fb2d9fa0fb83ac538b299c67b517f21ea7110b0ebb048eae198cc3e1fb0186ef45a7474b01521de80a67125ff20e8dbee461566ee257d7e098f74e57cbbba6c2ebc58ebdf37050682d5a57d6d56ffb203edf9cc487470bb0d682a32ab59074f93227303bce30779b127e457f4bcab4b398271aa311637cc26ee1a188697e95fc5058bd1eb46f6fadf71cfa878de500bc2540dec129c09a8e3bb7b9db541049a25d2353fd84aba0c066e28b78ceec33361e0c5c90246bdce645231b62e91ecbca7f73564c547c6f53a68bf096c33a80aea3a992bbe78c023cd4a3ddb17c17776bf43d9ccf378647c839bb0e6beb316f086a08b86b9e3c9f580c4b443d6c60489f4be3933798f7de3702e015aea769028f2e0eac7ac80d9b9ab66bce5d90761683ad1e12bde2cf07d17f64492083c1f32d8d7cd60a091cd7cc73c6f83b46ce4956ddcb10e07c8af25f0bc5a535a15a8130019c36e13c8a1f719bb1a03d21e5854ce5da9d7be682b2c5aae97b2d2c38032c4a70e726aae51e5f09b463b9eda4114e7ce7b7cbfd129d00acb621d76b7524d01f469a5de39bb2cba4d31080b218142cfd4c86753fe1fd1d661563e4b56166f982eb2d5d1fa537f2b31be38e583f95316ffe763f655e31c03a20de97914a94ec4ffc5d178e999a7e346b645cb9e4cb63dc2ede53a1f350a8e06dbbcb5e7aa204eefe21d8d4c6ea0864cc49ef798ea360f04f997dad6e528be73c6c1a014b623ba9e5904af475710f5d28c0b1069e5fe717593b641dc0597f84c5a896ea9db8513385faaa51c4bb31d4e80d5c1b56f89a46a4c5b9b4b91bd9fb0d99a34ca69dda1bd3619a3dde265473dcc98aa1a6d0a1cbea8ee431a1de0b35ad95607244061315e5ae53427ce476086ff45772807f03c073a53bd22ea19d3652e4dcf79eb94017a22f4200f8fcaefcb5298e334b40e7f8a4fcfc8ba468aea05e398afbc86e4e82a840f01729729189f44eab1b6e06900da0fa1de40fc2b369b5e858d5aef51d848cb376367c8322354f126d3a1cc3e402bc1dabb31eb7c3a923cacdb7ef084f0f8c71d7289006cb3d13257743f08339cd824d6c796c5e4fb25436f78ac065dd513af5e26be5e921a2e2ac547aa2913ab9c418712061380b9c8802575b6d5847d06747732d7a0a04338509db390a49c915cb4dce3285ce1f78b20957ce71a6ba191a70c99d82140e5ea4e775e393a8db734534660ba5dcfddc97b98478a1587b0349b1076d18c9143c31e117ed57cae55eb130860010bfb6036f2ce762a0e33b51a456740fc9943848dcfcb8767746a3f41152df2485c959343fd5122cbe9a4194f9b9550510bd3e412d12b7db153d80e1d18de736d894bd7b5fec2d09393a96c225937d6432535a4fb7be075057964eabfb2732e555c580e11dfa7fe1608103d1094b06c7486a981801d71edd8b7da71a25bb308bfdb991dccc664cb1b75d00706d8c90a08e882ba06bbf44946c95b0b1c9ed1f96642fb3db371bdbe1c8742c9b2c7a2bef7e45cc70b0ed0147a99276602fa0a6e53f36b0070121d32f21d58fe9c0b5d5b55950d8bc234b6bbca1aefe025175d52ee4909de9c76e04ceb1b9890ef2e4ca9752477d323b482612d2b972b2bc1f34add240a3180add9b7e44384adb0fa286513b869c5397427576aff68a22ed1b081da1d8573de686a2d4634423cd5ef2978ed32a24dc9abc8226fa95ee06cacc1f27e4ca60e471c8b363d13def180871f8e64eb4c8fdbb68342f005d5503bf3e5b04f5280a5d077776b95df25e7472222801961522ad8f6708c6c34e9aac4f88044fbd1d77fd2a1ad6289c11cf73ce3e813ce0dfdb066f0181e0b34f36da88c9122b17c4bab72df20f952a8e8b13740c9accc1751c6e89ac36b2ae7c436089b800e09fa7ed38adabef3a79440378a8f14e8ede496f1cc22f75e42a4a20813dac1d7141cb96b75aee695ec0c662e5dd7beed9acc34ca1bc3512e891c8ba9a290aa1cab00daa1c8a627a6677330fc8301670a014f91d78d2fef81bdabee2f9c9aad01de904577a2d9061dccce340c6d745f9271361bd3fc62e7bd9830be44fd348b14f2913d5c64cddedb2d215c523ec18e6dc5ddf24d8e7df1d91e70c3e3ac297f88bfc0ca4057cd4741f37676ab000a93f43307bbf4509257690e5ee81f6419650e3183352f79b3fe0de86b43428c543217b5b5fc21a876149327a3f978fd34f9ac3ec4898540f3d840f26a453013d587e5a28af9ed46eaf85136e5688aa73c44a7a0c2ef5b9984ee484fd52d4e93ef185e287998116fef3a5044d01ac0ed3467d963da2facc669b9521ec7ec1e7faa6a114b1d99bd72e3b55b7d0184faa4c7a821727dde441c2781a00f3e63d7eabcec018c842faedeb51207ab00f6f518082c5e7bc233575ebbcf0c0649f21d70fd0ed982f828b2fadd4f8fa1242977cb53a4cfffd2a8dab2f7221a3d56376d3c411057c7fa108efbccde9ebe9a33d79aa0d42042f7f9e3c19943eafc35b4d6ecbbbcab715b4b5c573e7950a85da243c4842d7c424fd7dba83a1103857bcf912f6d9372cccd80731aa3939df779c6e5905d80461b1ce0d6358b86d197927009401a2c1d916c64acc96dc719eaa9499364cb1585291ee6aac92f6ecce87f31e22cbe681d0d5c63a3c6fb7fd55a17b81d7a52bc5335f1b33064126ead4bee75aa779fc43e3b0f65b3cea2215e0f1d25b07ab820ebb216c60eaf56d0ebd83bff87c0baf01c2b0127412260334cf64116c2b84f2dfd24f024e6282d831e9a98b963a6358cbbcd32f6c545f8700798be2177e138ecacf1645f79af030d041bb33bcf693b8e7b552296aaa0569be68f17e256a0d51bedd993d8bc50cf66593d475dc046f80addecd494fefbecf1ef478b7f08f35e63e05d23e8fb6285af31dc3097698b2b60356b659a484281851a11ad94772df1d55d1e3f90e4b45c80b6740a77c0a315559016bdfbe5f72c6984499382c423c69114e218549bec6f2c83048d8d9a3726c858f196ef72da505e1cad6b777434562d235557c787c5196d663aa5e5111f1ba9e3692a5f69f70500d9b99e1b17ed8d99b8ce2ac036fb3e895a86447396cf6eba8eed198d4da4610f2538853aeb42140783ed46f4534bbe873dfe8d50c09d256fb6d54763b3e0b8b8529c87dcd63ba723e31b57c168d8d2f6dadfbf7111b9053831fce899f174cfc72bbeb643a9b5cbc712e27f7ea5ef8e2ec8e4306079c4dec527a2d39d7b6acb365f420b2b8e752b5d2a9cc001fc66b97818f9aeeaa812ec15d9c11040bb3ee02076ad54a962d8c07b7ed798ee7049ad25fd06ff03eb4a1bce32a10ecc4e1da3f3ed1bf928a3063a6e683561de832cab984b89ed7de9c7e3059d1df507219e07fd88cc9f19affde343befe05b1377f019e40bddfc1fe67c7c1f26d562496b8cfacd694a573fbad635ebe8fac2aa6705c5d43e64d5c88305dc95df6764c618732086afa1fb9f3ee82b8e7cf5f9955f72c191381cea2f51a1e9010a9752761a4bc13db0c44a608535f55f67283f8a51110ac8ad1b95422807850642a38f99a703877695419b419a73786a3bd242666d501ff59c55d5619baaafba91005e42196fe68795dd8687903e129ada24b56ccdcc53773ccdc835ab5a2543a10507823bbd39f0da4ffc7b0242ee463f51b19a9bd7a5c776e63e1db05929c5579f18bedb00c97028f1db635bc8067cd3f91ac7e40e6b8d464d2bab8e168c0ab74d36757b00286fcc7f2b26c1ca5deacc8297df2f55cbbc68c9af54843c6e90bebdbdfdbc63b20069610e97b555fb8368fd944f93b4c13497ede4136057a7c99532eddffdcf5a5b86efac3c482fd439b35c414bd9972193e916e7e2ce758601e530af1ca46e59c65bee59a5882d1a6e0387aa63752c9776a1fbb5091876413ab70bb99fd7e9aad4b4daf748d6aaa1b328661521674f51f4e9b8e991017dee81766e3bbafe808495d6d99d74d8a48acde98f36dc035109b8dbabb7653aeed3dc68ef0492f3ef262c3ef0eea869ad21a182a005978447cdb93a16796b23ad73f1d297d5f2080cb3b54b21932c15548853817e43af30eaa60236dbbc862cca4755b211b6debcdd07e9e14c2cf48a4dc79c6d6224a837a4b970dac69a6e6580706dcd27037501283c984b029fd71daa93464642d9f442f18c3d4fe5faaf7b0d53b115c01468bf25c68afbe9e77e637ad146b8a77937adf94f0828c58ec5fde9de72ef34db3904e2f74ad8b2fcc7f2f7a4e324a8675ee6255ecd980ad0a4856943a367dd3c38485172f59945cb73d2bdd1676c26d6913556b01a418fd509c8a5758ea1f97340c26a69b1cf1e203c0bd9bfaebab6434f298c81356c0e21e12fb47944eec906bd534ddc7b6539aee29a8bcba12db0a989c0fa1f1e6c5d300798ca2a1f877e2e332bf793af783af5247060f7e46e3cb15e635068ca22d668793ebd178fed7553287eebf2dbdcda31b2c7c536fc8eb8c861ecd57b493a6f3220645a969348e91a04ac04a1fc49532c26aecba0c6bc71ad13d9b844258e1d2de3e3e7f2a08226f17b8b5748b1cf679c732e7e4c1f7cdc688a715b7fd8fa45c74f8b426da5031a14be1f7a33f6a88d0eed0bf250168b76ad600f38fe1c119a3af6265870f0a2572eae262ce0711afb3468d2505139025dade84a383cad66f4f6480dd88dfb1f4b7203e95c5303eb75b0399197c52c8f4a1d4e26b44ad9de0d4af5772483c15bcb83788e28ee237c912c9a9b24de734e7e1df645e0acbe1249e74bbbfd79aa949106e54951acb5a879802bad908579f3b4b55bd2bb1c138320ac5ddfd9f320ff500242ed5fbd26ea7f61eb87e5218aee26d92cfa83148b99e9f103d632e41b2ee2d2d64ef49645981cf1b1413ba063153afbc67d6550382e7a685aa33854f712dc9e26119342b19885ffb7c0da6f6fdff73abf8bfc4a1acf1a217d24b153d27989d28620354a4bd6c204fbd4085f7e1a26908fdc6f559df613782fb8df3e078ac03972025cd896b3547a58d87745f7afb851bae4e471bd70c75f5c1baed3d37264ccf67028a1e276fa54847f2d7d23ab7c1a7b2f3174f71250fc06f9658ffbfdc763d92638d7523cb4b92fe5b9658aa79a0efcf9caefd8e4f7567f327c9f6b0497347b837f63511828b733cd024249b10d046a2b9884e5a68563d68b6c1fdebddd5b2deed8e4e079c9842b38c0d43969e9cd8d5780fec61f7da8186d07d306c5853df0831d20ed77c6582b60df19b010ff8aeccf2b8519d1dc263620268adfde6398e1af57053f331477b0fe6159683a5b4b126c71ea8e2d99704bc8958a5cc05f55294f66090f7fac0d68fc5ab50a6d8254b7adf733a76a5e4ee5f4b67b791708e50a48d561b0c1df9b6c9f1c74f3033c05da64e5e05d8fe48328f7b5d8a4012f7bcc6e7a359992b4ee2c6935e45c95cef821867fd9f18a4736539e152de16abff0fb850c4910a74dce428073ba1ad6de7f1b9ffc4ca076b1feb03c1cfc9d2d48da70e39bd9bdc71653ff2790eb6f4f977f4ca2e2d2125f58e487c1dc6907c6ced27fd39d103678328a4352e3da37cb7693a4601e41ec24fe7fac323ee2704332fe36effc9e69c06eafa20a4fceaad531bb069b078be03c1a1e158bafc65263cb1e704e16a9a30957ea3df83c469666917dd215bb5737de03e1a6faa323427b048866413594ce062b9b3d4e102cf9573c633db793e1480fe6e1bf9a7070d6d1abde17b02a9048c69874446d6d3469f27d15ff1c6a065db6dd0bbbe55cb737214d24dab5d39f08828d14d965cbf330335e5dabaea177e64b68ab04f1ee924f92ddeb7ae71fd7539cf108c8c6c8678b262ae5254c2141fa5bbd069f9814c61dd0efd0aece845d8ce55a00d1a63ae8216103dded41ea4b5625f3fb7183f5ad7046f04fb16f76d7ac6e5e442ea1afa1c5f231df1c12ec52ea8d148162b03b8919d013749544aedeff6aafa2936c4bca927c5b52cfdfe5aa0aa81bd34bdd54661d9192bf789d6ce4dd40e818594087b40c12fc529143f5cc3bc2627d3d9c14d672839ab7d522a990fe50a65adec9d786b5f67ea5b9bef8ce59fcfda19c26300aad2c5798620f497312b7b0b1f71e15113de45c0772d71481bcfa2ad24b6b1b31f04db9b8c4ae422a7bf18908b622ac1c32b11174bd743a35aea9a4b82439474963da17d9eee3cdb3385ee48f5bfa86c62980128378dc0164f31839d97602b6043631fef6ec32a9b6006b08774ab365c2063ad56f414f687d640a8ea876392854ccc78cb9654ab2d8b7f06b0004418194e4911c5d7f2a2780b0b69a8cbb284998ade79e7e3fe02a7e074fd19199a26c7ff6488c5c099a7089b4db264b9586e3706aa6d53354a6935ff0f998dcb20a6c47de1c9e666ec1c2b604c300de02b480e1825c3c41fe4250729c31ce4f05a6da2beee87d639dbfa80d07b621d348b08f465f9fb127cdb1a35e47589f694d4c7f2c5257dd7b5c4f6615d0434f92d78ec4ad43a13a37a14142a9b2e9044fb81a0617aeab371e68dfe5bfa312ddf5cde524834da4221cf705b3c0252ba990c7bb2942a16682463653df8d42e0a9c69690ce458548f7036530b47b9260da74827e836313b38729d7274fee98cdccc13380e22b84e30c4856e88419c6d1547923d90a8bac9248991e720b6439a1b354d5f48cb1af758fa52af7d36d19b6b0542dd8641baf73b3eb91a3e3d17bab248fe3fc8f069261a43dc2e2e562c33cc8d6d9405ec3c0ea698fff325d9755c374b7e4de70a1ffdbec9837aa071260e9bd582815f9906fa34f0bef891ea50b37ca16667f28c8c1b4c530df93c6b5b4ff316810631fa7fdd673cf6657b08bceefa2fde8b7717f9ad44a0f9d378857889f3118d2f726c195cb0d28cecaac9638cf4fd42b3e9df92240364c4e0d6f3ab843bbee9afbe367a6208ac71150a4cab4b0f56f9ed1d0ee87e6e05902ff99099d58ac711313135a8e63153c48438a88d58cac003e25d882143c0c2134352bc47c4bed94dee60858cda540419dcd4cd0a82bc605c15c1d329a5a7aed26052e0aa2133fe2a30195ad132d2f7c85c2cbac9c86cd17909ccf509e62b95a81760b8ee6666b74a7cdbe978c92935dac2e3db80fffff4a7a57773b30e227c3b5b8c7674e1ae05a7c2d8c28fd4363b415c9072a07af507fbb295ccd13a03283b000bab62a330ccbaeb227a4d37fbb92e63b33741e849864c8bee6e689d299ac2fd9e668751f0694a95baece3a5665ae775f747c9d4d1d26d049588f658b1b463fcd1fc68943d3e74a80995c297d4e66f65ec0d61f7032d4c4608a988dcabed8bda930935808bc4d83f3217790bdf6051bb92fddceef22441fd0753e94c85531c44afb7ab06dc937ca903adde6d1ba223936f1d828f45eb4562ef1eab43de7c806dc839e083fb1f8ab173c57147461089ed69ed09afa3f2a88225b0e30d6fbbc9844059e37668127ebc184e9e1d3207fd1d07c2fdfc18fa5916275136113eaf44b8424f28ab47d3fefa6e116046180c65f2c2401dbe0de8ed1b199a2b273365ccd70929e4a577abfa2dc1272f0399fe891db4e32e57807f99758eb3647cfe31341f66ba725082ab66b87388223fbd07e2b56405c79b1367857ae587bddc3b90476903e3acf7f20faf7f4e9d8970c609a9889327ff8df7c963949b7b3d425b08194ae86d383f6b696a967f95d6d7a1a020a7f4a2efe639e33a6bf57be7b0b89c6173d9142993f365ff32d9d779301f1aeae5aef0e2cf87a988da4a146c364a34fdb4ab41299707e7405ea0cd7832c1d22c0453bb534abf3b6f2b657d90c67f018c7489c80974b0b5a216178ef5a680386fabee303bfc8a5a551a16627a14e641c26ed0851559313f38b43becb6ddb91f83cdfea74b0e5f857d4bfc4bc310fea2f72dd097cec23a5feb1fb2b7b666de55cb7c1c79c2516827437d8642cad3077cff5e8e366f65b95a6524e22a095f5ade435b792b5c450ddda5f6cb9aaabea782a79faaf9908005b786ba170242787f30057bcb0e7b93f9d3746841b52ceaaee7bab3a8e5f0121cdb5a328b71349d480c33c7bc0d4f8b620b751c8620c1678b0f5e2727095ccb17a6d9d41271d6f43ce53ecd152d2a33e35f516fd09e4e151fee3abf19b5be3611e8caa6261cafc8116312b24f8d975609fe7be199d71635dac1552ab0981d725f8077f6034387eab540d09f172ab2857e24398a36979b039cfad06863b8d35c68cc6b9c0d4fb166e36f51c206f19960c090312a08135587548fc8f974ac341a27e3e27b06c6c2b762fb39a2df8b6e2b68b741d81c9842a3cfa41ac8a3da76c711a6ff101b15d8d5c3981c65ddf8a4091b7ad1dcf38dad26eb5b30d4fa454eefc3fe17a9e890ca82d5c7b6412b00202e5760191fe478eab3c691fb9484716859f1bb550ac129480a0fca68195439bca369ef0ba426791ff797347b4ed6dbc15527bac8b4f3a4bfdcaf6e842e73b6505df349ba68afd67f25e9033595c40ad2171bef8cfa793b7b65771a4cbfd4c229909e037747a052ba13100078ddbefc71cd1ae0aa4a355c8c14a4df4ed3f9f3a85f4430f867244cbff3d9c06494c98186bff64f799f704a865b3c7861596f863f5262474d2e7b4147bf3f5b6260a9d96972c38e8a7bd3c61f67233451a9d9b62c1bb742cedf2c6673e0fcb636dc30e8a178fa1bf17b8ba6ec38351e6bcfb1dc58a7f7fa92a09fdc3be70649e4264b87e5fe2efe4387960db6e291003fade2e13b7a912d5e99d804c88003695a85c29e348d77f74f19e14a42776561596b742564f08c90b54c76cfea2bc97857f52fd7e1414bc7ad09ea9e404dc5b7ed07c748fdcf8daf959850be059ce1a1fd16b37cf3def4f028aac1b65671075a02b32bbdc4bf3d39989e835c2fa0b55d0c2d95f308a5e4bd651c30244dca9ee3bb30e71ebe88bd23befb2e71123e83284731ccc4531821e412c981680c3cc77f414c2dbb374a140175a4e35316b11c7038d01a9502b048b4e069a253c81a502a9fab87712daecdf74c6293caefe4c30176da9d64f0017bbc5c4ccd70a7d9982fc9e2c84d49fe376357d81016a9b4a8f76db3d1617439296e28b39bc74a566f31e7b9bb76f7606df88318cbdbb926b1b79a2e7c9598dcd531b6344ad713d3b5e57af034a3b7430133f58a59232efa67bbf236fb6a100a3118e72a7494b1fb1cc61c5db57ec6896d9456a8dd7ad7a7eb14ff9bbc185e0c26649643af5aab75e395bb537dccc9ff704a020700d60ea1030f682fcc36fe75462558d7654a1afeb43f04249b490f85adb9b3465a85a229df142bbd37ba7584cf5fc6a5f4fec478dffaf588e71054a1e15a7e8dff87643d8d879dad3cd086698b400786e2b1041bbe6142145884eab0dc183df60913ef3e2877a54e6ab5a6bfdfe78cbbb88d9076f43fe78d06f4f62e5b884f9dabb8115920e501411ee156203ac72855e53e0f6104b091d8f05524293775942f834552c9c0528c9384e9386e4d5ee32459ade7fa37426be2a6c8e8a8eb27dd188acbb103effa23e645139c6d14a8f2df84e10ff0d868a10dcf955008559898c42989261e8d5ea7dfeb3557243ab3a00417eb0353187650f96136bbf6a12792d9e20ef3df1c56188d0300644dbfde5154ea57632c38f6e63f0c785fe45a7f86526c0f0eb81dbe11a742236841813b456eb529dbb9dc9a94047d16104abe378e4f0b169882196406f40203a35b1e3d28c56ef17c40668db9059cfdfa5714c5a0a351e956bb0fb3597ea18c22c4e94d5d870bb31f5504704da1e2be872b12b5c5c454c68c6634603169e898a0457f427f712aab0d748b4736ba52f7052def0dc1424fa7720e8b89294ae8e6a2c3def2a162dd6ffbd4fdec4f7dbdca4da1f117a2b9a2c4b1ca21d361503012242ede4e2c4a67fd01e604c252fb835d1bca62851b311ed71bba45bc88449fb5acd995d289f48dabad770f24fbc03a2865542227a5f88d2c21b7bb04d64015829592d8bcae166f617e9a75dc1d300bf7a4005e8b8044c7260468baba7683735c7a96e65ff2446c075e7d2b9ccba1ba51fc68241ffc16ec6050548da12d9e59e6e9d49b65892b5fb958f3fe576cce74f03b0be2265f9f295596d810729f68a35f221c1245b87c53f38dc0864ead3f6b868ad914e8bfde5a8ff81d1eb89c97dee375a7f4d947c09638720ecd0c65e4c76d1c2fff8c6dbaa286944ebf15b02672b6e97e9ee817bf38e4b4bc4068f31e729266ccce1be26a6c9e46c29d61969965535f2606d6ae680ae547da6201277a30173d95a80d33460b2ad469bffe746988caeffeeb133e9cce1c4d49769445dd1852e3ea07cb5e0fea69d9403a0997fc3add844f95b6d30c6e19f62ddc35baa9726e76db0cc39c25c6da8660c700e54b1fe8fbbbe87f88bbabc575bc88711f25daeb3672db89600161938c092a709cba9c9014424f0e2336dec6f0e1d7d2e816e4dfbff1d986412ebca7189aa270c1bec3f8ed7f996338de595c4be47f6c2c132b57b788a143efa6b9f70f619274da9221aed79cd98244eef33b8f940de867bd8d015ea1b9100b49c29de00d2c09b9762ec88af8352677dfdfb73ce996df797e7f8d65c619fb50c7bf2d2878e15441cf8c64fa4bfef4a798368217dabdb996034006ff504ba9637af52f45c73bc234eb450e727593a4ec7f80e54a0f0ad1ec618c2f66034dd1566061707a5b9e77314aefc813bcfa1ec9e00f742e7d74d312135a739a8755f7b071816870e7809c9b9dcea1ca68a09076cef31916d16fcf0a97be96e51e294f72e5bbf5ff96541d85eadc6e7ef3806b9cddab85d88f43d102369af110b4d29c46de7830eb07e98bb86e13c83db8bec6bf6e0cd4a020dd6700be07b9b7aa524d5ad15aa112b1344650d82ecf75267927ff73c4b415667bf5ed4400e9bb27e42179e70deabc5d386c027fa5742df96ae7801c51b47fb2c09e2eaff608084a201601736603c6487ae234e689c335dfd0d3ece9938487229f4e52883c6b56a59634c5e73200b5f388b9203dd6f237c3863e4cff8c3ef76e07943635e2236d5f6538d77b4b88e1ca34b62b446de5bfd3fa6a59c5ffa2b116b16ed56637b7a7b77cc2ab3859d13e21cf8fcbef6565397ba5452f7ac86e3e0700eb3ec94361aa350006ee9331a8cafb04dbc7768f5e99c0514c5c9f755291762aa6273f50742bad5a35155e20c5bceb83dc6b04597a7bda6086887648137ea4f5dac13b9527ee80253e3c00b10182eed44ff9f38c86c9d1bb3f0111c2bd55e047094072c6f5f1cdf3682ccdd40f08a5f33391310eef9b06a0a2fa7a8f9c1ad024e5688b67d4f32d5e840dd2f476235a74406fbb53f236b46665f8886df0d1606471751e69aacb1264f21d0a370e0e20690a4554e9a30a6b7aa911013a25b69df9ec4c987274992a8bf7f16e99d8d6e4b77bdf5418837003d77e6a368a8ce38a9292df7aca89eccaa1a87c40191618eca5c51329b12da65084267ba727f747e2baae35b3afe4e3e6838d53d9a39d340ac7b91c61aac959cbb9addcc6b63a2b6775c7fc438d2188dc25cae4ee417069babbc39d8798394e08dbef692db6f6541ed76332789f113e3bc7c0081202863fa098132fbd6b326637b9524855c795d427a1b99009aba703ead25b4b6cc20b94135e6028e1f85f8093f71b5078c603a46947acce46c960d363ee435d629b1fe69f381c974698a5a5a9401fb1671567962a84ae9714aa9a9f4dd4ee3bf5443717eb9fa2f56631b26d4c4389373db0745da9a9bdd20f859e71939413689d2b8c84a28b2b3f85e5713818956c5ec5b1338cf032c131543684656f937b97058b9f7fd0678a881dfffa77532685a9dc0dfbcc2a51fd427dbace70bb4c2bbfd02dda18154bcab6203e2600d1031ef49da9c2a81b1d06f33a87fe5cf856374fc8b587d03f6937da4787c9b4bfea38d2b14b18c4a0afe59bc55e72769adcde191d822d3db09b8f5e3ee9e485b13c9d4482791728ec96e9abfcea3dfc3ca2eb4ace84d21b17ae01b55b6795f1f5a70d8816aabbf5c9e8afaa16500915256d928d2c9a6c70621315cfbb6bea5d5fb284cfa11acaf52bd9fdcffa1c6c9cfcc5d9c1749db9d5f71676fc059c34c17d17a9d1a79a5439facadd10a9fd5f885a82c88ee7f1fef2dcb4abc55fd1402a4a1c8504c3641f340dd065e3171404f1762c5c52884504266490b258b7664c1a5c7ddc735525a909ed90520c219e76d8942203d13e61d6ae42d9b74cbb950f18f5aff12130e3e2a551501d4730188df6ebf38aca8f3145c1aa4e6e8c8b1c07529d749dd5a17818224a90554c407282bc2bc9b04b5da3b2f08c2591e7ad2c27dc0a3f3c7fd3c17fc822ffb13c19d0486f909a48e052dfef8bc3942dd8b65cc4f85a6ab0d3c5f570a4ae21961684caa3198aa7135ba3d7634f78da3feb699ac5589cbd5e9eeed91e5848248dcdbe31c9d2fdef15fb73abe1e290d7cfbaa5a2e1c6fbfa042fb698e22dfffe6195abaec81f155bee146e7fab283d3362cf827e08c0a336b7158c4117f80f355994bb6ed4df1b298498d968be46d6586d723cdf20cb3a6eb8e97ff3e82530efa18ae2b59dfed019b935808b8388ca081fae32dd9c83fe34b47f22958757b818d0dfa9a8a2af53afb623105ec56c8ee82013a3b7bfb080ab882bcc9539d8d724a847d7646446e5b2e3265b6791c4aefe8480f6088e5eef7b3aeee6e2d77ccf200e45f7ee0e4a6af1e89497c7d72aedb6f4d51e06842105ca1abf37776ec0c426798593a9bdda6257be95788c06482153855749c6ce9660e01ac384dde526e96fdf093162a42f344eb140a2d453d162aca3ce1708ac59f54bd60c4ceb19035c371cd3dbfeb16cb3048bd24c4ae41bc351d1142012da7fbd27cf2a0ec0433144fca3054e430a8bd3194f6d235c5cbbdf5deb884117d11f49d397d517c4ae497d7ad4ed300489f23b9446becfce15a308b22e523edb8e0052e441046293992d4abe0bd5eb92037c6946a9dadca479d4b4b646db6fcc3139ca6daf74e1af11d45e52bed91b89f30f44977fa77da20fafe7871af3c1e6c7f412609b619fb2a2c647ab4782dae048e3d887011f6dcdffc0d762a6c8604ed788b09b29b19f2e0490c0ee6f2574c3d153d9f446828b4ffcddf5f155a684c96d2ab81308159cf106729147dbc17b3c959033fed84f0fb4449296b0ddb4d720e9feacff78a5e353ccff18a7abae1ad1395ac38ba667b6e61d4bf110980806b05eefb2729675349002b1f1d1b8aabfb382ea4c1e35679511ae083d6c42efa2123350152667c7c7572e50d44f4001f12113e73a5a4e4521823abc1412a52957ced73499f13e68814212c8a90930852ce93210a0d6c4408c4dcc45786a54e584505f0022e89200199a12bb4de3159782b4617555e10dfcd891d22af46d58f0c2a6af7cea47474fe7070ffb6695319a4049ec2c3e7bd535a5ca4e69fb1a7766e556b725bfaf266e3ded0dbc9e6187fa629758fb0d278a606ac749fada74b964c25717b173d099610b4be3f4309e13da146bd030b29c16b454f1d0afb32d5d180bc625768d03ae511c40a1bfbf0b1935944dae9f068c4ae2ee5ff903c3ed3d6ec360484eb43ce2c527ad72d88691a7927980c1e0da9ebf0ff41d862f2cbadbd18ee1bf824d6d18899dd9b4a35431eb76d297ad94fb5237b68735fbcb7b13b37dc8e762b1493a779a7b1ea4a475b9bd7975b9a0668181ff2ac6800d794e7b76414f2541c02839a7ad4b61985845a6c5dd216e38741c3e0570b471e0b8825014a01af2bf0c91bb02655dcbb9a2412f172b0523874f183db2ba60352dd305f94ef2bb0e44fe1e5465c9145074981f7a8df61dd4adb643c96a419871f221d582615ef4f7725f4611b8d16e9a47bdbc448ae33a63b946ff115abe552ad5a4d2a0f29c0223f33978e884fda4aad7b59efdc9453c921ed53a5a258a9b662c39b18aa9b4bac5eba1de49cc25842913eefd6dbeaf49d8c2265b51271bbd29e1f14c21a6f3bba2401939e4e873a8f9e0d2f241c4acaab55c3b5c0ad23f1311d5d6672497aff0db1f1b9070def1fb46171d3da781d52a1d4817f6a9d6dd86c3dcf17e2b7f3c3c154f306e8127cac375ebe8b6ae37f2a02aac7be18e93ce989e060d007e38a2a8e0d28fbbb2ba4d508c87708b09ecdae496f28552e73eb1d8bd856d10fb7e5c2bd82f3dbaba21c3048ad94cec27618d0f8fc3dba1537b14c147cf6872fe39114be68720a12571184d911274600de019e768aed0d5c75a3849bdde2e2206fe0115fefca2c1e859a3c3444d71d988c114a5ca0a3bd8e5a4d8668b43abcb96a09f5e49e977c3540d9c87c4f711b5f230f091010eb856139012621d6e0869fb32904a5672feaa6a985327ad8d5107d5d7633721a710906212243b1ecb63dab92716e56b9e3c9b3b8fdc389109f61c95188cfbcdc241b3a35ed1414cb684d789c0e36a9d0bba342cca5355bce0140fab5957cdab473afe2a264c870090daaa403ff4274bae55cf7efb8749272896c162ead849fecea9459615728891eef557f4491c165b465eb4ee6d890d525e5eb1b7fcc9d1665b69691aa95cc8fcffff35540fa94471e9a728f0a254f80d4ec6207448a12fd7e9a735a38ee64cdf8978adafbb560416fb09e4d58126ab742397af17072856e491d41283b07328108f620e2e8590e74f32096e3ef8428e5f24983c08260c1e678592bd44ffbc61cb82253d0d203d067248907167ec57cf350fc8b51ef8fa09467d6f6f95fbff552305f7a013ba410f868642704afcdfbc2350f8cb03ccf7711fc201330555754080e7f8e3cc4f31e64e5e0c64d8b13fb3346f29dc0c22116ce540f698029e40e3754ec42f6acf81b711504773a339026710f8d0acbe4e5d0ef89745cfa947f5aa39ddc04d645d88001ceab24afe02b6f6be699906e04908bf2cc702118fca67fa3a591cd076a95cf375074ba480ca611caafc466bdf259e4cba0356f39f15b25fe5e0d1c39e59edd3606c6455b99a249b99329d32333bae7d14bddac87055f3a4eef7c3be9bfcda267e8177d4a51446c090a2bde2cdd63666e4d3898564ccb44b70a5a586f79aaf2d3e168b26cb0ebadbf596b2095d2c81c35036b0e62648d084ec9d9fdc46a92e82101fb20d1fe8f1a9a502c7dac66be443d0af1100faa47b7942cce117e86ab4b4fe9a706996989217d7dbc9747987c381e6c03876e6a45130d1a22e9570205b9bb54a82eb1a7f76412cd4f079c50460d20008e412ca4b41120155df7953207b866a00d621bf6a9810708ba71e69f17048acbe7a9929f7f08d9217b101d2a11174e7a31eea26b95726a1e7f93991a7dc6cfbf452a894dee86a6eff8d1373894dc0e1650a1e679cd7b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>第一台云服务器</title>
    <url>/2021/11/01/%E7%AC%AC%E4%B8%80%E5%8F%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f08fc40e0d9245d0b4ca95a65038ec64ce338ab7ed13bc8d9d11610e90aadb07">6d458f11055df70500a2d94a3e91c922e95c67de65dbd1b913581463ebeb6abbe1614ee3f8d83271c19baf35549967eed21fd75988093cc9ba3d23f3159f23642dad03b903a07a354a535fbe3f1e070f4b92e663f41ec7f7c157fc3b3b6d17e395d998aa395df6367310d045d4b7f9f0c4ac46ba46c9527f7fefe6403b6e4e5eeb0de0bb21b15cb27cab265cc2e4e095aa7af1a461e7dafe5adeac0cff4ea7593a7cefe1278662cdd576258f4ecf8d83c86f6eca4710172d47a1bfa875a22194935cd983089f33bcafc1abbf0497b08444376f36632c17c06e91d927c9dc18b2060acf53a331d22bae59fb06fa524915db626c5678e5308bae9dac9b73aa8eceb21c4ca3123f6579f103251fa79a6abd7c37e067898f7afe5028af0e9bb6831e41b2842123f4ba2b0d8e091a7209ec319202d2e3ab4581092cf2a276c6a84b05bd89f2b394cf62016bd780e448b21a866ef451cef2ab9114071397830bb34d3e91b2c6a6cd49c4a52ad1dc334b3920fcbb26130aaeac9084ca906504e2888a468ee8c50617f7966b4870514f98a327cf632f66a2d518dbe18c301b8ef51064bc9647363ba25f9b174e81167b6cef71211e057bbfba53f85c505b4acb3987187176e5dfc45aeddb85ae452d9917ef7fae2c27a72ffcc9e1e9381b73b98fbcccc0028c536e135c0dcaae58a5847ec9fce6fc82d8cf25827f332bcb81b177a31f1c157642f1b4024ae07c977cc4b7785be8b05046ed50d20fb92ee12e7603a22b04e4b1a4f317a73c10715ea9ca049f0f02bd49bf45618f6ea3ca6df7ae66da6fcd057a12d8798ca2ed1369e52e3dd71b32e524a580ffddf8bc3b7e614160db2dee58b2e4d12cc8d134c15ad9d09604eaf241c6002722864871f50e7cc287edb22e7d565415ba5d0c1feecd9887b58ed1405856afe89b8e54b9053ab4b9d84d5fce3ed78ed761de5cbec39b37c6480379facdcc94f5669d3c2a44bdad6d0dbbf1de4e5af4bf33095bc8eca355118893aaf60bbe4ad617c54f53cc2357ef507cd6c4202069421206b53632356e3bf472d72bbeba32a83acd679a94e9d3a43b05a1a7b39768e0c3ddbfc663c3245e5b7a7a741f992ccb82b2b8335ba0a42c5b964ded4b3d940f95b7d74255b2ab6075010c1255764d0ce9a05bcf19da73f503c50c593ce2ce6611d2a2dd73e6f87a45f5d291d6d8b269671297d1f35b38932aaea90ebc9b69b86e1411156ec6ee79ec13ad3437cdc22f184cc31b249d221881c9ea55297d851414089136ef937793ea188aa8a22c4fd02a019263985d11ec768d4ea84c45f19b5b8fde664f3368736c8bf30a17b0f6f19725fd1c173e34e446cdca852bdcffaeb8f8250b930fd71c99ac46f34f596b1f344867aa2bb04015a700289b483215bf21a2383bbcb3db22048a12de8fd44f9f1a08222feb6f9d8cc96dde400240f7ac6ace40f6e6c705f77304ffa39f4928cac5e5f772caa1db007cf139b66d48c3e70295076e98fdcc99e8b05ee48fc692fea423ce2d2e81842a2c91a5161272372398f636645e949f55076742516aabc0960aa01547816f88d6a71d1f8cb60170b54d945aadf0fc15a1c8e15c563039475c20b418258efadc6dc605c0cf7003bfbe6d2c6f85b3b67840c1c16afd8b22c94822df81f63957d1bf0ea712d74ce52715c1dcd57329e07a73cdbf5aca</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>重积分</title>
    <url>/2021/08/20/%E9%87%8D%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h1><h2 id="二重积分换元法"><a href="#二重积分换元法" class="headerlink" title="二重积分换元法"></a>二重积分换元法</h2><p>在介绍二重积分换元前，先来回顾一下定积分的还原方法</p>
<script type="math/tex; mode=display">
\int_a^bf(x)dx\xlongequal{x=x(t)}\int_c^df(x(t))dx(t)=\int_c^df(x)x^{'}(t)dt</script><p>这里我们可以有一种直观的理解方式，一开始我们的积分对应的微元是一条长为dx的线，而经过还原后，我们积分对应的微元是一条长为dt的线，这两条线之间肯定会有一个倍数关系，而这个倍数关系就是 $\dfrac{dx}{dt}$，也就是 $x’(t)$ ，<br>所以</p>
<script type="math/tex; mode=display">
dx=\dfrac{dx}{dt}·dt=x^{'}(t)</script><p>根据这样的理解，我们再来看一看二重积分的换元法</p>
<span id="more"></span>
<script type="math/tex; mode=display">
\iint\limits_{D}f(x,y)dxdy\xlongequal[y=y(u,v)]{x=x(u,v)}\iint\limits_{D_1}f(x,y)dx(u,v)dy(u,v)</script><p>这里的面积微元 $dA=dxdy$ 和 $dA_1=dudv$ 又有什么样的倍数关系呢？</p>
<p><img src="/2021/08/20/%E9%87%8D%E7%A7%AF%E5%88%86/p1.png"></p>
<p><strong>方法一</strong></p>
<p>直接推导，并不直观</p>
<p>由图可得</p>
<script type="math/tex; mode=display">
\begin{aligned}
dA_1
&=|dudv\sin\theta_1|\\
&=|du\times dv|\\
\\
dA
&=|dxdy\sin\theta|\\
&=|dx\times dy|\\
&=|(x_udu+x_vdv)\times(y_udu+y_vdv)|\\
&=x_udu\times y_vdv+x_vdv\times y_udu\\
&=(x_uy_v-x_vy_u)du\times dv\\
&=\begin{vmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}
\end{vmatrix}\;dA_1
\end{aligned}</script><p>这里是通过全微分的知识得到的</p>
<script type="math/tex; mode=display">
dx=\dfrac{\partial x}{\partial u}du+\dfrac{\partial x}{\partial v}dv</script><script type="math/tex; mode=display">
dy=\dfrac{\partial y}{\partial u}du+\dfrac{\partial y}{\partial v}dv</script><p><strong>方法二</strong></p>
<p>直接用线性代数的知识，比较直观</p>
<p>我们也可以将全微分用矩阵的形式表示，即</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}
\end{bmatrix}
\begin{bmatrix}
du\\
\\
dv
\end{bmatrix}=
\begin{bmatrix}
dx\\
\\
dy
\end{bmatrix}</script><p>这样就得到了它们之间的内在联系</p>
<p>两边同时取行列式，注意这里的dx、dy、du、dv都是平面中的向量，所以默认上面都是方阵，为了表达方便就不再改写。</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}
\end{vmatrix}
\begin{vmatrix}
du\\
\\
dv
\end{vmatrix}=
\begin{vmatrix}
dx\\
\\
dy
\end{vmatrix}</script><p>也就是</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}
\end{vmatrix}dudv=dxdy</script><p>其中</p>
<p>$<br>\begin{bmatrix}<br>\dfrac{\partial x}{\partial u}&amp;\dfrac{\partial x}{\partial v}\\<br>\\<br>\dfrac{\partial y}{\partial u}&amp;\dfrac{\partial y}{\partial v}<br>\end{bmatrix}<br>$<br>这个矩阵被称为 <strong>雅可比矩阵</strong>，对应的行列式就是 <strong>雅可比行列式</strong><br>用 $J$ 表示</p>
<p>所以我们就得到了二重积分换元法</p>
<script type="math/tex; mode=display">
\iint\limits_{D}f(x,y)dxdy\xlongequal[y=y(u,v)]{x=x(u,v)}\iint\limits_{D_1}f(u,v)\begin{vmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}
\end{vmatrix}dudv</script><p><strong>例题</strong></p>
<p>计算</p>
<script type="math/tex; mode=display">\iint_D\dfrac{(x+y)\ln(1+\dfrac{y}{x})}{\sqrt{1-x-y}}dxdy</script><p>其中区域 $D$ 由直线$x+y=1$与两坐标轴所围三角形区域</p>
<p>解：令 $\sqrt{1-x-y}=u$，$1+\dfrac{y}{x}=v$，得到</p>
<p>$x=\dfrac{1-u^2}{v}$，$y=(1-u^2)(1-\dfrac{1}{v})$</p>
<p>$D_{uv}=\{\;(x,y)|0&lt;u\leqslant1,1\leqslant v&lt;+∞ \;\}$</p>
<script type="math/tex; mode=display">
\begin{aligned}
J=\dfrac{\partial(x,y)}{\partial(u,v)}&=\begin{vmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}
\end{vmatrix}\\
&=
\begin{vmatrix}
-\dfrac{2u}{v}&\dfrac{u^2-1}{v^2}\\
-2u\,(1-\dfrac{1}{v})&\dfrac{1-u^2}{v^2}
\end{vmatrix}\\
&=\dfrac{2u(1-u^2)}{v^2}
\end{aligned}</script><p>$\therefore$ </p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{原式}&=
\iint\limits_{D_{uv}}\frac{(1-u^2)\ln v}{u}\;·\;\frac{2u(1-u^2)}{v^2}dudv\\
&=2\iint\limits_{D_{uv}}(1-u^2)^2\;\frac{\ln v}{v^2}dudv\\
&=2\int_1^∞\frac{\ln v}{v^2}dv\int_0^1(1-u^2)^2du\\
&=2\left(-\frac{\ln v}{v}\bigg|_1^∞+\int_1^∞\frac{1}{v^2}dv\right)\left[\frac15u^5-frac23u^3+u\right]_0^1\\
&=\frac{16}{15}
\end{aligned}</script><h1 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h1><p>类比二重积分换元法，三重积分换元法同样有</p>
<script type="math/tex; mode=display">
dxdydz=\begin{vmatrix}
\dfrac{\partial x}{\partial u}&\dfrac{\partial x}{\partial v}&\dfrac{\partial x}{\partial w}\\
\\
\dfrac{\partial y}{\partial u}&\dfrac{\partial y}{\partial v}&\dfrac{\partial y}{\partial w}\\
\\
\dfrac{\partial z}{\partial u}&\dfrac{\partial z}{\partial v}&\dfrac{\partial z}{\partial w}
\end{vmatrix}\;dudvdw</script><p>当然这种方法可推至n维，但是其计算难度也在递增</p>
]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
      </tags>
  </entry>
</search>
